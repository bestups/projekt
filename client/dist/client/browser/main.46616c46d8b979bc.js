(self.webpackChunkclient=self.webpackChunkclient||[]).push([[792],{386:(Dt,It,U)=>{"use strict";var We={};U.r(We),U.d(We,{arraysEqual:()=>wt,arraysEqualWithNull:()=>M4,assert:()=>S,assertNonNegativeIntegerDimensions:()=>Ks,assertNonNull:()=>vc,assertShapesMatch:()=>Pr,bytesFromStringArray:()=>$4,bytesPerElement:()=>Ag,checkConversionForErrors:()=>O4,clamp:()=>Bl,computeStrides:()=>Oe,convertBackendValuesAndArrayBuffer:()=>V4,createScalarValue:()=>$a,createShuffledIndices:()=>Fpe,decodeString:()=>Pa,distSquared:()=>Rpe,encodeString:()=>qi,fetch:()=>Q4,fingerPrint64:()=>Z4,flatten:()=>Ki,getArrayFromDType:()=>On,getTypedArrayFromDType:()=>Er,hasEncodingLoss:()=>R1,hexToLong:()=>By,indexToLoc:()=>Cc,inferDtype:()=>xc,inferFromImplicitShape:()=>A1,isBoolean:()=>P4,isFunction:()=>zl,isInt:()=>bc,isNumber:()=>l0,isPromise:()=>Fa,isScalarShape:()=>Mpe,isString:()=>Gi,isTypedArray:()=>lr,isValidDtype:()=>F4,locToIndex:()=>hi,makeOnesTypedArray:()=>c0,makeZerosNestedTypedArray:()=>M1,makeZerosTypedArray:()=>Lr,nearestDivisor:()=>u0,nearestLargerEven:()=>o0,now:()=>Vr,parseAxisParam:()=>pt,randUniform:()=>Ape,repeatedTry:()=>k1,rightPad:()=>wc,shuffle:()=>T1,shuffleCombo:()=>kpe,sizeFromShape:()=>j,sizeToSquarishShape:()=>a0,squeezeShape:()=>Oa,sum:()=>R4,swap:()=>Ma,tanh:()=>Ope,toNestedArray:()=>go,toTypedArray:()=>Wl});var nr={};U.r(nr),U.d(nr,{assertTypesMatch:()=>uH,getTensorsInContainer:()=>La,isTensorInList:()=>SC,makeTypesMatch:()=>_n});var qe={};U.r(qe),U.d(qe,{isBrowser:()=>H1,isMobile:()=>W1,mockIsMobile:()=>vme});var pn={};U.r(pn),U.d(pn,{Serializable:()=>kc,SerializationMap:()=>bo,getRegisteredName:()=>wge,registerClass:()=>oe});var ct={};U.r(ct),U.d(ct,{assertAndGetBroadcastShape:()=>et,getBroadcastDims:()=>Rc,getReductionAxes:()=>er});var Pe={};U.r(Pe),U.d(Pe,{CompositeArrayBuffer:()=>pi,browserFiles:()=>Mge,browserHTTPRequest:()=>Vge,concatenateArrayBuffers:()=>CH,copyModel:()=>tge,decodeWeights:()=>yH,decodeWeightsStream:()=>wH,encodeWeights:()=>K1,fromMemory:()=>zge,fromMemorySync:()=>UH,getLoadHandlers:()=>Ume,getModelArtifactsForJSON:()=>ek,getModelArtifactsForJSONSync:()=>_H,getModelArtifactsInfoForJSON:()=>qy,getSaveHandlers:()=>EH,getWeightSpecs:()=>nk,http:()=>Sk,isHTTPScheme:()=>Ik,listModels:()=>Jme,loadWeights:()=>Fge,moveModel:()=>nge,registerLoadRouter:()=>zme,registerSaveRouter:()=>Bme,removeModel:()=>ege,weightsLoaderFactory:()=>LH,withSaveHandler:()=>Uge,withSaveHandlerSync:()=>Wge});var lt={};U.r(lt),U.d(lt,{confusionMatrix:()=>Zge});var Se={};U.r(Se),U.d(Se,{draw:()=>oye,fromPixels:()=>Tk,fromPixelsAsync:()=>nye,toPixels:()=>sye});var z={};U.r(z),U.d(z,{prepareAndValidate:()=>RC});var he={};U.r(he),U.d(he,{calculateShapes:()=>ql,validateInput:()=>MC,validateUpdateShape:()=>kk});var ve={};U.r(ve),U.d(ve,{assertParamsValid:()=>Rk,computeFlatOffset:()=>Fk,computeOutShape:()=>Mk,getNormalizedAxes:()=>lye,isSliceContinous:()=>Ok,maskToAxes:()=>aye,parseSliceParams:()=>OC,sliceInfo:()=>$k,startForAxis:()=>QH,startIndicesWithElidedDims:()=>XH,stopForAxis:()=>JH,stopIndicesWithElidedDims:()=>YH,stridesForAxis:()=>ZH,stridesWithElidedDims:()=>GH});var re={};U.r(re),U.d(re,{TEST_EPSILON_FLOAT16:()=>tj,createVideoElement:()=>yye,encodeStrings:()=>nj,expectArrayBuffersEqual:()=>gye,expectArraysClose:()=>dye,expectArraysEqual:()=>fye,expectNumbersClose:()=>pye,expectPromiseToFail:()=>hye,expectValuesInRange:()=>mye,play:()=>vye,testEpsilon:()=>Pk});var ce={};U.r(ce),U.d(ce,{conv2d:()=>qj,depthwiseConv2d:()=>Hwe,matMul:()=>GA});var Ne={};U.r(Ne),U.d(Ne,{collectGatherOpShapeInfo:()=>bR,computeOutShape:()=>AG,segOpComputeOptimalWindowSize:()=>kG});var Me={};U.r(Me),U.d(Me,{ERF_A1:()=>oR,ERF_A2:()=>iR,ERF_A3:()=>aR,ERF_A4:()=>lR,ERF_A5:()=>uR,ERF_P:()=>sR,PARALLELIZE_THRESHOLD:()=>eR,RowPartitionType:()=>na,SELU_SCALE:()=>yI,SELU_SCALEALPHA:()=>gI,applyActivation:()=>cI,assertAndGetBroadcastShape:()=>et,assertAxesAreInnerMostDims:()=>Ur,assertParamsConsistent:()=>JA,assignToTypedArray:()=>pG,axesAreInnerMostDims:()=>pA,calculateShapes:()=>ql,checkEinsumDimSizes:()=>pR,checkPadOnDimRoundingMode:()=>hs,combineLocations:()=>hj,combineRaggedTensorToTensorShapes:()=>aG,complexWithEvenIndex:()=>hG,complexWithOddIndex:()=>fG,computeConv2DInfo:()=>Tr,computeConv3DInfo:()=>Xl,computeDefaultPad:()=>Xk,computeDilation2DInfo:()=>Yy,computeOptimalWindowSize:()=>mI,computeOutAndReduceShapes:()=>kr,computeOutShape:()=>ta,computePool2DInfo:()=>Wo,computePool3DInfo:()=>za,convertConv2DDataFormat:()=>Ua,decodeEinsumEquation:()=>hR,eitherStridesOrDilationsAreOne:()=>Br,expandShapeToKeepDim:()=>Wn,exponent:()=>gG,exponents:()=>mG,fromStringArrayToUint8:()=>RG,fromUint8ToStringArray:()=>Xa,getAxesPermutation:()=>Dn,getBroadcastDims:()=>Rc,getComplexWithIndex:()=>cR,getEinsumComputePath:()=>mR,getEinsumPermutation:()=>fR,getFusedBiasGradient:()=>uI,getFusedDyActivation:()=>lI,getImageCenter:()=>tR,getInnerMostAxes:()=>Hn,getPermuted:()=>yv,getRaggedRank:()=>uG,getReductionAxes:()=>er,getReshaped:()=>gv,getReshapedPermuted:()=>vv,getRowPartitionTypesHelper:()=>lG,getSliceBeginCoords:()=>nR,getSliceSize:()=>rR,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>bG,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>wG,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>xG,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>SG,getSparseReshapeInputOutputMismatchErrorMessage:()=>EG,getSparseReshapeInputOutputMultipleErrorMessage:()=>_G,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>CG,getSparseReshapeNegativeOutputDimErrorMessage:()=>IG,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>TG,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>vR,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>DG,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>NG,getUndoAxesPermutation:()=>Ql,isIdentityPermutation:()=>gR,log:()=>Gpe,mergeRealAndImagArrays:()=>Ka,prepareAndValidate:()=>RC,prepareSplitSize:()=>yR,segment_util:()=>Ne,shouldFuse:()=>dI,slice_util:()=>ve,splitRealAndImagArrays:()=>dG,stridesOrDilationsArePositive:()=>Fc,tupleValuesAreOne:()=>Yl,upcastType:()=>Ts,validateDefaultValueShape:()=>cG,validateInput:()=>MC,validateUpdateShape:()=>kk,warn:()=>yo});var Ut={};U.r(Ut),U.d(Ut,{nonMaxSuppressionV3Impl:()=>hI,nonMaxSuppressionV4Impl:()=>fI,nonMaxSuppressionV5Impl:()=>pI,whereImpl:()=>iI});var Kn={};U.r(Kn),U.d(Kn,{Abs:()=>Rg,Acos:()=>Fh,Acosh:()=>$h,AdadeltaOptimizer:()=>pk,AdagradOptimizer:()=>mk,AdamOptimizer:()=>gk,AdamaxOptimizer:()=>yk,Add:()=>Ic,AddN:()=>Mg,All:()=>d0,Any:()=>h0,ArgMax:()=>Og,ArgMin:()=>Fg,Asin:()=>Ph,Asinh:()=>Lh,Atan:()=>Vh,Atan2:()=>zh,Atanh:()=>Bh,AvgPool:()=>$g,AvgPool3D:()=>Pg,AvgPool3DGrad:()=>p0,AvgPoolGrad:()=>f0,BatchMatMul:()=>Lg,BatchToSpaceND:()=>Vg,Bincount:()=>m0,BitwiseAnd:()=>Bg,BroadcastArgs:()=>g0,BroadcastTo:()=>W4,Cast:()=>Uh,Ceil:()=>Wh,ClipByValue:()=>Hh,Complex:()=>y0,ComplexAbs:()=>zg,Concat:()=>Ug,Conv2D:()=>Wg,Conv2DBackpropFilter:()=>v0,Conv2DBackpropInput:()=>Hg,Conv3D:()=>jg,Conv3DBackpropFilterV2:()=>b0,Conv3DBackpropInputV2:()=>w0,Cos:()=>jh,Cosh:()=>Gh,CropAndResize:()=>C0,Cumprod:()=>x0,Cumsum:()=>Gg,DataStorage:()=>N1,DenseBincount:()=>I0,DepthToSpace:()=>S0,DepthwiseConv2dNative:()=>qg,DepthwiseConv2dNativeBackpropFilter:()=>_0,DepthwiseConv2dNativeBackpropInput:()=>E0,Diag:()=>D0,Dilation2D:()=>Kg,Dilation2DBackpropFilter:()=>T0,Dilation2DBackpropInput:()=>N0,Draw:()=>k0,ENV:()=>O1,Einsum:()=>A0,Elu:()=>Kh,EluGrad:()=>R0,Environment:()=>z4,Equal:()=>Xg,Erf:()=>Xh,Exp:()=>Yh,ExpandDims:()=>Yg,Expm1:()=>Zh,FFT:()=>M0,Fill:()=>O0,FlipLeftRight:()=>F0,Floor:()=>Qh,FloorDiv:()=>Jh,FromPixels:()=>yC,FusedBatchNorm:()=>Zg,FusedConv2D:()=>$y,FusedDepthwiseConv2D:()=>Py,GatherNd:()=>$0,GatherV2:()=>Qg,Greater:()=>Jg,GreaterEqual:()=>ef,IFFT:()=>P0,Identity:()=>nf,Imag:()=>L0,IsFinite:()=>rf,IsInf:()=>sf,IsNan:()=>af,KernelBackend:()=>s0,LRN:()=>iy,LRNGrad:()=>B0,LeakyRelu:()=>ey,Less:()=>ty,LessEqual:()=>ny,LinSpace:()=>V0,Log:()=>lf,Log1p:()=>uf,LogSoftmax:()=>H4,LogicalAnd:()=>ry,LogicalNot:()=>sy,LogicalOr:()=>oy,LogicalXor:()=>zpe,LowerBound:()=>Upe,MatrixBandPart:()=>Wpe,Max:()=>ay,MaxPool:()=>ly,MaxPool3D:()=>uy,MaxPool3DGrad:()=>U0,MaxPoolGrad:()=>z0,MaxPoolWithArgmax:()=>W0,Maximum:()=>cf,Mean:()=>cy,Min:()=>dy,Minimum:()=>df,MirrorPad:()=>hy,Mod:()=>hf,MomentumOptimizer:()=>vk,Multinomial:()=>H0,Multiply:()=>ff,Neg:()=>fy,NonMaxSuppressionV3:()=>j0,NonMaxSuppressionV4:()=>G0,NonMaxSuppressionV5:()=>q0,NotEqual:()=>py,OP_SCOPE_SUFFIX:()=>j1,OneHot:()=>gy,OnesLike:()=>my,Optimizer:()=>Ba,OptimizerConstructors:()=>sj,Pack:()=>yy,PadV2:()=>vy,Pool:()=>Hpe,Pow:()=>pf,Prelu:()=>by,Prod:()=>wy,RMSPropOptimizer:()=>bk,RaggedGather:()=>K0,RaggedRange:()=>X0,RaggedTensorToTensor:()=>Y0,Range:()=>Z0,Rank:()=>nH,Real:()=>Q0,RealDiv:()=>qh,Reciprocal:()=>mf,Reduction:()=>Fs,Relu:()=>gf,Relu6:()=>yf,Reshape:()=>xy,ResizeBilinear:()=>Iy,ResizeBilinearGrad:()=>eC,ResizeNearestNeighbor:()=>Cy,ResizeNearestNeighborGrad:()=>J0,Reverse:()=>Sy,RotateWithOffset:()=>vC,Round:()=>vf,Rsqrt:()=>bf,SGDOptimizer:()=>AC,ScatterNd:()=>tC,SearchSorted:()=>rC,Select:()=>_y,Selu:()=>wf,Sigmoid:()=>Sf,Sign:()=>If,Sin:()=>xf,Sinh:()=>Cf,Slice:()=>Ey,Softmax:()=>ky,Softplus:()=>_f,SpaceToBatchND:()=>Ny,SparseFillEmptyRows:()=>sC,SparseReshape:()=>oC,SparseSegmentMean:()=>iC,SparseSegmentSum:()=>aC,SparseToDense:()=>lC,SplitV:()=>Ty,Sqrt:()=>Ef,Square:()=>uC,SquaredDifference:()=>Df,StaticRegexReplace:()=>Ay,Step:()=>Rf,StridedSlice:()=>cC,StringNGrams:()=>dC,StringSplit:()=>hC,StringToHashBucketFast:()=>fC,Sub:()=>Nf,Sum:()=>Dy,Tan:()=>Tf,Tanh:()=>kf,Tensor:()=>St,TensorBuffer:()=>Qn,TensorScatterUpdate:()=>nC,Tile:()=>Af,TopK:()=>pC,Transform:()=>mC,Transpose:()=>Sc,Unique:()=>gC,Unpack:()=>Ry,UnsortedSegmentSum:()=>My,UpperBound:()=>jpe,Variable:()=>Hy,ZerosLike:()=>Oy,_FusedMatMul:()=>Fy,abs:()=>Jn,acos:()=>zk,acosh:()=>Uk,add:()=>ne,addN:()=>oj,all:()=>FC,any:()=>Xy,argMax:()=>Kl,argMin:()=>Wk,asin:()=>Hk,asinh:()=>jk,atan:()=>Gk,atan2:()=>qk,atanh:()=>Kk,avgPool:()=>Jy,avgPool3d:()=>Zk,backend:()=>EC,backend_util:()=>Me,basicLSTMCell:()=>ij,batchNorm:()=>zf,batchNorm2d:()=>Qk,batchNorm3d:()=>Jk,batchNorm4d:()=>eA,batchToSpaceND:()=>ev,bincount:()=>tA,bitwiseAnd:()=>aj,booleanMaskAsync:()=>zj,broadcastArgs:()=>lj,broadcastTo:()=>$c,broadcast_util:()=>ct,browser:()=>Se,buffer:()=>it,cast:()=>pe,ceil:()=>nA,clipByValue:()=>As,clone:()=>Zi,complex:()=>Va,concat:()=>Un,concat1d:()=>rA,concat2d:()=>sA,concat3d:()=>oA,concat4d:()=>iA,conv1d:()=>$C,conv2d:()=>Wa,conv2dTranspose:()=>PC,conv3d:()=>lA,conv3dTranspose:()=>uA,copyRegisteredKernels:()=>Xpe,cos:()=>tv,cosh:()=>LC,cosineWindow:()=>aI,cumprod:()=>nv,cumsum:()=>VC,customGrad:()=>Qi,denseBincount:()=>BC,deprecationWarn:()=>mH,depthToSpace:()=>cA,depthwiseConv2d:()=>Uf,device_util:()=>qe,diag:()=>cj,dilation2d:()=>dA,disableDeprecationWarnings:()=>Ime,dispose:()=>ot,disposeVariables:()=>Sme,div:()=>ke,divNoNan:()=>hA,dot:()=>fA,dropout:()=>UA,einsum:()=>Pc,elu:()=>Wf,enableDebugMode:()=>Cme,enableProdMode:()=>xme,enclosingPowerOfTwo:()=>WA,engine:()=>vo,ensureShape:()=>dj,env:()=>V,equal:()=>Xs,erf:()=>zC,euclideanNorm:()=>mA,exp:()=>Rs,expandDims:()=>jn,expm1:()=>gA,eye:()=>UC,fft:()=>pv,fill:()=>Ac,findBackend:()=>Nme,findBackendFactory:()=>Tme,floor:()=>Gf,floorDiv:()=>TC,fused:()=>ce,gather:()=>qf,gatherND:()=>jj,gather_util:()=>z,getBackend:()=>Gy,getGradient:()=>P1,getKernel:()=>Vy,getKernelsForBackend:()=>bC,grad:()=>mge,grads:()=>gge,greater:()=>fs,greaterEqual:()=>Ha,ifft:()=>Zf,imag:()=>Ky,image:()=>ms,inTopKAsync:()=>Gj,io:()=>Pe,irfft:()=>nI,isFinite:()=>yA,isInf:()=>vA,isNaN:()=>bA,keep:()=>ur,kernel_impls:()=>Ut,leakyRelu:()=>rv,less:()=>Kf,lessEqual:()=>Jl,linalg:()=>ZA,linspace:()=>pj,localResponseNormalization:()=>wA,log:()=>Ys,log1p:()=>sv,logSigmoid:()=>xA,logSoftmax:()=>WC,logSumExp:()=>ov,logicalAnd:()=>mi,logicalNot:()=>iv,logicalOr:()=>HC,logicalXor:()=>CA,losses:()=>sG,lowerBound:()=>mj,matMul:()=>at,math:()=>lt,max:()=>xo,maxPool:()=>av,maxPool3d:()=>IA,maxPoolWithArgmax:()=>gj,maximum:()=>ea,mean:()=>Nn,memory:()=>_C,meshgrid:()=>yj,min:()=>Hf,minimum:()=>eu,mirrorPad:()=>SA,mod:()=>_A,moments:()=>lv,movingAverage:()=>Uj,mul:()=>M,multiRNNCell:()=>vj,multinomial:()=>bj,neg:()=>on,nextFrame:()=>QA,norm:()=>jf,notEqual:()=>Vc,oneHot:()=>Mc,ones:()=>Ms,onesLike:()=>Zs,op:()=>R,outerProduct:()=>wj,pad:()=>ja,pad1d:()=>xj,pad2d:()=>Cj,pad3d:()=>EA,pad4d:()=>Ij,pool:()=>DA,pow:()=>Ji,prelu:()=>cv,print:()=>hk,prod:()=>NA,profile:()=>_me,raggedGather:()=>Sj,raggedRange:()=>_j,raggedTensorToTensor:()=>Ej,rand:()=>Dj,randomGamma:()=>Nj,randomNormal:()=>qC,randomStandardNormal:()=>Tj,randomUniform:()=>tu,randomUniformInt:()=>kj,range:()=>Ga,ready:()=>gH,real:()=>Vf,reciprocal:()=>AA,registerBackend:()=>q1,registerGradient:()=>j4,registerKernel:()=>wC,relu:()=>gi,relu6:()=>KC,removeBackend:()=>Dme,reshape:()=>O,reverse:()=>Io,reverse1d:()=>Aj,reverse2d:()=>Rj,reverse3d:()=>Mj,reverse4d:()=>Oj,rfft:()=>mv,round:()=>XC,rsqrt:()=>YC,scalar:()=>Re,scatterND:()=>Wj,scatter_util:()=>he,searchSorted:()=>GC,selu:()=>ZC,separableConv2d:()=>QC,serialization:()=>pn,setBackend:()=>G1,setPlatform:()=>kme,setdiff1dAsync:()=>Fj,sigmoid:()=>wo,sign:()=>MA,signal:()=>rG,sin:()=>JC,sinh:()=>eI,slice:()=>Et,slice1d:()=>dv,slice2d:()=>tI,slice3d:()=>hv,slice4d:()=>Yf,slice_util:()=>ve,softmax:()=>fv,softplus:()=>Lc,spaceToBatchND:()=>uv,sparse:()=>oG,sparseToDense:()=>Hj,spectral:()=>nG,split:()=>Os,sqrt:()=>Nr,square:()=>Kt,squaredDifference:()=>rI,squeeze:()=>Qs,stack:()=>ps,step:()=>Bc,stridedSlice:()=>OA,string:()=>iG,sub:()=>Ce,sum:()=>De,sumOutType:()=>IC,tan:()=>FA,tanh:()=>Zl,tensor:()=>cs,tensor1d:()=>Wr,tensor2d:()=>nu,tensor3d:()=>Ek,tensor4d:()=>$j,tensor5d:()=>Pj,tensor6d:()=>Lj,tensorScatterUpdate:()=>Vj,tensor_util:()=>nr,test_util:()=>re,tidy:()=>L,tile:()=>Co,time:()=>Eme,topk:()=>$A,train:()=>zc,transpose:()=>Ct,truncatedNormal:()=>sI,unique:()=>PA,unregisterGradient:()=>Kpe,unregisterKernel:()=>qpe,unsortedSegmentSum:()=>oI,unstack:()=>So,upcastType:()=>Ts,upperBound:()=>Bj,util:()=>We,valueAndGrad:()=>yge,valueAndGrads:()=>vge,variable:()=>LA,variableGrads:()=>OH,version_core:()=>rj,where:()=>zr,whereAsync:()=>BA,zeros:()=>tr,zerosLike:()=>_t});var Xn={};U.r(Xn),U.d(Xn,{json:()=>N_e});var Ao={};U.r(Ao),U.d(Ao,{json:()=>T_e});var no={};U.r(no),U.d(no,{json:()=>k_e});var Nt={};U.r(Nt),U.d(Nt,{json:()=>A_e});var Ft={};U.r(Ft),U.d(Ft,{json:()=>R_e});var $t={};U.r($t),U.d($t,{json:()=>M_e});var ae={};U.r(ae),U.d(ae,{json:()=>O_e});var ee={};U.r(ee),U.d(ee,{json:()=>F_e});var A={};U.r(A),U.d(A,{json:()=>$_e});var we={};U.r(we),U.d(we,{json:()=>P_e});var He={};U.r(He),U.d(He,{json:()=>L_e});var Tt={};U.r(Tt),U.d(Tt,{json:()=>V_e});var gt={};U.r(gt),U.d(gt,{json:()=>B_e});var Pt={};U.r(Pt),U.d(Pt,{json:()=>z_e});var An={};U.r(An),U.d(An,{json:()=>U_e});var $n={};U.r($n),U.d($n,{json:()=>W_e});var rr={};U.r(rr),U.d(rr,{json:()=>H_e});var wn={};U.r(wn),U.d(wn,{json:()=>j_e});var ns={};U.r(ns),U.d(ns,{json:()=>G_e});var vt={};U.r(vt),U.d(vt,{OP_SCOPE_SUFFIX:()=>j1,abs:()=>Jn,acos:()=>zk,acosh:()=>Uk,add:()=>ne,addN:()=>oj,all:()=>FC,any:()=>Xy,argMax:()=>Kl,argMin:()=>Wk,asin:()=>Hk,asinh:()=>jk,atan:()=>Gk,atan2:()=>qk,atanh:()=>Kk,avgPool:()=>Jy,avgPool3d:()=>Zk,basicLSTMCell:()=>ij,batchNorm:()=>zf,batchNorm2d:()=>Qk,batchNorm3d:()=>Jk,batchNorm4d:()=>eA,batchToSpaceND:()=>ev,bincount:()=>tA,bitwiseAnd:()=>aj,booleanMaskAsync:()=>zj,broadcastArgs:()=>lj,broadcastTo:()=>$c,buffer:()=>it,cast:()=>pe,ceil:()=>nA,clipByValue:()=>As,clone:()=>Zi,complex:()=>Va,concat:()=>Un,concat1d:()=>rA,concat2d:()=>sA,concat3d:()=>oA,concat4d:()=>iA,conv1d:()=>$C,conv2d:()=>Wa,conv2dTranspose:()=>PC,conv3d:()=>lA,conv3dTranspose:()=>uA,cos:()=>tv,cosh:()=>LC,cosineWindow:()=>aI,cumprod:()=>nv,cumsum:()=>VC,denseBincount:()=>BC,depthToSpace:()=>cA,depthwiseConv2d:()=>Uf,diag:()=>cj,dilation2d:()=>dA,div:()=>ke,divNoNan:()=>hA,dot:()=>fA,dropout:()=>UA,einsum:()=>Pc,elu:()=>Wf,enclosingPowerOfTwo:()=>WA,ensureShape:()=>dj,equal:()=>Xs,erf:()=>zC,euclideanNorm:()=>mA,exp:()=>Rs,expandDims:()=>jn,expm1:()=>gA,eye:()=>UC,fft:()=>pv,fill:()=>Ac,floor:()=>Gf,floorDiv:()=>TC,fused:()=>ce,gather:()=>qf,gatherND:()=>jj,greater:()=>fs,greaterEqual:()=>Ha,ifft:()=>Zf,imag:()=>Ky,image:()=>ms,inTopKAsync:()=>Gj,irfft:()=>nI,isFinite:()=>yA,isInf:()=>vA,isNaN:()=>bA,leakyRelu:()=>rv,less:()=>Kf,lessEqual:()=>Jl,linalg:()=>ZA,linspace:()=>pj,localResponseNormalization:()=>wA,log:()=>Ys,log1p:()=>sv,logSigmoid:()=>xA,logSoftmax:()=>WC,logSumExp:()=>ov,logicalAnd:()=>mi,logicalNot:()=>iv,logicalOr:()=>HC,logicalXor:()=>CA,losses:()=>sG,lowerBound:()=>mj,matMul:()=>at,max:()=>xo,maxPool:()=>av,maxPool3d:()=>IA,maxPoolWithArgmax:()=>gj,maximum:()=>ea,mean:()=>Nn,meshgrid:()=>yj,min:()=>Hf,minimum:()=>eu,mirrorPad:()=>SA,mod:()=>_A,moments:()=>lv,movingAverage:()=>Uj,mul:()=>M,multiRNNCell:()=>vj,multinomial:()=>bj,neg:()=>on,norm:()=>jf,notEqual:()=>Vc,oneHot:()=>Mc,ones:()=>Ms,onesLike:()=>Zs,op:()=>R,outerProduct:()=>wj,pad:()=>ja,pad1d:()=>xj,pad2d:()=>Cj,pad3d:()=>EA,pad4d:()=>Ij,pool:()=>DA,pow:()=>Ji,prelu:()=>cv,print:()=>hk,prod:()=>NA,raggedGather:()=>Sj,raggedRange:()=>_j,raggedTensorToTensor:()=>Ej,rand:()=>Dj,randomGamma:()=>Nj,randomNormal:()=>qC,randomStandardNormal:()=>Tj,randomUniform:()=>tu,randomUniformInt:()=>kj,range:()=>Ga,real:()=>Vf,reciprocal:()=>AA,relu:()=>gi,relu6:()=>KC,reshape:()=>O,reverse:()=>Io,reverse1d:()=>Aj,reverse2d:()=>Rj,reverse3d:()=>Mj,reverse4d:()=>Oj,rfft:()=>mv,round:()=>XC,rsqrt:()=>YC,scalar:()=>Re,scatterND:()=>Wj,searchSorted:()=>GC,selu:()=>ZC,separableConv2d:()=>QC,setdiff1dAsync:()=>Fj,sigmoid:()=>wo,sign:()=>MA,signal:()=>rG,sin:()=>JC,sinh:()=>eI,slice:()=>Et,slice1d:()=>dv,slice2d:()=>tI,slice3d:()=>hv,slice4d:()=>Yf,softmax:()=>fv,softplus:()=>Lc,spaceToBatchND:()=>uv,sparse:()=>oG,sparseToDense:()=>Hj,spectral:()=>nG,split:()=>Os,sqrt:()=>Nr,square:()=>Kt,squaredDifference:()=>rI,squeeze:()=>Qs,stack:()=>ps,step:()=>Bc,stridedSlice:()=>OA,string:()=>iG,sub:()=>Ce,sum:()=>De,tan:()=>FA,tanh:()=>Zl,tensor:()=>cs,tensor1d:()=>Wr,tensor2d:()=>nu,tensor3d:()=>Ek,tensor4d:()=>$j,tensor5d:()=>Pj,tensor6d:()=>Lj,tensorScatterUpdate:()=>Vj,tile:()=>Co,topk:()=>$A,transpose:()=>Ct,truncatedNormal:()=>sI,unique:()=>PA,unsortedSegmentSum:()=>oI,unstack:()=>So,upperBound:()=>Bj,variable:()=>LA,where:()=>zr,whereAsync:()=>BA,zeros:()=>tr,zerosLike:()=>_t});var qr={};function xu(e,n,t,r,s,o,i){try{var a=e[o](i),l=a.value}catch(u){return void t(u)}a.done?n(l):Promise.resolve(l).then(r,s)}function F(e){return function(){var n=this,t=arguments;return new Promise(function(r,s){var o=e.apply(n,t);function i(l){xu(o,r,s,i,a,"next",l)}function a(l){xu(o,r,s,i,a,"throw",l)}i(void 0)})}}function BS(e,n){return Object.is(e,n)}U.r(qr),U.d(qr,{mx:()=>X6,XI:()=>MM,Nk:()=>t5,f6:()=>n5,ct:()=>K6,YG:()=>r5,hH:()=>s5,z3:()=>a5,sG:()=>u5,uM:()=>d5,vS:()=>p5,qB:()=>m5,GG:()=>g5,lg:()=>v5,rq:()=>y5,cu:()=>w5,WR:()=>b5,GE:()=>x5,px:()=>C5,jC:()=>I5,He:()=>_5,hE:()=>E5,BF:()=>OM,Dk:()=>N5,cl:()=>T5,_B:()=>M5,ub:()=>F5,_f:()=>P5,Ku:()=>B5,qy:()=>z5,Zy:()=>U5,bu:()=>Qc,zv:()=>SDe,dH:()=>Z6,HS:()=>e5,yH:()=>H5,l3:()=>j5,z9:()=>BM,x6:()=>ZAe,_m:()=>G5,eW:()=>q5,GK:()=>K5,SP:()=>X5,yr:()=>Y5,dl:()=>h5,Dw:()=>Z5,xT:()=>J5,_X:()=>AM,wz:()=>t8});let mr=null,Sp=!1,zS=1;const gr=Symbol("SIGNAL");function st(e){const n=mr;return mr=e,n}const Cu={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,kind:"unknown",producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function Iu(e){if(Sp)throw new Error("");if(null===mr)return;mr.consumerOnSignalRead(e);const n=mr.nextProducerIndex++;qv(mr),n<mr.producerNode.length&&mr.producerNode[n]!==e&&Dp(mr)&&Gv(mr.producerNode[n],mr.producerIndexOfThis[n]),mr.producerNode[n]!==e&&(mr.producerNode[n]=e,mr.producerIndexOfThis[n]=Dp(mr)?gO(e,mr,n):0),mr.producerLastReadVersion[n]=e.version}function sl(e){if((!Dp(e)||e.dirty)&&(e.dirty||e.lastCleanEpoch!==zS)){if(!e.producerMustRecompute(e)&&!_p(e))return void id(e);e.producerRecomputeValue(e),id(e)}}function fO(e){if(void 0===e.liveConsumerNode)return;const n=Sp;Sp=!0;try{for(const t of e.liveConsumerNode)t.dirty||mO(t)}finally{Sp=n}}function pO(){return!1!==mr?.consumerAllowSignalWrites}function mO(e){e.dirty=!0,fO(e),e.consumerMarkedDirty?.(e)}function id(e){e.dirty=!1,e.lastCleanEpoch=zS}function Su(e){return e&&(e.nextProducerIndex=0),st(e)}function ad(e,n){if(st(n),e&&void 0!==e.producerNode&&void 0!==e.producerIndexOfThis&&void 0!==e.producerLastReadVersion){if(Dp(e))for(let t=e.nextProducerIndex;t<e.producerNode.length;t++)Gv(e.producerNode[t],e.producerIndexOfThis[t]);for(;e.producerNode.length>e.nextProducerIndex;)e.producerNode.pop(),e.producerLastReadVersion.pop(),e.producerIndexOfThis.pop()}}function _p(e){qv(e);for(let n=0;n<e.producerNode.length;n++){const t=e.producerNode[n],r=e.producerLastReadVersion[n];if(r!==t.version||(sl(t),r!==t.version))return!0}return!1}function Ep(e){if(qv(e),Dp(e))for(let n=0;n<e.producerNode.length;n++)Gv(e.producerNode[n],e.producerIndexOfThis[n]);e.producerNode.length=e.producerLastReadVersion.length=e.producerIndexOfThis.length=0,e.liveConsumerNode&&(e.liveConsumerNode.length=e.liveConsumerIndexOfThis.length=0)}function gO(e,n,t){if(yO(e),0===e.liveConsumerNode.length&&vO(e))for(let r=0;r<e.producerNode.length;r++)e.producerIndexOfThis[r]=gO(e.producerNode[r],e,r);return e.liveConsumerIndexOfThis.push(t),e.liveConsumerNode.push(n)-1}function Gv(e,n){if(yO(e),1===e.liveConsumerNode.length&&vO(e))for(let r=0;r<e.producerNode.length;r++)Gv(e.producerNode[r],e.producerIndexOfThis[r]);const t=e.liveConsumerNode.length-1;if(e.liveConsumerNode[n]=e.liveConsumerNode[t],e.liveConsumerIndexOfThis[n]=e.liveConsumerIndexOfThis[t],e.liveConsumerNode.length--,e.liveConsumerIndexOfThis.length--,n<e.liveConsumerNode.length){const r=e.liveConsumerIndexOfThis[n],s=e.liveConsumerNode[n];qv(s),s.producerIndexOfThis[r]=n}}function Dp(e){return e.consumerIsAlwaysLive||(e?.liveConsumerNode?.length??0)>0}function qv(e){e.producerNode??=[],e.producerIndexOfThis??=[],e.producerLastReadVersion??=[]}function yO(e){e.liveConsumerNode??=[],e.liveConsumerIndexOfThis??=[]}function vO(e){return void 0!==e.producerNode}const WS=Symbol("UNSET"),HS=Symbol("COMPUTING"),Np=Symbol("ERRORED"),eX={...Cu,value:WS,dirty:!0,error:null,equal:BS,kind:"computed",producerMustRecompute:e=>e.value===WS||e.value===HS,producerRecomputeValue(e){if(e.value===HS)throw new Error("Detected cycle in computations.");const n=e.value;e.value=HS;const t=Su(e);let r,s=!1;try{r=e.computation(),st(null),s=n!==WS&&n!==Np&&r!==Np&&e.equal(n,r)}catch(o){r=Np,e.error=o}finally{ad(e,t)}s?e.value=n:(e.value=r,e.version++)}};let bO=function tX(){throw new Error};function wO(){bO()}function Tp(e,n){pO()||wO(),e.equal(e.value,n)||(e.value=n,function sX(e){e.version++,function QK(){zS++}(),fO(e)}(e))}const GS={...Cu,equal:BS,value:void 0,kind:"signal"};function mn(e){return"function"==typeof e}function KS(e){const t=e(r=>{Error.call(r),r.stack=(new Error).stack});return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}const XS=KS(e=>function(t){e(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=t});function YS(e,n){if(e){const t=e.indexOf(n);0<=t&&e.splice(t,1)}}class bs{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;const{_parentage:t}=this;if(t)if(this._parentage=null,Array.isArray(t))for(const o of t)o.remove(this);else t.remove(this);const{initialTeardown:r}=this;if(mn(r))try{r()}catch(o){n=o instanceof XS?o.errors:[o]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const o of s)try{IO(o)}catch(i){n=n??[],i instanceof XS?n=[...n,...i.errors]:n.push(i)}}if(n)throw new XS(n)}}add(n){var t;if(n&&n!==this)if(this.closed)IO(n);else{if(n instanceof bs){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=null!==(t=this._finalizers)&&void 0!==t?t:[]).push(n)}}_hasParent(n){const{_parentage:t}=this;return t===n||Array.isArray(t)&&t.includes(n)}_addParent(n){const{_parentage:t}=this;this._parentage=Array.isArray(t)?(t.push(n),t):t?[t,n]:n}_removeParent(n){const{_parentage:t}=this;t===n?this._parentage=null:Array.isArray(t)&&YS(t,n)}remove(n){const{_finalizers:t}=this;t&&YS(t,n),n instanceof bs&&n._removeParent(this)}}bs.EMPTY=(()=>{const e=new bs;return e.closed=!0,e})();const xO=bs.EMPTY;function CO(e){return e instanceof bs||e&&"closed"in e&&mn(e.remove)&&mn(e.add)&&mn(e.unsubscribe)}function IO(e){mn(e)?e():e.unsubscribe()}const _u={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Xv={setTimeout(e,n,...t){const{delegate:r}=Xv;return r?.setTimeout?r.setTimeout(e,n,...t):setTimeout(e,n,...t)},clearTimeout(e){const{delegate:n}=Xv;return(n?.clearTimeout||clearTimeout)(e)},delegate:void 0};function SO(e){Xv.setTimeout(()=>{const{onUnhandledError:n}=_u;if(!n)throw e;n(e)})}function ZS(){}const lX=QS("C",void 0,void 0);function QS(e,n,t){return{kind:e,value:n,error:t}}let Eu=null;function Yv(e){if(_u.useDeprecatedSynchronousErrorHandling){const n=!Eu;if(n&&(Eu={errorThrown:!1,error:null}),e(),n){const{errorThrown:t,error:r}=Eu;if(Eu=null,t)throw r}}else e()}class JS extends bs{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,CO(n)&&n.add(this)):this.destination=mX}static create(n,t,r){return new t_(n,t,r)}next(n){this.isStopped?n_(function cX(e){return QS("N",e,void 0)}(n),this):this._next(n)}error(n){this.isStopped?n_(function uX(e){return QS("E",void 0,e)}(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?n_(lX,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const hX=Function.prototype.bind;function e_(e,n){return hX.call(e,n)}class fX{constructor(n){this.partialObserver=n}next(n){const{partialObserver:t}=this;if(t.next)try{t.next(n)}catch(r){Zv(r)}}error(n){const{partialObserver:t}=this;if(t.error)try{t.error(n)}catch(r){Zv(r)}else Zv(n)}complete(){const{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(t){Zv(t)}}}class t_ extends JS{constructor(n,t,r){let s;if(super(),mn(n)||!n)s={next:n??void 0,error:t??void 0,complete:r??void 0};else{let o;this&&_u.useDeprecatedNextContext?(o=Object.create(n),o.unsubscribe=()=>this.unsubscribe(),s={next:n.next&&e_(n.next,o),error:n.error&&e_(n.error,o),complete:n.complete&&e_(n.complete,o)}):s=n}this.destination=new fX(s)}}function Zv(e){_u.useDeprecatedSynchronousErrorHandling?function dX(e){_u.useDeprecatedSynchronousErrorHandling&&Eu&&(Eu.errorThrown=!0,Eu.error=e)}(e):SO(e)}function n_(e,n){const{onStoppedNotification:t}=_u;t&&Xv.setTimeout(()=>t(e,n))}const mX={closed:!0,next:ZS,error:function pX(e){throw e},complete:ZS},r_="function"==typeof Symbol&&Symbol.observable||"@@observable";function Du(e){return e}function _O(e){return 0===e.length?Du:1===e.length?e[0]:function(t){return e.reduce((r,s)=>s(r),t)}}let sr=(()=>{class e{constructor(t){t&&(this._subscribe=t)}lift(t){const r=new e;return r.source=this,r.operator=t,r}subscribe(t,r,s){const o=function vX(e){return e&&e instanceof JS||function yX(e){return e&&mn(e.next)&&mn(e.error)&&mn(e.complete)}(e)&&CO(e)}(t)?t:new t_(t,r,s);return Yv(()=>{const{operator:i,source:a}=this;o.add(i?i.call(o,a):a?this._subscribe(o):this._trySubscribe(o))}),o}_trySubscribe(t){try{return this._subscribe(t)}catch(r){t.error(r)}}forEach(t,r){return new(r=EO(r))((s,o)=>{const i=new t_({next:a=>{try{t(a)}catch(l){o(l),i.unsubscribe()}},error:o,complete:s});this.subscribe(i)})}_subscribe(t){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(t)}[r_](){return this}pipe(...t){return _O(t)(this)}toPromise(t){return new(t=EO(t))((r,s)=>{let o;this.subscribe(i=>o=i,i=>s(i),()=>r(o))})}}return e.create=n=>new e(n),e})();function EO(e){var n;return null!==(n=e??_u.Promise)&&void 0!==n?n:Promise}const bX=KS(e=>function(){e(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Ls=(()=>{class e extends sr{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(t){const r=new DO(this,this);return r.operator=t,r}_throwIfClosed(){if(this.closed)throw new bX}next(t){Yv(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(t)}})}error(t){Yv(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=t;const{observers:r}=this;for(;r.length;)r.shift().error(t)}})}complete(){Yv(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:t}=this;for(;t.length;)t.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var t;return(null===(t=this.observers)||void 0===t?void 0:t.length)>0}_trySubscribe(t){return this._throwIfClosed(),super._trySubscribe(t)}_subscribe(t){return this._throwIfClosed(),this._checkFinalizedStatuses(t),this._innerSubscribe(t)}_innerSubscribe(t){const{hasError:r,isStopped:s,observers:o}=this;return r||s?xO:(this.currentObservers=null,o.push(t),new bs(()=>{this.currentObservers=null,YS(o,t)}))}_checkFinalizedStatuses(t){const{hasError:r,thrownError:s,isStopped:o}=this;r?t.error(s):o&&t.complete()}asObservable(){const t=new sr;return t.source=this,t}}return e.create=(n,t)=>new DO(n,t),e})();class DO extends Ls{constructor(n,t){super(),this.destination=n,this.source=t}next(n){var t,r;null===(r=null===(t=this.destination)||void 0===t?void 0:t.next)||void 0===r||r.call(t,n)}error(n){var t,r;null===(r=null===(t=this.destination)||void 0===t?void 0:t.error)||void 0===r||r.call(t,n)}complete(){var n,t;null===(t=null===(n=this.destination)||void 0===n?void 0:n.complete)||void 0===t||t.call(n)}_subscribe(n){var t,r;return null!==(r=null===(t=this.source)||void 0===t?void 0:t.subscribe(n))&&void 0!==r?r:xO}}class Ro extends Ls{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){const t=super._subscribe(n);return!t.closed&&n.next(this._value),t}getValue(){const{hasError:n,thrownError:t,_value:r}=this;if(n)throw t;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}}function NO(e){return mn(e?.lift)}function Kr(e){return n=>{if(NO(n))return n.lift(function(t){try{return e(t,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function yr(e,n,t,r,s){return new wX(e,n,t,r,s)}class wX extends JS{constructor(n,t,r,s,o,i){super(n),this.onFinalize=o,this.shouldUnsubscribe=i,this._next=t?function(a){try{t(a)}catch(l){n.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){n.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:t}=this;super.unsubscribe(),!t&&(null===(n=this.onFinalize)||void 0===n||n.call(this))}}}function Rt(e,n){return Kr((t,r)=>{let s=0;t.subscribe(yr(r,o=>{r.next(e.call(n,o,s++))}))})}const TO="https://g.co/ng/security#xss";class te extends Error{code;constructor(n,t){super(function Nu(e,n){return`NG0${Math.abs(e)}${n?": "+n:""}`}(n,t)),this.code=n}}const Qv=Symbol("InputSignalNode#UNSET"),kO={...GS,transformFn:void 0,applyValueToInputSignal(e,n){Tp(e,n)}};function AO(e,n){const t=Object.create(kO);function r(){if(Iu(t),t.value===Qv)throw new te(-950,!1);return t.value}return t.value=e,t.transformFn=n?.transform,r[gr]=t,r}function ma(e){return{toString:e}.toString()}const ud="__parameters__";function dd(e,n,t){return ma(()=>{const r=function s_(e){return function(...t){if(e){const r=e(...t);for(const s in r)this[s]=r[s]}}}(n);function s(...o){if(this instanceof s)return r.apply(this,o),this;const i=new s(...o);return a.annotation=i,a;function a(l,u,c){const d=l.hasOwnProperty(ud)?l[ud]:Object.defineProperty(l,ud,{value:[]})[ud];for(;d.length<=c;)d.push(null);return(d[c]=d[c]||[]).push(i),l}}return t&&(s.prototype=Object.create(t.prototype)),s.prototype.ngMetadataName=e,s.annotationCls=s,s})}const gn=globalThis;function jt(e){for(let n in e)if(e[n]===jt)return n;throw Error("Could not find renamed property on target object.")}function xX(e,n){for(const t in n)n.hasOwnProperty(t)&&!e.hasOwnProperty(t)&&(e[t]=n[t])}function vr(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(vr).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const n=e.toString();if(null==n)return""+n;const t=n.indexOf("\n");return-1===t?n:n.substring(0,t)}function o_(e,n){return null==e||""===e?null===n?"":n:null==n||""===n?e:e+" "+n}const CX=jt({__forward_ref__:jt});function cn(e){return e.__forward_ref__=cn,e.toString=function(){return vr(this())},e}function Ke(e){return Jv(e)?e():e}function Jv(e){return"function"==typeof e&&e.hasOwnProperty(CX)&&e.__forward_ref__===cn}function _e(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function il(e){return{providers:e.providers||[],imports:e.imports||[]}}function eb(e){return MO(e,nb)||MO(e,OO)}function MO(e,n){return e.hasOwnProperty(n)?e[n]:null}function tb(e){return e&&(e.hasOwnProperty(i_)||e.hasOwnProperty(NX))?e[i_]:null}const nb=jt({\u0275prov:jt}),i_=jt({\u0275inj:jt}),OO=jt({ngInjectableDef:jt}),NX=jt({ngInjectorDef:jt});class fe{_desc;ngMetadataName="InjectionToken";\u0275prov;constructor(n,t){this._desc=n,this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=_e({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function u_(e){return e&&!!e.\u0275providers}const hd=jt({\u0275cmp:jt}),c_=jt({\u0275dir:jt}),d_=jt({\u0275pipe:jt}),$O=jt({\u0275mod:jt}),ga=jt({\u0275fac:jt}),kp=jt({__NG_ELEMENT_ID__:jt}),PO=jt({__NG_ENV_ID__:jt});function tt(e){return"string"==typeof e?e:null==e?"":String(e)}function h_(e,n){throw new te(-201,!1)}var xt=function(e){return e[e.Default=0]="Default",e[e.Host=1]="Host",e[e.Self=2]="Self",e[e.SkipSelf=4]="SkipSelf",e[e.Optional=8]="Optional",e}(xt||{});let f_;function LO(){return f_}function Bs(e){const n=f_;return f_=e,n}function VO(e,n,t){const r=eb(e);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:t&xt.Optional?null:void 0!==n?n:void h_()}const Ap={},p_="__NG_DI_FLAG__",ob="ngTempTokenPath",OX=/\n/gm,BO="__source";let fd;function al(e){const n=fd;return fd=e,n}function PX(e,n=xt.Default){if(void 0===fd)throw new te(-203,!1);return null===fd?VO(e,void 0,n):fd.get(e,n&xt.Optional?null:void 0,n)}function $e(e,n=xt.Default){return(LO()||PX)(Ke(e),n)}function Z(e,n=xt.Default){return $e(e,ib(n))}function ib(e){return typeof e>"u"||"number"==typeof e?e:(e.optional&&8)|(e.host&&1)|(e.self&&2)|(e.skipSelf&&4)}function m_(e){const n=[];for(let t=0;t<e.length;t++){const r=Ke(e[t]);if(Array.isArray(r)){if(0===r.length)throw new te(900,!1);let s,o=xt.Default;for(let i=0;i<r.length;i++){const a=r[i],l=LX(a);"number"==typeof l?-1===l?s=a.token:o|=l:s=a}n.push($e(s,o))}else n.push($e(r))}return n}function Rp(e,n){return e[p_]=n,e.prototype[p_]=n,e}function LX(e){return e[p_]}const g_=Rp(dd("Optional"),8),y_=Rp(dd("SkipSelf"),4);function Tu(e,n){return e.hasOwnProperty(ga)?e[ga]:null}function pd(e,n){e.forEach(t=>Array.isArray(t)?pd(t,n):n(t))}function UO(e,n,t){n>=e.length?e.push(t):e.splice(n,0,t)}function ab(e,n){return n>=e.length-1?e.pop():e.splice(n,1)[0]}function so(e,n,t){let r=md(e,n);return r>=0?e[1|r]=t:(r=~r,function WO(e,n,t,r){let s=e.length;if(s==n)e.push(t,r);else if(1===s)e.push(r,e[0]),e[0]=t;else{for(s--,e.push(e[s-1],e[s]);s>n;)e[s]=e[s-2],s--;e[n]=t,e[n+1]=r}}(e,r,n,t)),r}function b_(e,n){const t=md(e,n);if(t>=0)return e[1|t]}function md(e,n){return function HO(e,n,t){let r=0,s=e.length>>t;for(;s!==r;){const o=r+(s-r>>1),i=e[o<<t];if(n===i)return o<<t;i>n?s=o:r=o+1}return~(s<<t)}(e,n,1)}const Di={},Lt=[],Mo=new fe(""),jO=new fe("",-1),w_=new fe("");class ub{get(n,t=Ap){if(t===Ap){const r=new Error(`NullInjectorError: No provider for ${vr(n)}!`);throw r.name="NullInjectorError",r}return t}}function rs(e,n){const t=e[$O]||null;if(!t&&!0===n)throw new Error(`Type ${vr(e)} does not have '\u0275mod' property.`);return t}function dt(e){return e[hd]||null}function br(e){return e[c_]||null}function Xr(e){return e[d_]||null}function ya(e){return{\u0275providers:e}}function jX(...e){return{\u0275providers:x_(0,e),\u0275fromNgModule:!0}}function x_(e,...n){const t=[],r=new Set;let s;const o=i=>{t.push(i)};return pd(n,i=>{const a=i;cb(a,o,[],r)&&(s||=[],s.push(a))}),void 0!==s&&GO(s,o),t}function GO(e,n){for(let t=0;t<e.length;t++){const{ngModule:r,providers:s}=e[t];C_(s,o=>{n(o,r)})}}function cb(e,n,t,r){if(!(e=Ke(e)))return!1;let s=null,o=tb(e);const i=!o&&dt(e);if(o||i){if(i&&!i.standalone)return!1;s=e}else{const l=e.ngModule;if(o=tb(l),!o)return!1;s=l}const a=r.has(s);if(i){if(a)return!1;if(r.add(s),i.dependencies){const l="function"==typeof i.dependencies?i.dependencies():i.dependencies;for(const u of l)cb(u,n,t,r)}}else{if(!o)return!1;{if(null!=o.imports&&!a){let u;r.add(s);try{pd(o.imports,c=>{cb(c,n,t,r)&&(u||=[],u.push(c))})}finally{}void 0!==u&&GO(u,n)}if(!a){const u=Tu(s)||(()=>new s);n({provide:s,useFactory:u,deps:Lt},s),n({provide:w_,useValue:s,multi:!0},s),n({provide:Mo,useValue:()=>$e(s),multi:!0},s)}const l=o.providers;if(null!=l&&!a){const u=e;C_(l,c=>{n(c,u)})}}}return s!==e&&void 0!==e.providers}function C_(e,n){for(let t of e)u_(t)&&(t=t.\u0275providers),Array.isArray(t)?C_(t,n):n(t)}const GX=jt({provide:String,useValue:jt});function I_(e){return null!==e&&"object"==typeof e&&GX in e}function ku(e){return"function"==typeof e}const S_=new fe(""),db={},KX={};let __;function hb(){return void 0===__&&(__=new ub),__}class ws{}class Au extends ws{parent;source;scopes;records=new Map;_ngOnDestroyHooks=new Set;_onDestroyHooks=[];get destroyed(){return this._destroyed}_destroyed=!1;injectorDefTypes;constructor(n,t,r,s){super(),this.parent=t,this.source=r,this.scopes=s,D_(n,i=>this.processProvider(i)),this.records.set(jO,gd(void 0,this)),s.has("environment")&&this.records.set(ws,gd(void 0,this));const o=this.records.get(S_);null!=o&&"string"==typeof o.value&&this.scopes.add(o.value),this.injectorDefTypes=new Set(this.get(w_,Lt,xt.Self))}destroy(){Mp(this),this._destroyed=!0;const n=st(null);try{for(const r of this._ngOnDestroyHooks)r.ngOnDestroy();const t=this._onDestroyHooks;this._onDestroyHooks=[];for(const r of t)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),st(n)}}onDestroy(n){return Mp(this),this._onDestroyHooks.push(n),()=>this.removeOnDestroy(n)}runInContext(n){Mp(this);const t=al(this),r=Bs(void 0);try{return n()}finally{al(t),Bs(r)}}get(n,t=Ap,r=xt.Default){if(Mp(this),n.hasOwnProperty(PO))return n[PO](this);r=ib(r);const o=al(this),i=Bs(void 0);try{if(!(r&xt.SkipSelf)){let l=this.records.get(n);if(void 0===l){const u=function JX(e){return"function"==typeof e||"object"==typeof e&&e instanceof fe}(n)&&eb(n);l=u&&this.injectableDefInScope(u)?gd(E_(n),db):null,this.records.set(n,l)}if(null!=l)return this.hydrate(n,l)}return(r&xt.Self?hb():this.parent).get(n,t=r&xt.Optional&&t===Ap?null:t)}catch(a){if("NullInjectorError"===a.name){if((a[ob]=a[ob]||[]).unshift(vr(n)),o)throw a;return function VX(e,n,t,r){const s=e[ob];throw n[BO]&&s.unshift(n[BO]),e.message=function BX(e,n,t,r=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.slice(2):e;let s=vr(n);if(Array.isArray(n))s=n.map(vr).join(" -> ");else if("object"==typeof n){let o=[];for(let i in n)if(n.hasOwnProperty(i)){let a=n[i];o.push(i+":"+("string"==typeof a?JSON.stringify(a):vr(a)))}s=`{${o.join(", ")}}`}return`${t}${r?"("+r+")":""}[${s}]: ${e.replace(OX,"\n  ")}`}("\n"+e.message,s,t,r),e.ngTokenPath=s,e[ob]=null,e}(a,n,"R3InjectorError",this.source)}throw a}finally{Bs(i),al(o)}}resolveInjectorInitializers(){const n=st(null),t=al(this),r=Bs(void 0);try{const o=this.get(Mo,Lt,xt.Self);for(const i of o)i()}finally{al(t),Bs(r),st(n)}}toString(){const n=[],t=this.records;for(const r of t.keys())n.push(vr(r));return`R3Injector[${n.join(", ")}]`}processProvider(n){let t=ku(n=Ke(n))?n:Ke(n&&n.provide);const r=function YX(e){return I_(e)?gd(void 0,e.useValue):gd(XO(e),db)}(n);if(!ku(n)&&!0===n.multi){let s=this.records.get(t);s||(s=gd(void 0,db,!0),s.factory=()=>m_(s.multi),this.records.set(t,s)),t=n,s.multi.push(n)}this.records.set(t,r)}hydrate(n,t){const r=st(null);try{return t.value===db&&(t.value=KX,t.value=t.factory()),"object"==typeof t.value&&t.value&&function QX(e){return null!==e&&"object"==typeof e&&"function"==typeof e.ngOnDestroy}(t.value)&&this._ngOnDestroyHooks.add(t.value),t.value}finally{st(r)}}injectableDefInScope(n){if(!n.providedIn)return!1;const t=Ke(n.providedIn);return"string"==typeof t?"any"===t||this.scopes.has(t):this.injectorDefTypes.has(t)}removeOnDestroy(n){const t=this._onDestroyHooks.indexOf(n);-1!==t&&this._onDestroyHooks.splice(t,1)}}function E_(e){const n=eb(e),t=null!==n?n.factory:Tu(e);if(null!==t)return t;if(e instanceof fe)throw new te(204,!1);if(e instanceof Function)return function XX(e){if(e.length>0)throw new te(204,!1);const t=function DX(e){return e&&(e[nb]||e[OO])||null}(e);return null!==t?()=>t.factory(e):()=>new e}(e);throw new te(204,!1)}function XO(e,n,t){let r;if(ku(e)){const s=Ke(e);return Tu(s)||E_(s)}if(I_(e))r=()=>Ke(e.useValue);else if(function KO(e){return!(!e||!e.useFactory)}(e))r=()=>e.useFactory(...m_(e.deps||[]));else if(function qO(e){return!(!e||!e.useExisting)}(e))r=()=>$e(Ke(e.useExisting));else{const s=Ke(e&&(e.useClass||e.provide));if(!function ZX(e){return!!e.deps}(e))return Tu(s)||E_(s);r=()=>new s(...m_(e.deps))}return r}function Mp(e){if(e.destroyed)throw new te(205,!1)}function gd(e,n,t=!1){return{factory:e,value:n,multi:t?[]:void 0}}function D_(e,n){for(const t of e)Array.isArray(t)?D_(t,n):t&&u_(t)?D_(t.\u0275providers,n):n(t)}function Oo(e,n){e instanceof Au&&Mp(e);const r=al(e),s=Bs(void 0);try{return n()}finally{al(r),Bs(s)}}function YO(){return void 0!==LO()||null!=function $X(){return fd}()}function Mn(e){return Array.isArray(e)&&"object"==typeof e[1]}function xr(e){return Array.isArray(e)&&!0===e[1]}function k_(e){return!!(4&e.flags)}function cl(e){return e.componentOffset>-1}function yb(e){return!(1&~e.flags)}function Qo(e){return!!e.template}function Fp(e){return!!(512&e[2])}function dl(e){return!(256&~e[2])}class d9{previousValue;currentValue;firstChange;constructor(n,t,r){this.previousValue=n,this.currentValue=t,this.firstChange=r}isFirstChange(){return this.firstChange}}function s2(e,n,t,r){null!==n?n.applyValueToInputSignal(n,r):e[t]=r}const Jo=(()=>{const e=()=>o2;return e.ngInherit=!0,e})();function o2(e){return e.type.prototype.ngOnChanges&&(e.setInput=f9),h9}function h9(){const e=a2(this),n=e?.current;if(n){const t=e.previous;if(t===Di)e.previous=n;else for(let r in n)t[r]=n[r];e.current=null,this.ngOnChanges(n)}}function f9(e,n,t,r,s){const o=this.declaredInputs[r],i=a2(e)||function p9(e,n){return e[i2]=n}(e,{previous:Di,current:null}),a=i.current||(i.current={}),l=i.previous,u=l[o];a[o]=new d9(u&&u.currentValue,t,l===Di),s2(e,n,s,t)}const i2="__ngSimpleChanges__";function a2(e){return e[i2]||null}function Mt(e){for(;Array.isArray(e);)e=e[0];return e}function Sd(e,n){return Mt(n[e])}function os(e,n){return Mt(n[e.index])}function Fu(e,n){return e.data[n]}function oo(e,n){const t=n[e];return Mn(t)?t:t[0]}function M_(e){return!(128&~e[2])}function $o(e,n){return null==n?null:e[n]}function c2(e){e[17]=0}function O_(e){1024&e[2]||(e[2]|=1024,M_(e)&&$p(e))}function bb(e){return!!(9216&e[2]||e[24]?.dirty)}function F_(e){e[10].changeDetectionScheduler?.notify(9),64&e[2]&&(e[2]|=1024),bb(e)&&$p(e)}function $p(e){e[10].changeDetectionScheduler?.notify(0);let n=wa(e);for(;null!==n&&!(8192&n[2])&&(n[2]|=8192,M_(n));)n=wa(n)}function wb(e,n){if(dl(e))throw new te(911,!1);null===e[21]&&(e[21]=[]),e[21].push(n)}function wa(e){const n=e[3];return xr(n)?n[3]:n}function h2(e){return e[7]??=[]}function f2(e){return e.cleanup??=[]}const Ze={lFrame:I2(null),bindingsEnabled:!0,skipHydrationRootTNode:null};let L_=!1;function p2(){return Ze.bindingsEnabled}function K(){return Ze.lFrame.lView}function Xe(){return Ze.lFrame.tView}function ao(e){return Ze.lFrame.contextLView=e,e[8]}function lo(e){return Ze.lFrame.contextLView=null,e}function ht(){let e=m2();for(;null!==e&&64===e.type;)e=e.parent;return e}function m2(){return Ze.lFrame.currentTNode}function ei(e,n){const t=Ze.lFrame;t.currentTNode=e,t.isParent=n}function V_(){return Ze.lFrame.isParent}function v2(){return L_}function Cb(e){const n=L_;return L_=e,n}function Cs(){const e=Ze.lFrame;let n=e.bindingRootIndex;return-1===n&&(n=e.bindingRootIndex=e.tView.bindingStartIndex),n}function Po(){return Ze.lFrame.bindingIndex++}function T9(e,n){const t=Ze.lFrame;t.bindingIndex=t.bindingRootIndex=e,z_(n)}function z_(e){Ze.lFrame.currentDirectiveIndex=e}function W_(){return Ze.lFrame.currentQueryIndex}function Ib(e){Ze.lFrame.currentQueryIndex=e}function A9(e){const n=e[1];return 2===n.type?n.declTNode:1===n.type?e[5]:null}function x2(e,n,t){if(t&xt.SkipSelf){let s=n,o=e;for(;!(s=s.parent,null!==s||t&xt.Host||(s=A9(o),null===s||(o=o[14],10&s.type))););if(null===s)return!1;n=s,e=o}const r=Ze.lFrame=C2();return r.currentTNode=n,r.lView=e,!0}function H_(e){const n=C2(),t=e[1];Ze.lFrame=n,n.currentTNode=t.firstChild,n.lView=e,n.tView=t,n.contextLView=e,n.bindingIndex=t.bindingStartIndex,n.inI18n=!1}function C2(){const e=Ze.lFrame,n=null===e?null:e.child;return null===n?I2(e):n}function I2(e){const n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=n),n}function S2(){const e=Ze.lFrame;return Ze.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const _2=S2;function j_(){const e=S2();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function Yr(){return Ze.lFrame.selectedIndex}function Lu(e){Ze.lFrame.selectedIndex=e}function Zt(){const e=Ze.lFrame;return Fu(e.tView,e.selectedIndex)}let D2=!0;function Lp(){return D2}function ki(e){D2=e}function Sb(e,n){for(let t=n.directiveStart,r=n.directiveEnd;t<r;t++){const o=e.data[t].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:u,ngOnDestroy:c}=o;i&&(e.contentHooks??=[]).push(-t,i),a&&((e.contentHooks??=[]).push(t,a),(e.contentCheckHooks??=[]).push(t,a)),l&&(e.viewHooks??=[]).push(-t,l),u&&((e.viewHooks??=[]).push(t,u),(e.viewCheckHooks??=[]).push(t,u)),null!=c&&(e.destroyHooks??=[]).push(t,c)}}function _b(e,n,t){N2(e,n,3,t)}function Eb(e,n,t,r){(3&e[2])===t&&N2(e,n,t,r)}function G_(e,n){let t=e[2];(3&t)===n&&(t&=16383,t+=1,e[2]=t)}function N2(e,n,t,r){const o=r??-1,i=n.length-1;let a=0;for(let l=void 0!==r?65535&e[17]:0;l<i;l++)if("number"==typeof n[l+1]){if(a=n[l],null!=r&&a>=r)break}else n[l]<0&&(e[17]+=65536),(a<o||-1==o)&&(L9(e,t,n,l),e[17]=(4294901760&e[17])+l+2),l++}function T2(e,n){const t=st(null);try{n.call(e)}finally{st(t)}}function L9(e,n,t,r){const s=t[r]<0,o=t[r+1],a=e[s?-t[r]:t[r]];s?e[2]>>14<e[17]>>16&&(3&e[2])===n&&(e[2]+=16384,T2(a,o)):T2(a,o)}class Vp{factory;injectImpl;resolving=!1;canSeeViewProviders;multi;componentProviders;index;providerFactory;constructor(n,t,r){this.factory=n,this.canSeeViewProviders=t,this.injectImpl=r}}function k2(e){return 3===e||4===e||6===e}function A2(e){return 64===e.charCodeAt(0)}function Ed(e,n){if(null!==n&&0!==n.length)if(null===e||0===e.length)e=n.slice();else{let t=-1;for(let r=0;r<n.length;r++){const s=n[r];"number"==typeof s?t=s:0===t||R2(e,t,s,null,-1===t||2===t?n[++r]:null)}}return e}function R2(e,n,t,r,s){let o=0,i=e.length;if(-1===n)i=-1;else for(;o<e.length;){const a=e[o++];if("number"==typeof a){if(a===n){i=-1;break}if(a>n){i=o-1;break}}}for(;o<e.length;){const a=e[o];if("number"==typeof a)break;if(a===t){if(null===r)return void(null!==s&&(e[o+1]=s));if(r===e[o+1])return void(e[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(e.splice(i,0,n),o=i+1),e.splice(o++,0,t),null!==r&&e.splice(o++,0,r),null!==s&&e.splice(o++,0,s)}const X_={};class Vu{injector;parentInjector;constructor(n,t){this.injector=n,this.parentInjector=t}get(n,t,r){r=ib(r);const s=this.injector.get(n,X_,r);return s!==X_||t===X_?s:this.parentInjector.get(n,t,r)}}function Y_(e){return-1!==e}function Bp(e){return 32767&e}function zp(e,n){let t=function H9(e){return e>>16}(e),r=n;for(;t>0;)r=r[14],t--;return r}let Z_=!0;function Db(e){const n=Z_;return Z_=e,n}let G9=0;const Ai={};function Nb(e,n){const t=F2(e,n);if(-1!==t)return t;const r=n[1];r.firstCreatePass&&(e.injectorIndex=n.length,Q_(r.data,e),Q_(n,null),Q_(r.blueprint,null));const s=Tb(e,n),o=e.injectorIndex;if(Y_(s)){const i=Bp(s),a=zp(s,n),l=a[1].data;for(let u=0;u<8;u++)n[o+u]=a[i+u]|l[i+u]}return n[o+8]=s,o}function Q_(e,n){e.push(0,0,0,0,0,0,0,0,n)}function F2(e,n){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===n[e.injectorIndex+8]?-1:e.injectorIndex}function Tb(e,n){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let t=0,r=null,s=n;for(;null!==s;){if(r=U2(s),null===r)return-1;if(t++,s=s[14],-1!==r.injectorIndex)return r.injectorIndex|t<<16}return-1}function J_(e,n,t){!function q9(e,n,t){let r;"string"==typeof t?r=t.charCodeAt(0)||0:t.hasOwnProperty(kp)&&(r=t[kp]),null==r&&(r=t[kp]=G9++);const s=255&r;n.data[e+(s>>5)]|=1<<s}(e,n,t)}function $2(e,n,t){if(t&xt.Optional||void 0!==e)return e;h_()}function P2(e,n,t,r){if(t&xt.Optional&&void 0===r&&(r=null),!(t&(xt.Self|xt.Host))){const s=e[9],o=Bs(void 0);try{return s?s.get(n,r,t&xt.Optional):VO(n,r,t&xt.Optional)}finally{Bs(o)}}return $2(r,0,t)}function L2(e,n,t,r=xt.Default,s){if(null!==e){if(2048&n[2]&&!(r&xt.Self)){const i=function Q9(e,n,t,r,s){let o=e,i=n;for(;null!==o&&null!==i&&2048&i[2]&&!(512&i[2]);){const a=V2(o,i,t,r|xt.Self,Ai);if(a!==Ai)return a;let l=o.parent;if(!l){const u=i[20];if(u){const c=u.get(t,Ai,r);if(c!==Ai)return c}l=U2(i),i=i[14]}o=l}return s}(e,n,t,r,Ai);if(i!==Ai)return i}const o=V2(e,n,t,r,Ai);if(o!==Ai)return o}return P2(n,t,r,s)}function V2(e,n,t,r,s){const o=function Y9(e){if("string"==typeof e)return e.charCodeAt(0)||0;const n=e.hasOwnProperty(kp)?e[kp]:void 0;return"number"==typeof n?n>=0?255&n:Z9:n}(t);if("function"==typeof o){if(!x2(n,e,r))return r&xt.Host?$2(s,0,r):P2(n,t,r,s);try{let i;if(i=o(r),null!=i||r&xt.Optional)return i;h_()}finally{_2()}}else if("number"==typeof o){let i=null,a=F2(e,n),l=-1,u=r&xt.Host?n[15][5]:null;for((-1===a||r&xt.SkipSelf)&&(l=-1===a?Tb(e,n):n[a+8],-1!==l&&z2(r,!1)?(i=n[1],a=Bp(l),n=zp(l,n)):a=-1);-1!==a;){const c=n[1];if(B2(o,a,c.data)){const d=X9(a,n,t,i,r,u);if(d!==Ai)return d}l=n[a+8],-1!==l&&z2(r,n[1].data[a+8]===u)&&B2(o,a,n)?(i=c,a=Bp(l),n=zp(l,n)):a=-1}}return s}function X9(e,n,t,r,s,o){const i=n[1],a=i.data[e+8],c=kb(a,i,t,null==r?cl(a)&&Z_:r!=i&&!!(3&a.type),s&xt.Host&&o===a);return null!==c?Bu(n,i,c,a):Ai}function kb(e,n,t,r,s){const o=e.providerIndexes,i=n.data,a=1048575&o,l=e.directiveStart,c=o>>20,h=s?a+c:e.directiveEnd;for(let f=r?a:a+c;f<h;f++){const p=i[f];if(f<l&&t===p||f>=l&&p.type===t)return f}if(s){const f=i[l];if(f&&Qo(f)&&f.type===t)return l}return null}function Bu(e,n,t,r){let s=e[t];const o=n.data;if(function V9(e){return e instanceof Vp}(s)){const i=s;i.resolving&&function AX(e,n){throw n&&n.join(" > "),new te(-200,e)}(function Bt(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():tt(e)}(o[t]));const a=Db(i.canSeeViewProviders);i.resolving=!0;const u=i.injectImpl?Bs(i.injectImpl):null;x2(e,r,xt.Default);try{s=e[t]=i.factory(void 0,o,e,r),n.firstCreatePass&&t>=r.directiveStart&&function P9(e,n,t){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=n.type.prototype;if(r){const i=o2(n);(t.preOrderHooks??=[]).push(e,i),(t.preOrderCheckHooks??=[]).push(e,i)}s&&(t.preOrderHooks??=[]).push(0-e,s),o&&((t.preOrderHooks??=[]).push(e,o),(t.preOrderCheckHooks??=[]).push(e,o))}(t,o[t],n)}finally{null!==u&&Bs(u),Db(a),i.resolving=!1,_2()}}return s}function B2(e,n,t){return!!(t[n+(e>>5)]&1<<e)}function z2(e,n){return!(e&xt.Self||e&xt.Host&&n)}class Ln{_tNode;_lView;constructor(n,t){this._tNode=n,this._lView=t}get(n,t,r){return L2(this._tNode,this._lView,n,ib(r),t)}}function Z9(){return new Ln(ht(),K())}function Or(e){return ma(()=>{const n=e.prototype.constructor,t=n[ga]||eE(n),r=Object.prototype;let s=Object.getPrototypeOf(e.prototype).constructor;for(;s&&s!==r;){const o=s[ga]||eE(s);if(o&&o!==t)return o;s=Object.getPrototypeOf(s)}return o=>new o})}function eE(e){return Jv(e)?()=>{const n=eE(Ke(e));return n&&n()}:Tu(e)}function U2(e){const n=e[1],t=n.type;return 2===t?n.declTNode:1===t?e[5]:null}function q2(e,n=null,t=null,r){const s=K2(e,n,t,r);return s.resolveInjectorInitializers(),s}function K2(e,n=null,t=null,r,s=new Set){const o=[t||Lt,jX(e)];return r=r||("object"==typeof e?void 0:vr(e)),new Au(o,n||hb(),r||null,s)}class Vn{static THROW_IF_NOT_FOUND=Ap;static NULL=new ub;static create(n,t){if(Array.isArray(n))return q2({name:""},t,n,"");{const r=n.name??"";return q2({name:r},n.parent,n.providers,r)}}static \u0275prov=_e({token:Vn,providedIn:"any",factory:()=>$e(jO)});static __NG_ELEMENT_ID__=-1}new fe("").__NG_ELEMENT_ID__=e=>{const n=ht();if(null===n)throw new te(204,!1);if(2&n.type)return n.value;if(e&xt.Optional)return null;throw new te(204,!1)};const X2=!1;let fl=(()=>class e{static __NG_ELEMENT_ID__=a7;static __NG_ENV_ID__=t=>t})();class Y2 extends fl{_lView;constructor(n){super(),this._lView=n}onDestroy(n){return wb(this._lView,n),()=>function $_(e,n){if(null===e[21])return;const t=e[21].indexOf(n);-1!==t&&e[21].splice(t,1)}(this._lView,n)}}function a7(){return new Y2(K())}class Ia{}const Wp=new fe("",{providedIn:"root",factory:()=>!1}),Z2=new fe(""),nE=new fe("");let ti=(()=>{class e{taskId=0;pendingTasks=new Set;get _hasPendingTasks(){return this.hasPendingTasks.value}hasPendingTasks=new Ro(!1);add(){this._hasPendingTasks||this.hasPendingTasks.next(!0);const t=this.taskId++;return this.pendingTasks.add(t),t}has(t){return this.pendingTasks.has(t)}remove(t){this.pendingTasks.delete(t),0===this.pendingTasks.size&&this._hasPendingTasks&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this._hasPendingTasks&&this.hasPendingTasks.next(!1)}static \u0275prov=_e({token:e,providedIn:"root",factory:()=>new e})}return e})();const or=class u7 extends Ls{__isAsync;destroyRef=void 0;pendingTasks=void 0;constructor(n=!1){super(),this.__isAsync=n,YO()&&(this.destroyRef=Z(fl,{optional:!0})??void 0,this.pendingTasks=Z(ti,{optional:!0})??void 0)}emit(n){const t=st(null);try{super.next(n)}finally{st(t)}}subscribe(n,t,r){let s=n,o=t||(()=>null),i=r;if(n&&"object"==typeof n){const l=n;s=l.next?.bind(l),o=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(o=this.wrapInTimeout(o),s&&(s=this.wrapInTimeout(s)),i&&(i=this.wrapInTimeout(i)));const a=super.subscribe({next:s,error:o,complete:i});return n instanceof bs&&n.add(a),a}wrapInTimeout(n){return t=>{const r=this.pendingTasks?.add();setTimeout(()=>{n(t),void 0!==r&&this.pendingTasks?.remove(r)})}}};function Hp(...e){}function Q2(e){let n,t;function r(){e=Hp;try{void 0!==t&&"function"==typeof cancelAnimationFrame&&cancelAnimationFrame(t),void 0!==n&&clearTimeout(n)}catch{}}return n=setTimeout(()=>{e(),r()}),"function"==typeof requestAnimationFrame&&(t=requestAnimationFrame(()=>{e(),r()})),()=>r()}function J2(e){return queueMicrotask(()=>e()),()=>{e=Hp}}const rE="isAngularZone",Rb=rE+"_ID";let c7=0;class Vt{hasPendingMacrotasks=!1;hasPendingMicrotasks=!1;isStable=!0;onUnstable=new or(!1);onMicrotaskEmpty=new or(!1);onStable=new or(!1);onError=new or(!1);constructor(n){const{enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:r=!1,shouldCoalesceRunChangeDetection:s=!1,scheduleInRootZone:o=X2}=n;if(typeof Zone>"u")throw new te(908,!1);Zone.assertZonePatched();const i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!s&&r,i.shouldCoalesceRunChangeDetection=s,i.callbackScheduled=!1,i.scheduleInRootZone=o,function f7(e){const n=()=>{!function h7(e){function n(){Q2(()=>{e.callbackScheduled=!1,oE(e),e.isCheckStableRunning=!0,sE(e),e.isCheckStableRunning=!1})}e.isCheckStableRunning||e.callbackScheduled||(e.callbackScheduled=!0,e.scheduleInRootZone?Zone.root.run(()=>{n()}):e._outer.run(()=>{n()}),oE(e))}(e)},t=c7++;e._inner=e._inner.fork({name:"angular",properties:{[rE]:!0,[Rb]:t,[Rb+t]:!0},onInvokeTask:(r,s,o,i,a,l)=>{if(function p7(e){return nF(e,"__ignore_ng_zone__")}(l))return r.invokeTask(o,i,a,l);try{return eF(e),r.invokeTask(o,i,a,l)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||e.shouldCoalesceRunChangeDetection)&&n(),tF(e)}},onInvoke:(r,s,o,i,a,l,u)=>{try{return eF(e),r.invoke(o,i,a,l,u)}finally{e.shouldCoalesceRunChangeDetection&&!e.callbackScheduled&&!function m7(e){return nF(e,"__scheduler_tick__")}(l)&&n(),tF(e)}},onHasTask:(r,s,o,i)=>{r.hasTask(o,i),s===o&&("microTask"==i.change?(e._hasPendingMicrotasks=i.microTask,oE(e),sE(e)):"macroTask"==i.change&&(e.hasPendingMacrotasks=i.macroTask))},onHandleError:(r,s,o,i)=>(r.handleError(o,i),e.runOutsideAngular(()=>e.onError.emit(i)),!1)})}(i)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get(rE)}static assertInAngularZone(){if(!Vt.isInAngularZone())throw new te(909,!1)}static assertNotInAngularZone(){if(Vt.isInAngularZone())throw new te(909,!1)}run(n,t,r){return this._inner.run(n,t,r)}runTask(n,t,r,s){const o=this._inner,i=o.scheduleEventTask("NgZoneEvent: "+s,n,d7,Hp,Hp);try{return o.runTask(i,t,r)}finally{o.cancelTask(i)}}runGuarded(n,t,r){return this._inner.runGuarded(n,t,r)}runOutsideAngular(n){return this._outer.run(n)}}const d7={};function sE(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function oE(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&!0===e.callbackScheduled)}function eF(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function tF(e){e._nesting--,sE(e)}class iE{hasPendingMicrotasks=!1;hasPendingMacrotasks=!1;isStable=!0;onUnstable=new or;onMicrotaskEmpty=new or;onStable=new or;onError=new or;run(n,t,r){return n.apply(t,r)}runGuarded(n,t,r){return n.apply(t,r)}runOutsideAngular(n){return n()}runTask(n,t,r,s){return n.apply(t,r)}}function nF(e,n){return!(!Array.isArray(e)||1!==e.length)&&!0===e[0]?.data?.[n]}class Ri{_console=console;handleError(n){this._console.error("ERROR",n)}}const y7=new fe("",{providedIn:"root",factory:()=>{const e=Z(Vt),n=Z(Ri);return t=>e.runOutsideAngular(()=>n.handleError(t))}});function sF(e,n){return AO(e,n)}const b7=(sF.required=function v7(e){return AO(Qv,e)},sF);function w7(){return Dd(ht(),K())}function Dd(e,n){return new uo(os(e,n))}let uo=(()=>class e{nativeElement;constructor(t){this.nativeElement=t}static __NG_ELEMENT_ID__=w7})();function oF(e){return e instanceof uo?e.nativeElement:e}const iF=new Set;function Fr(e){iF.has(e)||(iF.add(e),performance?.mark?.("mark_feature_usage",{detail:{feature:e}}))}function Uu(e,n){Fr("NgSignals");const t=function rX(e){const n=Object.create(GS);n.value=e;const t=()=>(Iu(n),n.value);return t[gr]=n,t}(e),r=t[gr];return n?.equal&&(r.equal=n.equal),t.set=s=>Tp(r,s),t.update=s=>function jS(e,n){pO()||wO(),Tp(e,n(e.value))}(r,s),t.asReadonly=Mb.bind(t),t}function Mb(){const e=this[gr];if(void 0===e.readonlyFn){const n=()=>this();n[gr]=e,e.readonlyFn=n}return e.readonlyFn}function lF(e){return function aF(e){return"function"==typeof e&&void 0!==e[gr]}(e)&&"function"==typeof e.set}function x7(){return this._results[Symbol.iterator]()}class C7{_emitDistinctChangesOnly;dirty=!0;_onDirty=void 0;_results=[];_changesDetected=!1;_changes=void 0;length=0;first=void 0;last=void 0;get changes(){return this._changes??=new Ls}constructor(n=!1){this._emitDistinctChangesOnly=n}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,t){return this._results.reduce(n,t)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,t){this.dirty=!1;const r=function zs(e){return e.flat(Number.POSITIVE_INFINITY)}(n);(this._changesDetected=!function HX(e,n,t){if(e.length!==n.length)return!1;for(let r=0;r<e.length;r++){let s=e[r],o=n[r];if(t&&(s=t(s),o=t(o)),o!==s)return!1}return!0}(this._results,r,t))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){void 0!==this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.next(this)}onDirty(n){this._onDirty=n}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){void 0!==this._changes&&(this._changes.complete(),this._changes.unsubscribe())}[Symbol.iterator]=x7}function Gp(e){return!(128&~e.flags)}var Ob=function(e){return e[e.OnPush=0]="OnPush",e[e.Default=1]="Default",e}(Ob||{});const Fb=new Map;let S7=0;function lE(e){Fb.delete(e[19])}const $b="__ngContext__";function is(e,n){Mn(n)?(e[$b]=n[19],function E7(e){Fb.set(e[19],e)}(n)):e[$b]=n}function yF(e){return bF(e[12])}function vF(e){return bF(e[4])}function bF(e){for(;null!==e&&!xr(e);)e=e[4];return e}let dE;const Wu=new fe("",{providedIn:"root",factory:()=>H7}),H7="ng",hE=new fe(""),Hu=new fe("",{providedIn:"platform",factory:()=>"unknown"}),DF=new fe("",{providedIn:"root",factory:()=>function Mi(){if(void 0!==dE)return dE;if(typeof document<"u")return document;throw new te(210,!1)}().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null}),AF=new fe("",{providedIn:"root",factory:()=>!1});var IE=function(e){return e[e.CHANGE_DETECTION=0]="CHANGE_DETECTION",e[e.AFTER_NEXT_RENDER=1]="AFTER_NEXT_RENDER",e}(IE||{});const kd=new fe("");var Ad=function(e){return e[e.EarlyRead=0]="EarlyRead",e[e.Write=1]="Write",e[e.MixedReadWrite=2]="MixedReadWrite",e[e.Read=3]="Read",e}(Ad||{});let SE=(()=>{class e{impl=null;execute(){this.impl?.execute()}static \u0275prov=_e({token:e,providedIn:"root",factory:()=>new e})}return e})();const FF=[Ad.EarlyRead,Ad.Write,Ad.MixedReadWrite,Ad.Read];let $F=(()=>{class e{ngZone=Z(Vt);scheduler=Z(Ia);errorHandler=Z(Ri,{optional:!0});sequences=new Set;deferredRegistrations=new Set;executing=!1;constructor(){Z(kd,{optional:!0})}execute(){this.executing=!0;for(const t of FF)for(const r of this.sequences)if(!r.erroredOrDestroyed&&r.hooks[t])try{r.pipelinedValue=this.ngZone.runOutsideAngular(()=>this.maybeTrace(()=>r.hooks[t](r.pipelinedValue),r.snapshot))}catch(s){r.erroredOrDestroyed=!0,this.errorHandler?.handleError(s)}this.executing=!1;for(const t of this.sequences)t.afterRun(),t.once&&(this.sequences.delete(t),t.destroy());for(const t of this.deferredRegistrations)this.sequences.add(t);this.deferredRegistrations.size>0&&this.scheduler.notify(8),this.deferredRegistrations.clear()}register(t){this.executing?this.deferredRegistrations.add(t):(this.sequences.add(t),this.scheduler.notify(7))}unregister(t){this.executing&&this.sequences.has(t)?(t.erroredOrDestroyed=!0,t.pipelinedValue=void 0,t.once=!0):(this.sequences.delete(t),this.deferredRegistrations.delete(t))}maybeTrace(t,r){return r?r.run(IE.AFTER_NEXT_RENDER,t):t()}static \u0275prov=_e({token:e,providedIn:"root",factory:()=>new e})}return e})();class PF{impl;hooks;once;snapshot;erroredOrDestroyed=!1;pipelinedValue=void 0;unregisterOnDestroy;constructor(n,t,r,s,o=null){this.impl=n,this.hooks=t,this.once=r,this.snapshot=o,this.unregisterOnDestroy=s?.onDestroy(()=>this.destroy())}afterRun(){this.erroredOrDestroyed=!1,this.pipelinedValue=void 0,this.snapshot?.dispose(),this.snapshot=null}destroy(){this.impl.unregister(this),this.unregisterOnDestroy?.()}}function Yp(e,n){!n?.injector&&function yd(e){if(!YO())throw new te(-203,!1)}();const t=n?.injector??Z(Vn);return Fr("NgAfterNextRender"),function LF(e,n,t,r){const s=n.get(SE);s.impl??=n.get($F);const o=n.get(kd,null,{optional:!0}),i=t?.phase??Ad.MixedReadWrite,a=!0!==t?.manualCleanup?n.get(fl):null,l=new PF(s.impl,function Y7(e,n){if(e instanceof Function){const t=[void 0,void 0,void 0,void 0];return t[n]=e,t}return[e.earlyRead,e.write,e.mixedReadWrite,e.read]}(e,i),r,a,o?.snapshot(null));return s.impl.register(l),l}(e,t,n,!0)}function i$(e,n){const t=e.contentQueries;if(null!==t){const r=st(null);try{for(let s=0;s<t.length;s+=2){const i=t[s+1];if(-1!==i){const a=e.data[i];Ib(t[s]),a.contentQueries(2,n[i],i)}}}finally{st(r)}}}function PE(e,n,t){Ib(0);const r=st(null);try{n(e,t)}finally{st(r)}}function LE(e,n,t){if(k_(n)){const r=st(null);try{const o=n.directiveEnd;for(let i=n.directiveStart;i<o;i++){const a=e.data[i];a.contentQueries&&a.contentQueries(1,t[i],i)}}finally{st(r)}}}var Lo=function(e){return e[e.Emulated=0]="Emulated",e[e.None=2]="None",e[e.ShadowDom=3]="ShadowDom",e}(Lo||{});let Zb;function u$(e){return function BE(){if(void 0===Zb&&(Zb=null,gn.trustedTypes))try{Zb=gn.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:e=>e,createScript:e=>e,createScriptURL:e=>e})}catch{}return Zb}()?.createScriptURL(e)||e}class c${changingThisBreaksApplicationSecurity;constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${TO})`}}function yl(e){return e instanceof c$?e.changingThisBreaksApplicationSecurity:e}function om(e,n){const t=function PY(e){return e instanceof c$&&e.getTypeName()||null}(e);if(null!=t&&t!==n){if("ResourceURL"===t&&"URL"===n)return!0;throw new Error(`Required a safe ${n}, got a ${t} (see ${TO})`)}return t===n}const zY=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;var Bd=function(e){return e[e.NONE=0]="NONE",e[e.HTML=1]="HTML",e[e.STYLE=2]="STYLE",e[e.SCRIPT=3]="SCRIPT",e[e.URL=4]="URL",e[e.RESOURCE_URL=5]="RESOURCE_URL",e}(Bd||{});function am(e){const n=lm();return n?n.sanitize(Bd.URL,e)||"":om(e,"URL")?yl(e):function zE(e){return(e=String(e)).match(zY)?e:"unsafe:"+e}(tt(e))}function b$(e){const n=lm();if(n)return u$(n.sanitize(Bd.RESOURCE_URL,e)||"");if(om(e,"ResourceURL"))return u$(yl(e));throw new te(904,!1)}function lm(){const e=K();return e&&e[10].sanitizer}function co(e){return e instanceof Function?e():e}var vl=function(e){return e[e.None=0]="None",e[e.SignalBased=1]="SignalBased",e[e.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",e}(vl||{});function gZ(e,n,t){let r=e.length;for(;;){const s=e.indexOf(n,t);if(-1===s)return s;if(0===s||e.charCodeAt(s-1)<=32){const o=n.length;if(s+o===r||e.charCodeAt(s+o)<=32)return s}t=s+1}}const T$="ng-template";function yZ(e,n,t,r){let s=0;if(r){for(;s<n.length&&"string"==typeof n[s];s+=2)if("class"===n[s]&&-1!==gZ(n[s+1].toLowerCase(),t,0))return!0}else if(qE(e))return!1;if(s=n.indexOf(1,s),s>-1){let o;for(;++s<n.length&&"string"==typeof(o=n[s]);)if(o.toLowerCase()===t)return!0}return!1}function qE(e){return 4===e.type&&e.value!==T$}function vZ(e,n,t){return n===(4!==e.type||t?e.value:T$)}function bZ(e,n,t){let r=4;const s=e.attrs,o=null!==s?function CZ(e){for(let n=0;n<e.length;n++)if(k2(e[n]))return n;return e.length}(s):0;let i=!1;for(let a=0;a<n.length;a++){const l=n[a];if("number"!=typeof l){if(!i)if(4&r){if(r=2|1&r,""!==l&&!vZ(e,l,t)||""===l&&1===n.length){if(ni(r))return!1;i=!0}}else if(8&r){if(null===s||!yZ(e,s,l,t)){if(ni(r))return!1;i=!0}}else{const u=n[++a],c=wZ(l,s,qE(e),t);if(-1===c){if(ni(r))return!1;i=!0;continue}if(""!==u){let d;if(d=c>o?"":s[c+1].toLowerCase(),2&r&&u!==d){if(ni(r))return!1;i=!0}}}}else{if(!i&&!ni(r)&&!ni(l))return!1;if(i&&ni(l))continue;i=!1,r=l|1&r}}return ni(r)||i}function ni(e){return!(1&e)}function wZ(e,n,t,r){if(null===n)return-1;let s=0;if(r||!t){let o=!1;for(;s<n.length;){const i=n[s];if(i===e)return s;if(3===i||6===i)o=!0;else{if(1===i||2===i){let a=n[++s];for(;"string"==typeof a;)a=n[++s];continue}if(4===i)break;if(0===i){s+=4;continue}}s+=o?1:2}return-1}return function IZ(e,n){let t=e.indexOf(4);if(t>-1)for(t++;t<e.length;){const r=e[t];if("number"==typeof r)return-1;if(r===n)return t;t++}return-1}(n,e)}function k$(e,n,t=!1){for(let r=0;r<n.length;r++)if(bZ(e,n[r],t))return!0;return!1}function A$(e,n){return e?":not("+n.trim()+")":n}function _Z(e){let n=e[0],t=1,r=2,s="",o=!1;for(;t<e.length;){let i=e[t];if("string"==typeof i)if(2&r){const a=e[++t];s+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""!==s&&!ni(i)&&(n+=A$(o,s),s=""),r=i,o=o||!ni(r);t++}return""!==s&&(n+=A$(o,s)),n}const nt={};function In(e=1){R$(Xe(),K(),Yr()+e,!1)}function R$(e,n,t,r){if(!r)if(3&~n[2]){const o=e.preOrderHooks;null!==o&&Eb(n,o,0,t)}else{const o=e.preOrderCheckHooks;null!==o&&_b(n,o,t)}Lu(t)}function se(e,n=xt.Default){const t=K();return null===t?$e(e,n):L2(ht(),t,Ke(e),n)}function O$(e,n,t,r,s,o){const i=st(null);try{let a=null;s&vl.SignalBased&&(a=n[r][gr]),null!==a&&void 0!==a.transformFn&&(o=a.transformFn(o)),s&vl.HasDecoratorInputTransform&&(o=e.inputTransforms[r].call(n,o)),null!==e.setInput?e.setInput(n,a,o,t,r):s2(n,a,r,o)}finally{st(i)}}function tw(e,n,t){return e.createElement(n,t)}function qu(e,n,t,r,s){e.insertBefore(n,t,r,s)}function $$(e,n,t){e.appendChild(n,t)}function P$(e,n,t,r,s){null!==r?qu(e,n,t,r,s):$$(e,n,t)}function V$(e,n,t){const{mergedAttrs:r,classes:s,styles:o}=t;null!==r&&function W9(e,n,t){let r=0;for(;r<t.length;){const s=t[r];if("number"==typeof s){if(0!==s)break;r++;const o=t[r++],i=t[r++],a=t[r++];e.setAttribute(n,i,a,o)}else{const o=s,i=t[++r];A2(o)?e.setProperty(n,o,i):e.setAttribute(n,o,i),r++}}}(e,n,r),null!==s&&function TZ(e,n,t){""===t?e.removeAttribute(n,"class"):e.setAttribute(n,"class",t)}(e,n,s),null!==o&&function NZ(e,n,t){e.setAttribute(n,"style",t)}(e,n,o)}function cm(e,n,t,r,s,o,i,a,l,u,c){const d=n.blueprint.slice();return d[0]=s,d[2]=1228|r,(null!==u||e&&2048&e[2])&&(d[2]|=2048),c2(d),d[3]=d[14]=e,d[8]=t,d[10]=i||e&&e[10],d[11]=a||e&&e[11],d[9]=l||e&&e[9]||null,d[5]=o,d[19]=function _7(){return S7++}(),d[6]=c,d[20]=u,d[15]=2==n.type?e[15]:d,d}function dm(e,n,t,r){if(0===t)return-1;const s=n.length;for(let o=0;o<t;o++)n.push(r),e.blueprint.push(r),e.data.push(null);return s}function B$(e,n,t,r,s){const o=Yr(),i=2&r;try{Lu(-1),i&&n.length>25&&R$(e,n,25,!1),t(r,s)}finally{Lu(o)}}function YE(e,n,t){p2()&&(function zZ(e,n,t,r){const s=t.directiveStart,o=t.directiveEnd;cl(t)&&function KZ(e,n,t){const r=os(n,e),s=QE(t),o=e[10].rendererFactory,i=nw(e,cm(e,s,null,nD(t),r,n,null,o.createRenderer(r,t),null,null,null));e[n.index]=i}(n,t,e.data[s+t.componentOffset]),e.firstCreatePass||Nb(t,n),is(r,n);const i=t.initialInputs;for(let a=s;a<o;a++){const l=e.data[a],u=Bu(n,e,a,t);is(u,n),null!==i&&XZ(0,a-s,u,l,0,i),Qo(l)&&(oo(t.index,n)[8]=Bu(n,e,a,t))}}(e,n,t,os(t,n)),!(64&~t.flags)&&j$(e,n,t))}function ZE(e,n,t=os){const r=n.localNames;if(null!==r){let s=n.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?t(n,e):e[i];e[s++]=a}}}function QE(e){const n=e.tView;return null===n||n.incompleteFirstPass?e.tView=JE(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts,e.id):n}function JE(e,n,t,r,s,o,i,a,l,u,c){const d=25+r,h=d+s,f=function kZ(e,n){const t=[];for(let r=0;r<n;r++)t.push(r<e?null:nt);return t}(d,h),p="function"==typeof u?u():u;return f[1]={type:e,blueprint:f,template:t,queries:null,viewQuery:a,declTNode:n,data:f.slice().fill(null,d),bindingStartIndex:d,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:l,consts:p,incompleteFirstPass:!1,ssrId:c}}let z$=()=>null;function U$(e,n,t,r,s){for(let o in n){if(!n.hasOwnProperty(o))continue;const i=n[o];if(void 0===i)continue;r??={};let a,l=vl.None;Array.isArray(i)?(a=i[0],l=i[1]):a=i;let u=o;if(null!==s){if(!s.hasOwnProperty(o))continue;u=s[o]}0===e?W$(r,t,u,a,l):W$(r,t,u,a)}return r}function W$(e,n,t,r,s){let o;e.hasOwnProperty(t)?(o=e[t]).push(n,r):o=e[t]=[n,r],void 0!==s&&o.push(s)}function Hs(e,n,t,r,s,o,i,a){const l=os(n,t);let c,u=n.inputs;!a&&null!=u&&(c=u[r])?(sD(e,t,c,r,s),cl(n)&&function PZ(e,n){const t=oo(n,e);16&t[2]||(t[2]|=64)}(t,n.index)):3&n.type&&(r=function $Z(e){return"class"===e?"className":"for"===e?"htmlFor":"formaction"===e?"formAction":"innerHtml"===e?"innerHTML":"readonly"===e?"readOnly":"tabindex"===e?"tabIndex":e}(r),s=null!=i?i(s,n.value||"",r):s,o.setProperty(l,r,s))}function eD(e,n,t,r){if(p2()){const s=null===r?null:{"":-1},o=function WZ(e,n){const t=e.directiveRegistry;let r=null,s=null;if(t)for(let o=0;o<t.length;o++){const i=t[o];if(k$(n,i.selectors,!1))if(r||(r=[]),Qo(i))if(null!==i.findHostDirectiveDefs){const a=[];s=s||new Map,i.findHostDirectiveDefs(i,a,s),r.unshift(...a,i),tD(e,n,a.length)}else r.unshift(i),tD(e,n,0);else s=s||new Map,i.findHostDirectiveDefs?.(i,r,s),r.push(i)}return null===r?null:[r,s]}(e,t);let i,a;null===o?i=a=null:[i,a]=o,null!==i&&H$(e,n,t,i,s,a),s&&function HZ(e,n,t){if(n){const r=e.localNames=[];for(let s=0;s<n.length;s+=2){const o=t[n[s+1]];if(null==o)throw new te(-301,!1);r.push(n[s],o)}}}(t,r,s)}t.mergedAttrs=Ed(t.mergedAttrs,t.attrs)}function H$(e,n,t,r,s,o){for(let u=0;u<r.length;u++)J_(Nb(t,n),e,r[u].type);!function GZ(e,n,t){e.flags|=1,e.directiveStart=n,e.directiveEnd=n+t,e.providerIndexes=n}(t,e.data.length,r.length);for(let u=0;u<r.length;u++){const c=r[u];c.providersResolver&&c.providersResolver(c)}let i=!1,a=!1,l=dm(e,n,r.length,null);for(let u=0;u<r.length;u++){const c=r[u];t.mergedAttrs=Ed(t.mergedAttrs,c.hostAttrs),qZ(e,t,n,l,c),jZ(l,c,s),null!==c.contentQueries&&(t.flags|=4),(null!==c.hostBindings||null!==c.hostAttrs||0!==c.hostVars)&&(t.flags|=64);const d=c.type.prototype;!i&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((e.preOrderHooks??=[]).push(t.index),i=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((e.preOrderCheckHooks??=[]).push(t.index),a=!0),l++}!function FZ(e,n,t){const s=n.directiveEnd,o=e.data,i=n.attrs,a=[];let l=null,u=null;for(let c=n.directiveStart;c<s;c++){const d=o[c],h=t?t.get(d):null,p=h?h.outputs:null;l=U$(0,d.inputs,c,l,h?h.inputs:null),u=U$(1,d.outputs,c,u,p);const m=null===l||null===i||qE(n)?null:YZ(l,c,i);a.push(m)}null!==l&&(l.hasOwnProperty("class")&&(n.flags|=8),l.hasOwnProperty("style")&&(n.flags|=16)),n.initialInputs=a,n.inputs=l,n.outputs=u}(e,t,o)}function j$(e,n,t){const r=t.directiveStart,s=t.directiveEnd,o=t.index,i=function k9(){return Ze.lFrame.currentDirectiveIndex}();try{Lu(o);for(let a=r;a<s;a++){const l=e.data[a],u=n[a];z_(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&UZ(l,u)}}finally{Lu(-1),z_(i)}}function UZ(e,n){null!==e.hostBindings&&e.hostBindings(1,n)}function tD(e,n,t){n.componentOffset=t,(e.components??=[]).push(n.index)}function jZ(e,n,t){if(t){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)t[n.exportAs[r]]=e;Qo(n)&&(t[""]=e)}}function qZ(e,n,t,r,s){e.data[r]=s;const o=s.factory||(s.factory=Tu(s.type)),i=new Vp(o,Qo(s),se);e.blueprint[r]=i,t[r]=i,function VZ(e,n,t,r,s){const o=s.hostBindings;if(o){let i=e.hostBindingOpCodes;null===i&&(i=e.hostBindingOpCodes=[]);const a=~n.index;(function BZ(e){let n=e.length;for(;n>0;){const t=e[--n];if("number"==typeof t&&t<0)return t}return 0})(i)!=a&&i.push(a),i.push(t,r,o)}}(e,n,r,dm(e,t,s.hostVars,nt),s)}function nD(e){let n=16;return e.signals?n=4096:e.onPush&&(n=64),n}function Oi(e,n,t,r,s,o){const i=os(e,n);!function rD(e,n,t,r,s,o,i){if(null==o)e.removeAttribute(n,s,t);else{const a=null==i?tt(o):i(o,r||"",s);e.setAttribute(n,s,a,t)}}(n[11],i,o,e.value,t,r,s)}function XZ(e,n,t,r,s,o){const i=o[n];if(null!==i)for(let a=0;a<i.length;)O$(r,t,i[a++],i[a++],i[a++],i[a++])}function YZ(e,n,t){let r=null,s=0;for(;s<t.length;){const o=t[s];if(0!==o)if(5!==o){if("number"==typeof o)break;if(e.hasOwnProperty(o)){null===r&&(r=[]);const i=e[o];for(let a=0;a<i.length;a+=3)if(i[a]===n){r.push(o,i[a+1],i[a+2],t[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function G$(e,n,t,r){return[e,!0,0,n,null,r,null,t,null,null]}function nw(e,n){return e[12]?e[13][4]=n:e[12]=n,e[13]=n,n}function rw(e,n){const t=e[9],r=t?t.get(Ri,null):null;r&&r.handleError(n)}function sD(e,n,t,r,s){for(let o=0;o<t.length;){const i=t[o++],a=t[o++],l=t[o++];O$(e.data[i],n[i],r,a,l,s)}}function ZZ(e,n){const t=oo(n,e),r=t[1];!function QZ(e,n){for(let t=n.length;t<e.blueprint.length;t++)n.push(e.blueprint[t])}(r,t);const s=t[0];null!==s&&null===t[6]&&(t[6]=null),sw(r,t,t[8])}function sw(e,n,t){H_(n);try{const r=e.viewQuery;null!==r&&PE(1,r,t);const s=e.template;null!==s&&B$(e,n,s,1,t),e.firstCreatePass&&(e.firstCreatePass=!1),n[18]?.finishViewCreation(e),e.staticContentQueries&&i$(e,n),e.staticViewQueries&&PE(2,e.viewQuery,t);const o=e.components;null!==o&&function JZ(e,n){for(let t=0;t<n.length;t++)ZZ(e,n[t])}(n,o)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0,e.firstCreatePass=!1),r}finally{n[2]&=-5,j_()}}var bl=function(e){return e[e.Important=1]="Important",e[e.DashCase=2]="DashCase",e}(bl||{});function iD(e,n){return undefined(e,n)}function Ud(e,n,t,r,s){if(null!=r){let o,i=!1;xr(r)?o=r:Mn(r)&&(i=!0,r=r[0]);const a=Mt(r);0===e&&null!==t?null==s?$$(n,t,a):qu(n,t,a,s||null,!0):1===e&&null!==t?qu(n,t,a,s||null,!0):2===e?function um(e,n,t){e.removeChild(null,n,t)}(n,a,i):3===e&&n.destroyNode(a),null!=o&&function aQ(e,n,t,r,s){const o=t[7];o!==Mt(t)&&Ud(n,e,r,o,s);for(let a=10;a<t.length;a++){const l=t[a];iw(l[1],l,e,n,r,o)}}(n,e,o,t,s)}}function X$(e,n){n[10].changeDetectionScheduler?.notify(10),iw(e,n,n[11],2,null,null)}function Y$(e,n){const t=e[9],r=n[3];(Mn(r)||n[15]!==r[3][15])&&(e[2]|=2),null===t?e[9]=[n]:t.push(n)}function aD(e,n){const t=e[9],r=t.indexOf(n);t.splice(r,1)}function hm(e,n){if(e.length<=10)return;const t=10+n,r=e[t];if(r){const s=r[16];null!==s&&s!==e&&aD(s,r),n>0&&(e[t-1][4]=r[4]);const o=ab(e,10+n);!function K$(e,n){X$(e,n),n[0]=null,n[5]=null}(r[1],r);const i=o[18];null!==i&&i.detachView(o[1]),r[3]=null,r[4]=null,r[2]&=-129}return r}function fm(e,n){if(dl(n))return;const t=n[11];t.destroyNode&&iw(e,n,t,3,null,null),function nQ(e){let n=e[12];if(!n)return lD(e[1],e);for(;n;){let t=null;if(Mn(n))t=n[12];else{const r=n[10];r&&(t=r)}if(!t){for(;n&&!n[4]&&n!==e;)Mn(n)&&lD(n[1],n),n=n[3];null===n&&(n=e),Mn(n)&&lD(n[1],n),t=n&&n[4]}n=t}}(n)}function lD(e,n){if(dl(n))return;const t=st(null);try{n[2]&=-129,n[2]|=256,n[24]&&Ep(n[24]),function oQ(e,n){let t;if(null!=e&&null!=(t=e.destroyHooks))for(let r=0;r<t.length;r+=2){const s=n[t[r]];if(!(s instanceof Vp)){const o=t[r+1];if(Array.isArray(o))for(let i=0;i<o.length;i+=2){const a=s[o[i]],l=o[i+1];try{l.call(a)}finally{}}else try{o.call(s)}finally{}}}}(e,n),function sQ(e,n){const t=e.cleanup,r=n[7];if(null!==t)for(let i=0;i<t.length-1;i+=2)if("string"==typeof t[i]){const a=t[i+3];a>=0?r[a]():r[-a].unsubscribe(),i+=2}else t[i].call(r[t[i+1]]);null!==r&&(n[7]=null);const s=n[21];if(null!==s){n[21]=null;for(let i=0;i<s.length;i++)(0,s[i])()}const o=n[23];if(null!==o){n[23]=null;for(const i of o)i.destroy()}}(e,n),1===n[1].type&&n[11].destroy();const r=n[16];if(null!==r&&xr(n[3])){r!==n[3]&&aD(r,n);const s=n[18];null!==s&&s.detachView(e)}lE(n)}finally{st(t)}}function uD(e,n,t){return function Z$(e,n,t){let r=n;for(;null!==r&&168&r.type;)r=(n=r).parent;if(null===r)return t[0];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:o}=e.data[r.directiveStart+s];if(o===Lo.None||o===Lo.Emulated)return null}return os(r,t)}}(e,n.parent,t)}let eP=function J$(e,n,t){return 40&e.type?os(e,t):null};function ow(e,n,t,r){const s=uD(e,r,n),o=n[11],a=function Q$(e,n,t){return eP(e,n,t)}(r.parent||n[5],r,n);if(null!=s)if(Array.isArray(t))for(let l=0;l<t.length;l++)P$(o,s,t[l],a,!1);else P$(o,s,t,a,!1)}function Ku(e,n){if(null!==n){const t=n.type;if(3&t)return os(n,e);if(4&t)return dD(-1,e[n.index]);if(8&t){const r=n.child;if(null!==r)return Ku(e,r);{const s=e[n.index];return xr(s)?dD(-1,s):Mt(s)}}if(128&t)return Ku(e,n.next);if(32&t)return iD(n,e)()||Mt(e[n.index]);{const r=nP(e,n);return null!==r?Array.isArray(r)?r[0]:Ku(wa(e[15]),r):Ku(e,n.next)}}return null}function nP(e,n){return null!==n?e[15][5].projection[n.projection]:null}function dD(e,n){const t=10+e+1;if(t<n.length){const r=n[t],s=r[1].firstChild;if(null!==s)return Ku(r,s)}return n[7]}function hD(e,n,t,r,s,o,i){for(;null!=t;){if(128===t.type){t=t.next;continue}const a=r[t.index],l=t.type;if(i&&0===n&&(a&&is(Mt(a),r),t.flags|=2),32&~t.flags)if(8&l)hD(e,n,t.child,r,s,o,!1),Ud(n,e,s,a,o);else if(32&l){const u=iD(t,r);let c;for(;c=u();)Ud(n,e,s,c,o);Ud(n,e,s,a,o)}else 16&l?rP(e,n,r,t,s,o):Ud(n,e,s,a,o);t=i?t.projectionNext:t.next}}function iw(e,n,t,r,s,o){hD(t,r,e.firstChild,n,s,o,!1)}function rP(e,n,t,r,s,o){const i=t[15],l=i[5].projection[r.projection];if(Array.isArray(l))for(let u=0;u<l.length;u++)Ud(n,e,s,l[u],o);else{let u=l;const c=i[3];Gp(r)&&(u.flags|=128),hD(e,n,u,c,s,o,!0)}}function Xu(e,n){return!n||null===n.firstChild||Gp(e)}function jd(e,n,t,r,s=!1){for(;null!==t;){if(128===t.type){t=s?t.projectionNext:t.next;continue}const o=n[t.index];null!==o&&r.push(Mt(o)),xr(o)&&pD(o,r);const i=t.type;if(8&i)jd(e,n,t.child,r);else if(32&i){const a=iD(t,n);let l;for(;l=a();)r.push(l)}else if(16&i){const a=nP(n,t);if(Array.isArray(a))r.push(...a);else{const l=wa(n[15]);jd(l[1],l,a,r,!0)}}t=s?t.projectionNext:t.next}return r}function pD(e,n){for(let t=10;t<e.length;t++){const r=e[t],s=r[1].firstChild;null!==s&&jd(r[1],r,s,n)}e[7]!==e[0]&&n.push(e[7])}let oP=[];const hQ={...Cu,consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:e=>{$p(e.lView)},consumerOnSignalRead(){this.lView[24]=this}},pQ={...Cu,consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:e=>{let n=wa(e.lView);for(;n&&!iP(n[1]);)n=wa(n);n&&O_(n)},consumerOnSignalRead(){this.lView[24]=this}};function iP(e){return 2!==e.type}function aP(e){if(null===e[23])return;let n=!0;for(;n;){let t=!1;for(const r of e[23])r.dirty&&(t=!0,null===r.zone||Zone.current===r.zone?r.run():r.zone.run(()=>r.run()));n=t&&!!(8192&e[2])}}function aw(e,n=!0,t=0){const s=e[10].rendererFactory;s.begin?.();try{!function gQ(e,n){const t=v2();try{Cb(!0),mD(e,n);let r=0;for(;bb(e);){if(100===r)throw new te(103,!1);r++,mD(e,1)}}finally{Cb(t)}}(e,t)}catch(i){throw n&&rw(e,i),i}finally{s.end?.()}}function uP(e,n,t,r){if(dl(n))return;const s=n[2];H_(n);let a=!0,l=null,u=null;iP(e)?(u=function uQ(e){return e[24]??function cQ(e){const n=oP.pop()??Object.create(hQ);return n.lView=e,n}(e)}(n),l=Su(u)):null===function US(){return mr}()?(a=!1,u=function fQ(e){const n=e[24]??Object.create(pQ);return n.lView=e,n}(n),l=Su(u)):n[24]&&(Ep(n[24]),n[24]=null);try{c2(n),function b2(e){return Ze.lFrame.bindingIndex=e}(e.bindingStartIndex),null!==t&&B$(e,n,t,2,r);const c=!(3&~s);if(c){const f=e.preOrderCheckHooks;null!==f&&_b(n,f,null)}else{const f=e.preOrderHooks;null!==f&&Eb(n,f,0,null),G_(n,0)}if(function yQ(e){for(let n=yF(e);null!==n;n=vF(n)){if(!(2&n[2]))continue;const t=n[9];for(let r=0;r<t.length;r++)O_(t[r])}}(n),aP(n),cP(n,0),null!==e.contentQueries&&i$(e,n),c){const f=e.contentCheckHooks;null!==f&&_b(n,f)}else{const f=e.contentHooks;null!==f&&Eb(n,f,1),G_(n,1)}!function bQ(e,n){const t=e.hostBindingOpCodes;if(null!==t)try{for(let r=0;r<t.length;r++){const s=t[r];if(s<0)Lu(~s);else{const o=s,i=t[++r],a=t[++r];T9(i,o);const l=n[o];a(2,l)}}}finally{Lu(-1)}}(e,n);const d=e.components;null!==d&&hP(n,d,0);const h=e.viewQuery;if(null!==h&&PE(2,h,r),c){const f=e.viewCheckHooks;null!==f&&_b(n,f)}else{const f=e.viewHooks;null!==f&&Eb(n,f,2),G_(n,2)}if(!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),n[22]){for(const f of n[22])f();n[22]=null}n[2]&=-73}catch(c){throw $p(n),c}finally{null!==u&&(ad(u,l),a&&function dQ(e){e.lView[24]!==e&&(e.lView=null,oP.push(e))}(u)),j_()}}function cP(e,n){for(let t=yF(e);null!==t;t=vF(t))for(let r=10;r<t.length;r++)dP(t[r],n)}function vQ(e,n,t){dP(oo(n,e),t)}function dP(e,n){M_(e)&&mD(e,n)}function mD(e,n){const r=e[1],s=e[2],o=e[24];let i=!!(0===n&&16&s);if(i||=!!(64&s&&0===n),i||=!!(1024&s),i||=!(!o?.dirty||!_p(o)),i||=!1,o&&(o.dirty=!1),e[2]&=-9217,i)uP(r,e,r.template,e[8]);else if(8192&s){aP(e),cP(e,1);const a=r.components;null!==a&&hP(e,a,1)}}function hP(e,n,t){for(let r=0;r<n.length;r++)vQ(e,n[r],t)}function pm(e,n){const t=v2()?64:1088;for(e[10].changeDetectionScheduler?.notify(n);e;){e[2]|=t;const r=wa(e);if(Fp(e)&&!r)return e;e=r}return null}class mm{_lView;_cdRefInjectingView;notifyErrorHandler;_appRef=null;_attachedToViewContainer=!1;get rootNodes(){const n=this._lView,t=n[1];return jd(t,n,t.firstChild,[])}constructor(n,t,r=!0){this._lView=n,this._cdRefInjectingView=t,this.notifyErrorHandler=r}get context(){return this._lView[8]}get dirty(){return!!(9280&this._lView[2])||!!this._lView[24]?.dirty}set context(n){this._lView[8]=n}get destroyed(){return dl(this._lView)}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const n=this._lView[3];if(xr(n)){const t=n[8],r=t?t.indexOf(this):-1;r>-1&&(hm(n,r),ab(t,r))}this._attachedToViewContainer=!1}fm(this._lView[1],this._lView)}onDestroy(n){wb(this._lView,n)}markForCheck(){pm(this._cdRefInjectingView||this._lView,4)}markForRefresh(){O_(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){F_(this._lView),this._lView[2]|=128}detectChanges(){this._lView[2]|=1024,aw(this._lView,this.notifyErrorHandler)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new te(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;const n=Fp(this._lView),t=this._lView[16];null!==t&&!n&&aD(t,this._lView),X$(this._lView[1],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new te(902,!1);this._appRef=n;const t=Fp(this._lView),r=this._lView[16];null!==r&&!t&&Y$(r,this._lView),F_(this._lView)}}let _a=(()=>class e{static __NG_ELEMENT_ID__=CQ})();const wQ=_a,xQ=class extends wQ{_declarationLView;_declarationTContainer;elementRef;constructor(n,t,r){super(),this._declarationLView=n,this._declarationTContainer=t,this.elementRef=r}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(n,t){return this.createEmbeddedViewImpl(n,t)}createEmbeddedViewImpl(n,t,r){const s=function Wd(e,n,t,r){const s=st(null);try{const o=n.tView,l=cm(e,o,t,4096&e[2]?4096:16,null,n,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null);l[16]=e[n.index];const c=e[18];return null!==c&&(l[18]=c.createEmbeddedView(o)),sw(o,l,t),l}finally{st(s)}}(this._declarationLView,this._declarationTContainer,n,{embeddedViewInjector:t,dehydratedView:r});return new mm(s)}};function CQ(){return lw(ht(),K())}function lw(e,n){return 4&e.type?new xQ(n,e,Dd(e,n)):null}function Yu(e,n,t,r,s){let o=e.data[n];if(null===o)o=function bD(e,n,t,r,s){const o=m2(),i=V_(),l=e.data[n]=function RQ(e,n,t,r,s,o){let i=n?n.injectorIndex:-1,a=0;return function Pu(){return null!==Ze.skipHydrationRootTNode}()&&(a|=128),{type:t,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:a,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,t,n,r,s);return function AQ(e,n,t,r){null===e.firstChild&&(e.firstChild=n),null!==t&&(r?null==t.child&&null!==n.parent&&(t.child=n):null===t.next&&(t.next=n,n.prev=t))}(e,l,o,i),l}(e,n,t,r,s),function N9(){return Ze.lFrame.inI18n}()&&(o.flags|=32);else if(64&o.type){o.type=t,o.value=r,o.attrs=s;const i=function Pp(){const e=Ze.lFrame,n=e.currentTNode;return e.isParent?n:n.parent}();o.injectorIndex=null===i?-1:i.injectorIndex}return ei(o,!0),o}class vJ{}class OP{}class bJ{resolveComponentFactory(n){throw Error(`No component factory found for ${vr(n)}.`)}}class pw{static NULL=new bJ}class ND{}let Ea=(()=>class e{destroyNode=null;static __NG_ELEMENT_ID__=()=>function wJ(){const e=K(),t=oo(ht().index,e);return(Mn(t)?t:e)[11]}()})(),xJ=(()=>{class e{static \u0275prov=_e({token:e,providedIn:"root",factory:()=>null})}return e})();function gw(e,n,t){let r=t?e.styles:null,s=t?e.classes:null,o=0;if(null!==n)for(let i=0;i<n.length;i++){const a=n[i];"number"==typeof a?o=a:1==o?s=o_(s,a):2==o&&(r=o_(r,a+": "+n[++i]+";"))}t?e.styles=r:e.stylesWithoutHost=r,t?e.classes=s:e.classesWithoutHost=s}class PP extends pw{ngModule;constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){const t=dt(n);return new _m(t,this.ngModule)}}function LP(e,n){const t=[];for(const r in e){if(!e.hasOwnProperty(r))continue;const s=e[r];if(void 0===s)continue;const o=Array.isArray(s),i=o?s[0]:s;t.push(n?{propName:i,templateName:r,isSignal:!!((o?s[1]:vl.None)&vl.SignalBased)}:{propName:i,templateName:r})}return t}class _m extends OP{componentDef;ngModule;selector;componentType;ngContentSelectors;isBoundToModule;get inputs(){const n=this.componentDef,t=n.inputTransforms,r=LP(n.inputs,!0);if(null!==t)for(const s of r)t.hasOwnProperty(s.propName)&&(s.transform=t[s.propName]);return r}get outputs(){return LP(this.componentDef.outputs,!1)}constructor(n,t){super(),this.componentDef=n,this.ngModule=t,this.componentType=n.type,this.selector=function EZ(e){return e.map(_Z).join(",")}(n.selectors),this.ngContentSelectors=n.ngContentSelectors?n.ngContentSelectors:[],this.isBoundToModule=!!t}create(n,t,r,s){const o=st(null);try{let i=(s=s||this.ngModule)instanceof ws?s:s?.injector;i&&null!==this.componentDef.getStandaloneInjector&&(i=this.componentDef.getStandaloneInjector(i)||i);const a=i?new Vu(n,i):n,l=a.get(ND,null);if(null===l)throw new te(407,!1);const d={rendererFactory:l,sanitizer:a.get(xJ,null),changeDetectionScheduler:a.get(Ia,null)},h=l.createRenderer(null,this.componentDef),f=this.componentDef.selectors[0][0]||"div",p=r?function AZ(e,n,t,r){const o=r.get(AF,!1)||t===Lo.ShadowDom,i=e.selectRootElement(n,o);return function RZ(e){z$(e)}(i),i}(h,r,this.componentDef.encapsulation,a):tw(h,f,function SJ(e){const n=e.toLowerCase();return"svg"===n?"svg":"math"===n?"math":null}(f));let m=512;this.componentDef.signals?m|=4096:this.componentDef.onPush||(m|=16);let g=null;null!==p&&(g=null);const y=JE(0,null,null,1,0,null,null,null,null,null,null),v=cm(null,y,null,m,null,null,d,h,a,null,g);v[25]=p,H_(v);let b,w=null;try{const I=this.componentDef;let _,D=null;I.findHostDirectiveDefs?(_=[],D=new Map,I.findHostDirectiveDefs(I,_,D),_.push(I)):_=[I];const N=r?["ng-version","19.1.3"]:function _J(e){const{attrs:n,classes:t}=function DZ(e){const n=[],t=[];let r=1,s=2;for(;r<e.length;){let o=e[r];if("string"==typeof o)2===s?""!==o&&n.push(o,e[++r]):8===s&&t.push(o);else{if(!ni(s))break;s=o}r++}return{attrs:n,classes:t}}(e),r=n;return t.length&&r.push(1,...t),r}(this.componentDef.selectors[0]),T=Yu(y,25,2,"#host",N);for(const P of _)T.mergedAttrs=Ed(T.mergedAttrs,P.hostAttrs);T.mergedAttrs=Ed(T.mergedAttrs,N),gw(T,T.mergedAttrs,!0),p&&V$(h,p,T),w=function DJ(e,n,t,r,s,o){const i=s[1];let a=null;null!==n&&(a=null);const l=o.rendererFactory.createRenderer(n,t),u=cm(s,QE(t),null,nD(t),s[e.index],e,o,l,null,null,a);return i.firstCreatePass&&tD(i,e,r.length-1),nw(s,u),s[e.index]=u}(T,p,I,_,v,d),void 0!==t&&function TJ(e,n,t){const r=e.projection=[];for(let s=0;s<n.length;s++){const o=t[s];r.push(null!=o&&o.length?Array.from(o):null)}}(T,this.ngContentSelectors,t),b=function NJ(e,n,t,r,s,o){const i=ht(),a=s[1],l=os(i,s);H$(a,s,i,t,null,r);for(let c=0;c<t.length;c++)is(Bu(s,a,i.directiveStart+c,i),s);j$(a,s,i),l&&is(l,s);const u=Bu(s,a,i.directiveStart+i.componentOffset,i);if(e[8]=s[8]=u,null!==o)for(const c of o)c(u,n);return LE(a,i,s),u}(w,I,_,D,v,[kJ]),sw(y,v,null)}catch(I){throw null!==w&&lE(w),lE(v),I}finally{j_()}const x=Fu(y,25);return new EJ(this.componentType,b,Dd(x,v),v,x)}finally{st(o)}}}class EJ extends vJ{location;_rootLView;_tNode;instance;hostView;changeDetectorRef;componentType;previousInputValues=null;constructor(n,t,r,s,o){super(),this.location=r,this._rootLView=s,this._tNode=o,this.instance=t,this.hostView=this.changeDetectorRef=new mm(s,void 0,!1),this.componentType=n}setInput(n,t){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[n])){if(this.previousInputValues??=new Map,this.previousInputValues.has(n)&&Object.is(this.previousInputValues.get(n),t))return;const o=this._rootLView;sD(o[1],o,s,n,t),this.previousInputValues.set(n,t),pm(oo(this._tNode.index,o),1)}}get injector(){return new Ln(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}}function kJ(){const e=ht();Sb(K()[1],e)}let ri=(()=>class e{static __NG_ELEMENT_ID__=AJ})();function AJ(){return zP(ht(),K())}const RJ=ri,VP=class extends RJ{_lContainer;_hostTNode;_hostLView;constructor(n,t,r){super(),this._lContainer=n,this._hostTNode=t,this._hostLView=r}get element(){return Dd(this._hostTNode,this._hostLView)}get injector(){return new Ln(this._hostTNode,this._hostLView)}get parentInjector(){const n=Tb(this._hostTNode,this._hostLView);if(Y_(n)){const t=zp(n,this._hostLView),r=Bp(n);return new Ln(t[1].data[r+8],t)}return new Ln(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){const t=BP(this._lContainer);return null!==t&&t[n]||null}get length(){return this._lContainer.length-10}createEmbeddedView(n,t,r){let s,o;"number"==typeof r?s=r:null!=r&&(s=r.index,o=r.injector);const a=n.createEmbeddedViewImpl(t||{},o,null);return this.insertImpl(a,s,Xu(this._hostTNode,null)),a}createComponent(n,t,r,s,o){const i=n&&!function Op(e){return"function"==typeof e}(n);let a;if(i)a=t;else{const p=t||{};a=p.index,r=p.injector,s=p.projectableNodes,o=p.environmentInjector||p.ngModuleRef}const l=i?n:new _m(dt(n)),u=r||this.parentInjector;if(!o&&null==l.ngModule){const m=(i?u:this.parentInjector).get(ws,null);m&&(o=m)}dt(l.componentType??{});const f=l.create(u,s,null,o);return this.insertImpl(f.hostView,a,Xu(this._hostTNode,null)),f}insert(n,t){return this.insertImpl(n,t,!0)}insertImpl(n,t,r){const s=n._lView;if(function v9(e){return xr(e[3])}(s)){const a=this.indexOf(n);if(-1!==a)this.detach(a);else{const l=s[3],u=new VP(l,l[5],l[3]);u.detach(u.indexOf(n))}}const o=this._adjustIndex(t),i=this._lContainer;return function Hd(e,n,t,r=!0){const s=n[1];if(function rQ(e,n,t,r){const s=10+r,o=t.length;r>0&&(t[s-1][4]=n),r<o-10?(n[4]=t[s],UO(t,10+r,n)):(t.push(n),n[4]=null),n[3]=t;const i=n[16];null!==i&&t!==i&&Y$(i,n);const a=n[18];null!==a&&a.insertView(e),F_(n),n[2]|=128}(s,n,e,t),r){const i=dD(t,e),a=n[11],l=a.parentNode(e[7]);null!==l&&function tQ(e,n,t,r,s,o){r[0]=s,r[5]=n,iw(e,r,t,1,s,o)}(s,e[5],a,n,l,i)}const o=n[6];null!==o&&null!==o.firstChild&&(o.firstChild=null)}(i,s,o,r),n.attachToViewContainerRef(),UO(AD(i),o,n),n}move(n,t){return this.insert(n,t)}indexOf(n){const t=BP(this._lContainer);return null!==t?t.indexOf(n):-1}remove(n){const t=this._adjustIndex(n,-1),r=hm(this._lContainer,t);r&&(ab(AD(this._lContainer),t),fm(r[1],r))}detach(n){const t=this._adjustIndex(n,-1),r=hm(this._lContainer,t);return r&&null!=ab(AD(this._lContainer),t)?new mm(r):null}_adjustIndex(n,t=0){return n??this.length+t}};function BP(e){return e[8]}function AD(e){return e[8]||(e[8]=[])}function zP(e,n){let t;const r=n[e.index];return xr(r)?t=r:(t=G$(r,n,null,e),n[e.index]=t,nw(n,t)),UP(t,n,e,r),new VP(t,e,n)}let UP=function HP(e,n,t,r){if(e[7])return;let s;s=8&t.type?Mt(r):function MJ(e,n){const t=e[11],r=t.createComment(""),s=os(n,e),o=t.parentNode(s);return qu(t,o,r,t.nextSibling(s),!1),r}(n,t),e[7]=s};class MD{queryList;matches=null;constructor(n){this.queryList=n}clone(){return new MD(this.queryList)}setDirty(){this.queryList.setDirty()}}class OD{queries;constructor(n=[]){this.queries=n}createEmbeddedView(n){const t=n.queries;if(null!==t){const r=null!==n.contentQueries?n.contentQueries[0]:t.length,s=[];for(let o=0;o<r;o++){const i=t.getByIndex(o);s.push(this.queries[i.indexInDeclarationView].clone())}return new OD(s)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}finishViewCreation(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let t=0;t<this.queries.length;t++)null!==VD(n,t).matches&&this.queries[t].setDirty()}}class jP{flags;read;predicate;constructor(n,t,r=null){this.flags=t,this.read=r,this.predicate="string"==typeof n?function zJ(e){return e.split(",").map(n=>n.trim())}(n):n}}class FD{queries;constructor(n=[]){this.queries=n}elementStart(n,t){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,t)}elementEnd(n){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(n)}embeddedTView(n){let t=null;for(let r=0;r<this.length;r++){const s=null!==t?t.length:0,o=this.getByIndex(r).embeddedTView(n,s);o&&(o.indexInDeclarationView=r,null!==t?t.push(o):t=[o])}return null!==t?new FD(t):null}template(n,t){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,t)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}}class $D{metadata;matches=null;indexInDeclarationView=-1;crossesNgTemplate=!1;_declarationNodeIndex;_appliesToNextNode=!0;constructor(n,t=-1){this.metadata=n,this._declarationNodeIndex=t}elementStart(n,t){this.isApplyingToNode(t)&&this.matchTNode(n,t)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,t){this.elementStart(n,t)}embeddedTView(n,t){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,t),new $D(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&1&~this.metadata.flags){const t=this._declarationNodeIndex;let r=n.parent;for(;null!==r&&8&r.type&&r.index!==t;)r=r.parent;return t===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(n,t){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const o=r[s];this.matchTNodeWithReadOption(n,t,PJ(t,o)),this.matchTNodeWithReadOption(n,t,kb(t,n,o,!1,!1))}else r===_a?4&t.type&&this.matchTNodeWithReadOption(n,t,-1):this.matchTNodeWithReadOption(n,t,kb(t,n,r,!1,!1))}matchTNodeWithReadOption(n,t,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===uo||s===ri||s===_a&&4&t.type)this.addMatch(t.index,-2);else{const o=kb(t,n,s,!1,!1);null!==o&&this.addMatch(t.index,o)}else this.addMatch(t.index,r)}}addMatch(n,t){null===this.matches?this.matches=[n,t]:this.matches.push(n,t)}}function PJ(e,n){const t=e.localNames;if(null!==t)for(let r=0;r<t.length;r+=2)if(t[r]===n)return t[r+1];return null}function VJ(e,n,t,r){return-1===t?function LJ(e,n){return 11&e.type?Dd(e,n):4&e.type?lw(e,n):null}(n,e):-2===t?function BJ(e,n,t){return t===uo?Dd(n,e):t===_a?lw(n,e):t===ri?zP(n,e):void 0}(e,n,r):Bu(e,e[1],t,n)}function GP(e,n,t,r){const s=n[18].queries[r];if(null===s.matches){const o=e.data,i=t.matches,a=[];for(let l=0;null!==i&&l<i.length;l+=2){const u=i[l];a.push(u<0?null:VJ(n,o[u],i[l+1],t.metadata.read))}s.matches=a}return s.matches}function PD(e,n,t,r){const s=e.queries.getByIndex(t),o=s.matches;if(null!==o){const i=GP(e,n,s,t);for(let a=0;a<o.length;a+=2){const l=o[a];if(l>0)r.push(i[a/2]);else{const u=o[a+1],c=n[-l];for(let d=10;d<c.length;d++){const h=c[d];h[16]===h[3]&&PD(h[1],h,u,r)}if(null!==c[9]){const d=c[9];for(let h=0;h<d.length;h++){const f=d[h];PD(f[1],f,u,r)}}}}}return r}function KP(e,n,t){const r=Xe();return r.firstCreatePass&&(function YP(e,n,t){null===e.queries&&(e.queries=new FD),e.queries.track(new $D(n,t))}(r,new jP(e,n,t),-1),!(2&~n)&&(r.staticViewQueries=!0)),function qP(e,n,t){const r=new C7(!(4&~t));return function b9(e,n,t,r){const s=h2(n);s.push(t),e.firstCreatePass&&f2(e).push(r,s.length-1)}(e,n,r,r.destroy),(n[18]??=new OD).queries.push(new MD(r))-1}(r,K(),n)}function VD(e,n){return e.queries.getByIndex(n)}function ZP(e,n){const t=e[1],r=VD(t,n);return r.crossesNgTemplate?PD(t,e,n,[]):GP(t,e,r,n)}class Qu{}class lL{}class zD extends Qu{ngModuleType;_parent;_bootstrapComponents=[];_r3Injector;instance;destroyCbs=[];componentFactoryResolver=new PP(this);constructor(n,t,r,s=!0){super(),this.ngModuleType=n,this._parent=t;const o=rs(n);this._bootstrapComponents=co(o.bootstrap),this._r3Injector=K2(n,t,[{provide:Qu,useValue:this},{provide:pw,useValue:this.componentFactoryResolver},...r],vr(n),new Set(["environment"])),s&&this.resolveInjectorInitializers()}resolveInjectorInitializers(){this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(this.ngModuleType)}get injector(){return this._r3Injector}destroy(){const n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(t=>t()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}}class UD extends lL{moduleType;constructor(n){super(),this.moduleType=n}create(n){return new zD(this.moduleType,n,[])}}class uL extends Qu{injector;componentFactoryResolver=new PP(this);instance=null;constructor(n){super();const t=new Au([...n.providers,{provide:Qu,useValue:this},{provide:pw,useValue:this.componentFactoryResolver}],n.parent||hb(),n.debugName,new Set(["environment"]));this.injector=t,n.runEnvironmentInitializers&&t.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}}function vw(e,n,t=null){return new uL({providers:e,parent:n,debugName:t,runEnvironmentInitializers:!0}).injector}let eee=(()=>{class e{_injector;cachedInjectors=new Map;constructor(t){this._injector=t}getOrCreateStandaloneInjector(t){if(!t.standalone)return null;if(!this.cachedInjectors.has(t)){const r=x_(0,t.type),s=r.length>0?vw([r],this._injector,`Standalone[${t.type.name}]`):null;this.cachedInjectors.set(t,s)}return this.cachedInjectors.get(t)}ngOnDestroy(){try{for(const t of this.cachedInjectors.values())null!==t&&t.destroy()}finally{this.cachedInjectors.clear()}}static \u0275prov=_e({token:e,providedIn:"environment",factory:()=>new e($e(ws))})}return e})();function Cl(e){return ma(()=>{const n=dL(e),t={...n,decls:e.decls,vars:e.vars,template:e.template,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,onPush:e.changeDetection===Ob.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&e.dependencies||null,getStandaloneInjector:n.standalone?s=>s.get(eee).getOrCreateStandaloneInjector(t):null,getExternalStyles:null,signals:e.signals??!1,data:e.data||{},encapsulation:e.encapsulation||Lo.Emulated,styles:e.styles||Lt,_:null,schemas:e.schemas||null,tView:null,id:""};n.standalone&&Fr("NgStandalone"),hL(t);const r=e.dependencies;return t.directiveDefs=bw(r,!1),t.pipeDefs=bw(r,!0),t.id=function see(e){let n=0;const r=[e.selectors,e.ngContentSelectors,e.hostVars,e.hostAttrs,"function"==typeof e.consts?"":e.consts,e.vars,e.decls,e.encapsulation,e.standalone,e.signals,e.exportAs,JSON.stringify(e.inputs),JSON.stringify(e.outputs),Object.getOwnPropertyNames(e.type.prototype),!!e.contentQueries,!!e.viewQuery];for(const o of r.join("|"))n=Math.imul(31,n)+o.charCodeAt(0)|0;return n+=2147483648,"c"+n}(t),t})}function tee(e){return dt(e)||br(e)}function nee(e){return null!==e}function Ju(e){return ma(()=>({type:e.type,bootstrap:e.bootstrap||Lt,declarations:e.declarations||Lt,imports:e.imports||Lt,exports:e.exports||Lt,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null}))}function cL(e,n){if(null==e)return Di;const t={};for(const r in e)if(e.hasOwnProperty(r)){const s=e[r];let o,i,a=vl.None;Array.isArray(s)?(a=s[0],o=s[1],i=s[2]??o):(o=s,i=s),n?(t[o]=a!==vl.None?[r,a]:r,n[o]=i):t[o]=r}return t}function Je(e){return ma(()=>{const n=dL(e);return hL(n),n})}function dL(e){const n={};return{type:e.type,providersResolver:null,factory:null,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:n,inputTransforms:null,inputConfig:e.inputs||Di,exportAs:e.exportAs||null,standalone:e.standalone??!0,signals:!0===e.signals,selectors:e.selectors||Lt,viewQuery:e.viewQuery||null,features:e.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:cL(e.inputs,n),outputs:cL(e.outputs),debugInfo:null}}function hL(e){e.features?.forEach(n=>n(e))}function bw(e,n){if(!e)return null;const t=n?Xr:tee;return()=>("function"==typeof e?e():e).map(r=>t(r)).filter(nee)}function qt(e){let n=function fL(e){return Object.getPrototypeOf(e.prototype).constructor}(e.type),t=!0;const r=[e];for(;n;){let s;if(Qo(e))s=n.\u0275cmp||n.\u0275dir;else{if(n.\u0275cmp)throw new te(903,!1);s=n.\u0275dir}if(s){if(t){r.push(s);const i=e;i.inputs=ww(e.inputs),i.inputTransforms=ww(e.inputTransforms),i.declaredInputs=ww(e.declaredInputs),i.outputs=ww(e.outputs);const a=s.hostBindings;a&&uee(e,a);const l=s.viewQuery,u=s.contentQueries;if(l&&aee(e,l),u&&lee(e,u),oee(e,s),xX(e.outputs,s.outputs),Qo(s)&&s.data.animation){const c=e.data;c.animation=(c.animation||[]).concat(s.data.animation)}}const o=s.features;if(o)for(let i=0;i<o.length;i++){const a=o[i];a&&a.ngInherit&&a(e),a===qt&&(t=!1)}}n=Object.getPrototypeOf(n)}!function iee(e){let n=0,t=null;for(let r=e.length-1;r>=0;r--){const s=e[r];s.hostVars=n+=s.hostVars,s.hostAttrs=Ed(s.hostAttrs,t=Ed(t,s.hostAttrs))}}(r)}function oee(e,n){for(const t in n.inputs){if(!n.inputs.hasOwnProperty(t)||e.inputs.hasOwnProperty(t))continue;const r=n.inputs[t];if(void 0!==r&&(e.inputs[t]=r,e.declaredInputs[t]=n.declaredInputs[t],null!==n.inputTransforms)){const s=Array.isArray(r)?r[0]:r;if(!n.inputTransforms.hasOwnProperty(s))continue;e.inputTransforms??={},e.inputTransforms[s]=n.inputTransforms[s]}}}function ww(e){return e===Di?{}:e===Lt?[]:e}function aee(e,n){const t=e.viewQuery;e.viewQuery=t?(r,s)=>{n(r,s),t(r,s)}:n}function lee(e,n){const t=e.contentQueries;e.contentQueries=t?(r,s,o)=>{n(r,s,o),t(r,s,o)}:n}function uee(e,n){const t=e.hostBindings;e.hostBindings=t?(r,s)=>{n(r,s),t(r,s)}:n}function vL(e){const n=e.inputConfig,t={};for(const r in n)if(n.hasOwnProperty(r)){const s=n[r];Array.isArray(s)&&s[3]&&(t[r]=s[3])}e.inputTransforms=t}function xw(e){return!!HD(e)&&(Array.isArray(e)||!(e instanceof Map)&&Symbol.iterator in e)}function HD(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function Fi(e,n,t){return e[n]=t}function Bn(e,n,t){return!Object.is(e[n],t)&&(e[n]=t,!0)}function Tm(e,n,t,r,s,o,i,a){const l=K(),u=Xe();return function Nm(e,n,t,r,s,o,i,a,l,u){const c=t+25,d=n.firstCreatePass?function vee(e,n,t,r,s,o,i,a,l){const u=n.consts,c=Yu(n,e,4,i||null,a||null);eD(n,t,c,$o(u,l)),Sb(n,c);const d=c.tView=JE(2,c,r,s,o,n.directiveRegistry,n.pipeRegistry,null,n.schemas,u,null);return null!==n.queries&&(n.queries.template(n,c),d.queries=n.queries.embeddedTView(c)),c}(c,n,e,r,s,o,i,a,l):n.data[c];ei(d,!1);const h=bL(n,e,d,t);Lp()&&ow(n,e,h,d),is(h,e);const f=G$(h,e,h,d);return e[c]=f,nw(e,f),yb(d)&&YE(n,e,d),null!=l&&ZE(e,d,u),d}(l,u,e,n,t,r,s,$o(u.consts,o),i,a),Tm}let bL=function wL(e,n,t,r){return ki(!0),n[11].createComment("")};let DL=(()=>{class e{log(t){console.log(t)}warn(t){console.warn(t)}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"platform"})}return e})();const OL=new fe("");function Am(e){return!!e&&"function"==typeof e.then}function FL(e){return!!e&&"function"==typeof e.subscribe}const Dw=new fe("");let $L=(()=>{class e{resolve;reject;initialized=!1;done=!1;donePromise=new Promise((t,r)=>{this.resolve=t,this.reject=r});appInits=Z(Dw,{optional:!0})??[];injector=Z(Vn);constructor(){}runInitializers(){if(this.initialized)return;const t=[];for(const s of this.appInits){const o=Oo(this.injector,s);if(Am(o))t.push(o);else if(FL(o)){const i=new Promise((a,l)=>{o.subscribe({complete:a,error:l})});t.push(i)}}const r=()=>{this.done=!0,this.resolve()};Promise.all(t).then(()=>{r()}).catch(s=>{this.reject(s)}),0===t.length&&r(),this.initialized=!0}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),JD=(()=>{class e{static \u0275prov=_e({token:e,providedIn:"root",factory:()=>new PL})}return e})();class PL{queuedEffectCount=0;queues=new Map;schedule(n){this.enqueue(n)}remove(n){const r=this.queues.get(n.zone);r.has(n)&&(r.delete(n),this.queuedEffectCount--)}enqueue(n){const t=n.zone;this.queues.has(t)||this.queues.set(t,new Set);const r=this.queues.get(t);r.has(n)||(this.queuedEffectCount++,r.add(n))}flush(){for(;this.queuedEffectCount>0;)for(const[n,t]of this.queues)null===n?this.flushQueue(t):n.run(()=>this.flushQueue(t))}flushQueue(n){for(const t of n)n.delete(t),this.queuedEffectCount--,t.run()}}const Qd=new fe("");let ho=(()=>{class e{_runningTick=!1;_destroyed=!1;_destroyListeners=[];_views=[];internalErrorHandler=Z(y7);afterRenderManager=Z(SE);zonelessEnabled=Z(Wp);rootEffectScheduler=Z(JD);dirtyFlags=0;deferredDirtyFlags=0;tracingSnapshot=null;externalTestViews=new Set;afterTick=new Ls;get allViews(){return[...this.externalTestViews.keys(),...this._views]}get destroyed(){return this._destroyed}componentTypes=[];components=[];isStable=Z(ti).hasPendingTasks.pipe(Rt(t=>!t));constructor(){Z(kd,{optional:!0})}whenStable(){let t;return new Promise(r=>{t=this.isStable.subscribe({next:s=>{s&&r()}})}).finally(()=>{t.unsubscribe()})}_injector=Z(ws);_rendererFactory=null;get injector(){return this._injector}bootstrap(t,r){const s=t instanceof OP;if(!this._injector.get($L).done)throw!s&&function ll(e){const n=dt(e)||br(e)||Xr(e);return null!==n&&n.standalone}(t),new te(405,!1);let i;i=s?t:this._injector.get(pw).resolveComponentFactory(t),this.componentTypes.push(i.componentType);const a=function vte(e){return e.isBoundToModule}(i)?void 0:this._injector.get(Qu),u=i.create(Vn.NULL,[],r||i.selector,a),c=u.location.nativeElement,d=u.injector.get(OL,null);return d?.registerApplication(c),u.onDestroy(()=>{this.detachView(u.hostView),Nw(this.components,u),d?.unregisterApplication(c)}),this._loadComponent(u),u}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick=()=>{if(null!==this.tracingSnapshot){const r=this.tracingSnapshot;return this.tracingSnapshot=null,r.run(IE.CHANGE_DETECTION,this._tick),void r.dispose()}if(this._runningTick)throw new te(101,!1);const t=st(null);try{this._runningTick=!0,this.synchronize()}catch(r){this.internalErrorHandler(r)}finally{this._runningTick=!1,st(t),this.afterTick.next()}};synchronize(){null===this._rendererFactory&&!this._injector.destroyed&&(this._rendererFactory=this._injector.get(ND,null,{optional:!0})),this.dirtyFlags|=this.deferredDirtyFlags,this.deferredDirtyFlags=0;let t=0;for(;0!==this.dirtyFlags&&t++<10;)this.synchronizeOnce()}synchronizeOnce(){if(this.dirtyFlags|=this.deferredDirtyFlags,this.deferredDirtyFlags=0,16&this.dirtyFlags&&(this.dirtyFlags&=-17,this.rootEffectScheduler.flush()),7&this.dirtyFlags){const t=!!(1&this.dirtyFlags);this.dirtyFlags&=-8,this.dirtyFlags|=8;for(let{_lView:r,notifyErrorHandler:s}of this.allViews)xte(r,s,t,this.zonelessEnabled);if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),23&this.dirtyFlags)return}else this._rendererFactory?.begin?.(),this._rendererFactory?.end?.();8&this.dirtyFlags&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){this.allViews.some(({_lView:t})=>bb(t))?this.dirtyFlags|=2:this.dirtyFlags&=-8}attachView(t){const r=t;this._views.push(r),r.attachToAppRef(this)}detachView(t){const r=t;Nw(this._views,r),r.detachFromAppRef()}_loadComponent(t){this.attachView(t.hostView),this.tick(),this.components.push(t),this._injector.get(Qd,[]).forEach(s=>s(t))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(t=>t()),this._views.slice().forEach(t=>t.destroy())}finally{this._destroyed=!0,this._views=[],this._destroyListeners=[]}}onDestroy(t){return this._destroyListeners.push(t),()=>Nw(this._destroyListeners,t)}destroy(){if(this._destroyed)throw new te(406,!1);const t=this._injector;t.destroy&&!t.destroyed&&t.destroy()}get viewCount(){return this._views.length}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function Nw(e,n){const t=e.indexOf(n);t>-1&&e.splice(t,1)}function xte(e,n,t,r){(t||bb(e))&&aw(e,n,t&&!r?0:1)}function $i(e,n,t,r){const s=K();return Bn(s,Po(),n)&&(Xe(),Oi(Zt(),s,e,n,t,r)),$i}function Tw(e,n){return e<<17|n<<2}function El(e){return e>>17&32767}function rN(e){return 2|e}function nc(e){return(131068&e)>>2}function sN(e,n){return-131069&e|n<<2}function oN(e){return 1|e}function eV(e,n,t,r){const s=e[t+1],o=null===n;let i=r?El(s):nc(s),a=!1;for(;0!==i&&(!1===a||o);){const u=e[i+1];one(e[i],n)&&(a=!0,e[i+1]=r?oN(u):rN(u)),i=r?El(u):nc(u)}a&&(e[t+1]=r?rN(s):oN(s))}function one(e,n){return null===e||null==n||(Array.isArray(e)?e[1]:e)===n||!(!Array.isArray(e)||"string"!=typeof n)&&md(e,n)>=0}function Zr(e,n,t){const r=K();return Bn(r,Po(),n)&&Hs(Xe(),Zt(),r,e,n,r[11],t,!1),Zr}function iN(e,n,t,r,s){const i=s?"class":"style";sD(e,t,n.inputs[i],i,r)}function kw(e,n){return function si(e,n,t,r){const s=K(),o=Xe(),i=function Ca(e){const n=Ze.lFrame,t=n.bindingIndex;return n.bindingIndex=n.bindingIndex+e,t}(2);o.firstUpdatePass&&function uV(e,n,t,r){const s=e.data;if(null===s[t+1]){const o=s[Yr()],i=function lV(e,n){return n>=e.expandoStartIndex}(e,t);(function fV(e,n){return!!(e.flags&(n?8:16))})(o,r)&&null===n&&!i&&(n=!1),n=function pne(e,n,t,r){const s=function U_(e){const n=Ze.lFrame.currentDirectiveIndex;return-1===n?null:e[n]}(e);let o=r?n.residualClasses:n.residualStyles;if(null===s)0===(r?n.classBindings:n.styleBindings)&&(t=Mm(t=aN(null,e,n,t,r),n.attrs,r),o=null);else{const i=n.directiveStylingLast;if(-1===i||e[i]!==s)if(t=aN(s,e,n,t,r),null===o){let l=function mne(e,n,t){const r=t?n.classBindings:n.styleBindings;if(0!==nc(r))return e[El(r)]}(e,n,r);void 0!==l&&Array.isArray(l)&&(l=aN(null,e,n,l[1],r),l=Mm(l,n.attrs,r),function gne(e,n,t,r){e[El(t?n.classBindings:n.styleBindings)]=r}(e,n,r,l))}else o=function yne(e,n,t){let r;const s=n.directiveEnd;for(let o=1+n.directiveStylingLast;o<s;o++)r=Mm(r,e[o].hostAttrs,t);return Mm(r,n.attrs,t)}(e,n,r)}return void 0!==o&&(r?n.residualClasses=o:n.residualStyles=o),t}(s,o,n,r),function rne(e,n,t,r,s,o){let i=o?n.classBindings:n.styleBindings,a=El(i),l=nc(i);e[r]=t;let c,u=!1;if(Array.isArray(t)?(c=t[1],(null===c||md(t,c)>0)&&(u=!0)):c=t,s)if(0!==l){const h=El(e[a+1]);e[r+1]=Tw(h,a),0!==h&&(e[h+1]=sN(e[h+1],r)),e[a+1]=function tne(e,n){return 131071&e|n<<17}(e[a+1],r)}else e[r+1]=Tw(a,0),0!==a&&(e[a+1]=sN(e[a+1],r)),a=r;else e[r+1]=Tw(l,0),0===a?a=r:e[l+1]=sN(e[l+1],r),l=r;u&&(e[r+1]=rN(e[r+1])),eV(e,c,r,!0),eV(e,c,r,!1),function sne(e,n,t,r,s){const o=s?e.residualClasses:e.residualStyles;null!=o&&"string"==typeof n&&md(o,n)>=0&&(t[r+1]=oN(t[r+1]))}(n,c,e,r,o),i=Tw(a,l),o?n.classBindings=i:n.styleBindings=i}(s,o,n,t,i,r)}}(o,e,i,r),n!==nt&&Bn(s,i,n)&&function dV(e,n,t,r,s,o,i,a){if(!(3&n.type))return;const l=e.data,u=l[a+1],c=function nne(e){return!(1&~e)}(u)?hV(l,n,t,s,nc(u),i):void 0;Aw(c)||(Aw(o)||function ene(e){return!(2&~e)}(u)&&(o=hV(l,null,t,s,a,i)),function lQ(e,n,t,r,s){if(n)s?e.addClass(t,r):e.removeClass(t,r);else{let o=-1===r.indexOf("-")?void 0:bl.DashCase;null==s?e.removeStyle(t,r,o):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),o|=bl.Important),e.setStyle(t,r,s,o))}}(r,i,Sd(Yr(),t),s,o))}(o,o.data[Yr()],s,s[11],e,s[i+1]=function xne(e,n){return null==e||""===e||("string"==typeof n?e+=n:"object"==typeof e&&(e=vr(yl(e)))),e}(n,t),r,i)}(e,n,null,!0),kw}function aN(e,n,t,r,s){let o=null;const i=t.directiveEnd;let a=t.directiveStylingLast;for(-1===a?a=t.directiveStart:a++;a<i&&(o=n[a],r=Mm(r,o.hostAttrs,s),o!==e);)a++;return null!==e&&(t.directiveStylingLast=a),r}function Mm(e,n,t){const r=t?1:2;let s=-1;if(null!==n)for(let o=0;o<n.length;o++){const i=n[o];"number"==typeof i?s=i:s===r&&(Array.isArray(e)||(e=void 0===e?[]:["",e]),so(e,i,!!t||n[++o]))}return void 0===e?null:e}function hV(e,n,t,r,s,o){const i=null===n;let a;for(;s>0;){const l=e[s],u=Array.isArray(l),c=u?l[1]:l,d=null===c;let h=t[s+1];h===nt&&(h=d?Lt:void 0);let f=d?b_(h,r):c===r?h:void 0;if(u&&!Aw(f)&&(f=b_(l,r)),Aw(f)&&(a=f,i))return a;const p=e[s+1];s=i?El(p):nc(p)}if(null!==n){let l=o?n.residualClasses:n.residualStyles;null!=l&&(a=b_(l,r))}return a}function Aw(e){return void 0!==e}function ze(e,n,t,r){const s=K(),o=Xe(),i=25+e,a=s[11],l=o.firstCreatePass?function Hne(e,n,t,r,s,o){const i=n.consts,l=Yu(n,e,2,r,$o(i,s));return eD(n,t,l,$o(i,o)),null!==l.attrs&&gw(l,l.attrs,!1),null!==l.mergedAttrs&&gw(l,l.mergedAttrs,!0),null!==n.queries&&n.queries.elementStart(n,l),l}(i,o,s,n,t,r):o.data[i],u=yV(o,s,l,a,n,e);s[i]=u;const c=yb(l);return ei(l,!0),V$(a,u,l),!function Xd(e){return!(32&~e.flags)}(l)&&Lp()&&ow(o,s,u,l),0===function w9(){return Ze.lFrame.elementDepthCount}()&&is(u,s),function x9(){Ze.lFrame.elementDepthCount++}(),c&&(YE(o,s,l),LE(o,l,s)),null!==r&&ZE(s,l),ze}function Ye(){let e=ht();V_()?function B_(){Ze.lFrame.isParent=!1}():(e=e.parent,ei(e,!1));const n=e;(function I9(e){return Ze.skipHydrationRootTNode===e})(n)&&function D9(){Ze.skipHydrationRootTNode=null}(),function C9(){Ze.lFrame.elementDepthCount--}();const t=Xe();return t.firstCreatePass&&(Sb(t,e),k_(e)&&t.queries.elementEnd(e)),null!=n.classesWithoutHost&&function z9(e){return!!(8&e.flags)}(n)&&iN(t,n,K(),n.classesWithoutHost,!0),null!=n.stylesWithoutHost&&function U9(e){return!!(16&e.flags)}(n)&&iN(t,n,K(),n.stylesWithoutHost,!1),Ye}function rc(e,n,t,r){return ze(e,n,t,r),Ye(),rc}let yV=(e,n,t,r,s,o)=>(ki(!0),tw(r,s,function E2(){return Ze.lFrame.currentNamespace}()));function sc(){return K()}const Mw="en-US";let SV=Mw;function hn(e,n,t,r){const s=K(),o=Xe(),i=ht();return mN(o,s,s[11],i,e,n,r),hn}function mN(e,n,t,r,s,o,i){const a=yb(r),u=e.firstCreatePass&&f2(e),c=n[8],d=h2(n);let h=!0;if(3&r.type||i){const m=os(r,n),g=i?i(m):m,y=d.length,v=i?w=>i(Mt(w[r.index])):r.index;let b=null;if(!i&&a&&(b=function Bre(e,n,t,r){const s=e.cleanup;if(null!=s)for(let o=0;o<s.length-1;o+=2){const i=s[o];if(i===t&&s[o+1]===r){const a=n[7],l=s[o+2];return a.length>l?a[l]:null}"string"==typeof i&&(o+=2)}return null}(e,n,s,r.index)),null!==b)(b.__ngLastListenerFn__||b).__ngNextListenerFn__=o,b.__ngLastListenerFn__=o,h=!1;else{o=GV(r,n,c,o);const w=t.listen(g,s,o);d.push(o,w),u&&u.push(s,v,y,y+1)}}else o=GV(r,n,c,o);const f=r.outputs;let p;if(h&&null!==f&&(p=f[s])){const m=p.length;if(m)for(let g=0;g<m;g+=2){const x=n[p[g]][p[g+1]].subscribe(o),I=d.length;d.push(o,x),u&&u.push(s,r.index,I,-(I+1))}}}function jV(e,n,t,r){const s=st(null);try{return!1!==t(r)}catch(o){return rw(e,o),!1}finally{st(s)}}function GV(e,n,t,r){return function s(o){if(o===Function)return r;pm(e.componentOffset>-1?oo(e.index,n):n,5);let a=jV(n,0,r,o),l=s.__ngNextListenerFn__;for(;l;)a=jV(n,0,l,o)&&a,l=l.__ngNextListenerFn__;return a}}function ii(e=1){return function R9(e){return(Ze.lFrame.contextLView=function d2(e,n){for(;e>0;)n=n[14],e--;return n}(e,Ze.lFrame.contextLView))[8]}(e)}function Pw(e,n,t){KP(e,n,t)}function Vm(e){const n=K(),t=Xe(),r=W_();Ib(r+1);const s=VD(t,r);if(e.dirty&&function y9(e){return!(4&~e[2])}(n)===!(2&~s.metadata.flags)){if(null===s.matches)e.reset([]);else{const o=ZP(n,r);e.reset(o,oF),e.notifyOnChanges()}return!0}return!1}function Bm(){return function LD(e,n){return e[18].queries[n].queryList}(K(),W_())}function bt(e,n=""){const t=K(),r=Xe(),s=e+25,o=r.firstCreatePass?Yu(r,s,1,n,null):r.data[s],i=hB(r,t,o,n,e);t[s]=i,Lp()&&ow(r,t,i,o),ei(o,!1)}let hB=(e,n,t,r,s)=>(ki(!0),function KE(e,n){return e.createText(n)}(n[11],r));function zm(e){return Lw("",e,""),zm}function Lw(e,n,t){const r=K(),s=function eh(e,n,t,r){return Bn(e,Po(),t)?n+tt(t)+r:nt}(r,e,n,t);return s!==nt&&function Da(e,n,t){const r=Sd(n,e);!function F$(e,n,t){e.setValue(n,t)}(e[11],r,t)}(r,Yr(),s),Lw}function ch(e,n,t){lF(n)&&(n=n());const r=K();return Bn(r,Po(),n)&&Hs(Xe(),Zt(),r,e,n,r[11],t,!1),ch}function Um(e,n){const t=lF(e);return t&&e.set(n),t}function dh(e,n){const t=K(),r=Xe(),s=ht();return mN(r,t,t[11],s,e,n),dh}function vN(e,n,t,r,s){if(e=Ke(e),Array.isArray(e))for(let o=0;o<e.length;o++)vN(e[o],n,t,r,s);else{const o=Xe(),i=K(),a=ht();let l=ku(e)?e:Ke(e.provide);const u=XO(e),c=1048575&a.providerIndexes,d=a.directiveStart,h=a.providerIndexes>>20;if(ku(e)||!e.multi){const f=new Vp(u,s,se),p=wN(l,n,s?c:c+h,d);-1===p?(J_(Nb(a,i),o,l),bN(o,e,n.length),n.push(l),a.directiveStart++,a.directiveEnd++,s&&(a.providerIndexes+=1048576),t.push(f),i.push(f)):(t[p]=f,i[p]=f)}else{const f=wN(l,n,c+h,d),p=wN(l,n,c,c+h),g=p>=0&&t[p];if(s&&!g||!s&&!(f>=0&&t[f])){J_(Nb(a,i),o,l);const y=function hse(e,n,t,r,s){const o=new Vp(e,t,se);return o.multi=[],o.index=n,o.componentProviders=0,IB(o,s,r&&!t),o}(s?dse:cse,t.length,s,r,u);!s&&g&&(t[p].providerFactory=y),bN(o,e,n.length,0),n.push(l),a.directiveStart++,a.directiveEnd++,s&&(a.providerIndexes+=1048576),t.push(y),i.push(y)}else bN(o,e,f>-1?f:p,IB(t[s?p:f],u,!s&&r));!s&&r&&g&&t[p].componentProviders++}}}function bN(e,n,t,r){const s=ku(n),o=function qX(e){return!!e.useClass}(n);if(s||o){const l=(o?Ke(n.useClass):n).prototype.ngOnDestroy;if(l){const u=e.destroyHooks||(e.destroyHooks=[]);if(!s&&n.multi){const c=u.indexOf(t);-1===c?u.push(t,[r,l]):u[c+1].push(r,l)}else u.push(t,l)}}}function IB(e,n,t){return t&&e.componentProviders++,e.multi.push(n)-1}function wN(e,n,t,r){for(let s=t;s<r;s++)if(n[s]===e)return s;return-1}function cse(e,n,t,r){return xN(this.multi,[])}function dse(e,n,t,r){const s=this.multi;let o;if(this.providerFactory){const i=this.providerFactory.componentProviders,a=Bu(t,t[1],this.providerFactory.index,r);o=a.slice(0,i),xN(s,o);for(let l=i;l<a.length;l++)o.push(a[l])}else o=[],xN(s,o);return o}function xN(e,n){for(let t=0;t<e.length;t++)n.push((0,e[t])());return n}function Sn(e,n=[]){return t=>{t.providersResolver=(r,s)=>function use(e,n,t){const r=Xe();if(r.firstCreatePass){const s=Qo(e);vN(t,r.data,r.blueprint,s,!0),vN(n,r.data,r.blueprint,s,!1)}}(r,s?s(e):e,n)}}function CN(e,n,t){const r=Cs()+e,s=K();return s[r]===nt?Fi(s,r,t?n.call(t):n()):function Dm(e,n){return e[n]}(s,r)}function IN(e,n,t,r){return function EB(e,n,t,r,s,o){const i=n+t;return Bn(e,i,s)?Fi(e,i+1,o?r.call(o,s):r(s)):Wm(e,i+1)}(K(),Cs(),e,n,t,r)}function _B(e,n,t,r,s){return function DB(e,n,t,r,s,o,i){const a=n+t;return function ec(e,n,t,r){const s=Bn(e,n,t);return Bn(e,n+1,r)||s}(e,a,s,o)?Fi(e,a+2,i?r.call(i,s,o):r(s,o)):Wm(e,a+2)}(K(),Cs(),e,n,t,r,s)}function Wm(e,n){const t=e[n];return t===nt?void 0:t}class soe{ngModuleFactory;componentFactories;constructor(n,t){this.ngModuleFactory=n,this.componentFactories=t}}let GB=(()=>{class e{compileModuleSync(t){return new UD(t)}compileModuleAsync(t){return Promise.resolve(this.compileModuleSync(t))}compileModuleAndAllComponentsSync(t){const r=this.compileModuleSync(t),o=co(rs(t).declarations).reduce((i,a)=>{const l=dt(a);return l&&i.push(new _m(l)),i},[]);return new soe(r,o)}compileModuleAndAllComponentsAsync(t){return Promise.resolve(this.compileModuleAndAllComponentsSync(t))}clearCache(){}clearCacheFor(t){}getModuleId(t){}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),aoe=(()=>{class e{zone=Z(Vt);changeDetectionScheduler=Z(Ia);applicationRef=Z(ho);_onMicrotaskEmptySubscription;initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.changeDetectionScheduler.runningTick||this.zone.run(()=>{this.applicationRef.tick()})}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function NN({ngZoneFactory:e,ignoreChangesOutsideZone:n,scheduleInRootZone:t}){return e??=()=>new Vt({...TN(),scheduleInRootZone:t}),[{provide:Vt,useFactory:e},{provide:Mo,multi:!0,useFactory:()=>{const r=Z(aoe,{optional:!0});return()=>r.initialize()}},{provide:Mo,multi:!0,useFactory:()=>{const r=Z(uoe);return()=>{r.initialize()}}},!0===n?{provide:Z2,useValue:!0}:[],{provide:nE,useValue:t??X2}]}function TN(e){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:e?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:e?.runCoalescing??!1}}let uoe=(()=>{class e{subscription=new bs;initialized=!1;zone=Z(Vt);pendingTasks=Z(ti);initialize(){if(this.initialized)return;this.initialized=!0;let t=null;!this.zone.isStable&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(t=this.pendingTasks.add()),this.zone.runOutsideAngular(()=>{this.subscription.add(this.zone.onStable.subscribe(()=>{Vt.assertNotInAngularZone(),queueMicrotask(()=>{null!==t&&!this.zone.hasPendingMacrotasks&&!this.zone.hasPendingMicrotasks&&(this.pendingTasks.remove(t),t=null)})}))}),this.subscription.add(this.zone.onUnstable.subscribe(()=>{Vt.assertInAngularZone(),t??=this.pendingTasks.add()}))}ngOnDestroy(){this.subscription.unsubscribe()}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),qm=(()=>{class e{appRef=Z(ho);taskService=Z(ti);ngZone=Z(Vt);zonelessEnabled=Z(Wp);tracing=Z(kd,{optional:!0});disableScheduling=Z(Z2,{optional:!0})??!1;zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run;schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}];subscriptions=new bs;angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(Rb):null;scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(Z(nE,{optional:!0})??!1);cancelScheduledCallback=null;useMicrotaskScheduler=!1;runningTick=!1;pendingRenderTaskId=null;constructor(){this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{this.runningTick||this.cleanup()})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()})),this.disableScheduling||=!this.zonelessEnabled&&(this.ngZone instanceof iE||!this.zoneIsDefined)}notify(t){if(!this.zonelessEnabled&&5===t)return;let r=!1;switch(t){case 0:this.appRef.dirtyFlags|=2;break;case 3:case 2:case 4:case 5:case 1:this.appRef.dirtyFlags|=4;break;case 8:this.appRef.deferredDirtyFlags|=8;break;case 6:case 14:this.appRef.dirtyFlags|=2,r=!0;break;case 13:this.appRef.dirtyFlags|=16,r=!0;break;case 12:r=!0;break;default:this.appRef.dirtyFlags|=8}if(this.appRef.tracingSnapshot=this.tracing?.snapshot(this.appRef.tracingSnapshot)??null,!this.shouldScheduleTick(r))return;const s=this.useMicrotaskScheduler?J2:Q2;this.pendingRenderTaskId=this.taskService.add(),this.cancelScheduledCallback=this.scheduleInRootZone?Zone.root.run(()=>s(()=>this.tick())):this.ngZone.runOutsideAngular(()=>s(()=>this.tick()))}shouldScheduleTick(t){return!(this.disableScheduling&&!t||this.appRef.destroyed||null!==this.pendingRenderTaskId||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(Rb+this.angularZoneId))}tick(){if(this.runningTick||this.appRef.destroyed)return;if(0===this.appRef.dirtyFlags)return void this.cleanup();!this.zonelessEnabled&&7&this.appRef.dirtyFlags&&(this.appRef.dirtyFlags|=1);const t=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(r){throw this.taskService.remove(t),r}finally{this.cleanup()}this.useMicrotaskScheduler=!0,J2(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(t)})}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,null!==this.pendingRenderTaskId){const t=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(t)}}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const Dl=new fe("",{providedIn:"root",factory:()=>Z(Dl,xt.Optional|xt.SkipSelf)||function coe(){return typeof $localize<"u"&&$localize.locale||Mw}()}),Uw=new fe(""),goe=new fe("");function Km(e){return!e.moduleRef}let Nl=null;let Xm=(()=>class e{static __NG_ELEMENT_ID__=xoe})();function xoe(e){return function Coe(e,n,t){if(cl(e)&&!t){const r=oo(e.index,n);return new mm(r,r)}return 175&e.type?new mm(n[15],n):null}(ht(),K(),!(16&~e))}class i3{constructor(){}supports(n){return xw(n)}create(n){return new Doe(n)}}const Eoe=(e,n)=>n;class Doe{length=0;collection;_linkedRecords=null;_unlinkedRecords=null;_previousItHead=null;_itHead=null;_itTail=null;_additionsHead=null;_additionsTail=null;_movesHead=null;_movesTail=null;_removalsHead=null;_removalsTail=null;_identityChangesHead=null;_identityChangesTail=null;_trackByFn;constructor(n){this._trackByFn=n||Eoe}forEachItem(n){let t;for(t=this._itHead;null!==t;t=t._next)n(t)}forEachOperation(n){let t=this._itHead,r=this._removalsHead,s=0,o=null;for(;t||r;){const i=!r||t&&t.currentIndex<l3(r,s,o)?t:r,a=l3(i,s,o),l=i.currentIndex;if(i===r)s--,r=r._nextRemoved;else if(t=t._next,null==i.previousIndex)s++;else{o||(o=[]);const u=a-s,c=l-s;if(u!=c){for(let h=0;h<u;h++){const f=h<o.length?o[h]:o[h]=0,p=f+h;c<=p&&p<u&&(o[h]=f+1)}o[i.previousIndex]=c-u}}a!==l&&n(i,a,l)}}forEachPreviousItem(n){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)n(t)}forEachAddedItem(n){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)n(t)}forEachMovedItem(n){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)n(t)}forEachRemovedItem(n){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)n(t)}forEachIdentityChange(n){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)n(t)}diff(n){if(null==n&&(n=[]),!xw(n))throw new te(900,!1);return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let s,o,i,t=this._itHead,r=!1;if(Array.isArray(n)){this.length=n.length;for(let a=0;a<this.length;a++)o=n[a],i=this._trackByFn(a,o),null!==t&&Object.is(t.trackById,i)?(r&&(t=this._verifyReinsertion(t,o,i,a)),Object.is(t.item,o)||this._addIdentityChange(t,o)):(t=this._mismatch(t,o,i,a),r=!0),t=t._next}else s=0,function gee(e,n){if(Array.isArray(e))for(let t=0;t<e.length;t++)n(e[t]);else{const t=e[Symbol.iterator]();let r;for(;!(r=t.next()).done;)n(r.value)}}(n,a=>{i=this._trackByFn(s,a),null!==t&&Object.is(t.trackById,i)?(r&&(t=this._verifyReinsertion(t,a,i,s)),Object.is(t.item,a)||this._addIdentityChange(t,a)):(t=this._mismatch(t,a,i,s),r=!0),t=t._next,s++}),this.length=s;return this._truncate(t),this.collection=n,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let n;for(n=this._previousItHead=this._itHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._additionsHead;null!==n;n=n._nextAdded)n.previousIndex=n.currentIndex;for(this._additionsHead=this._additionsTail=null,n=this._movesHead;null!==n;n=n._nextMoved)n.previousIndex=n.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(n,t,r,s){let o;return null===n?o=this._itTail:(o=n._prev,this._remove(n)),null!==(n=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(n.item,t)||this._addIdentityChange(n,t),this._reinsertAfter(n,o,s)):null!==(n=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(n.item,t)||this._addIdentityChange(n,t),this._moveAfter(n,o,s)):n=this._addAfter(new Noe(t,r),o,s),n}_verifyReinsertion(n,t,r,s){let o=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==o?n=this._reinsertAfter(o,n._prev,s):n.currentIndex!=s&&(n.currentIndex=s,this._addToMoves(n,s)),n}_truncate(n){for(;null!==n;){const t=n._next;this._addToRemovals(this._unlink(n)),n=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(n,t,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(n);const s=n._prevRemoved,o=n._nextRemoved;return null===s?this._removalsHead=o:s._nextRemoved=o,null===o?this._removalsTail=s:o._prevRemoved=s,this._insertAfter(n,t,r),this._addToMoves(n,r),n}_moveAfter(n,t,r){return this._unlink(n),this._insertAfter(n,t,r),this._addToMoves(n,r),n}_addAfter(n,t,r){return this._insertAfter(n,t,r),this._additionsTail=null===this._additionsTail?this._additionsHead=n:this._additionsTail._nextAdded=n,n}_insertAfter(n,t,r){const s=null===t?this._itHead:t._next;return n._next=s,n._prev=t,null===s?this._itTail=n:s._prev=n,null===t?this._itHead=n:t._next=n,null===this._linkedRecords&&(this._linkedRecords=new a3),this._linkedRecords.put(n),n.currentIndex=r,n}_remove(n){return this._addToRemovals(this._unlink(n))}_unlink(n){null!==this._linkedRecords&&this._linkedRecords.remove(n);const t=n._prev,r=n._next;return null===t?this._itHead=r:t._next=r,null===r?this._itTail=t:r._prev=t,n}_addToMoves(n,t){return n.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=n:this._movesTail._nextMoved=n),n}_addToRemovals(n){return null===this._unlinkedRecords&&(this._unlinkedRecords=new a3),this._unlinkedRecords.put(n),n.currentIndex=null,n._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=n,n._prevRemoved=null):(n._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=n),n}_addIdentityChange(n,t){return n.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=n:this._identityChangesTail._nextIdentityChange=n,n}}class Noe{item;trackById;currentIndex=null;previousIndex=null;_nextPrevious=null;_prev=null;_next=null;_prevDup=null;_nextDup=null;_prevRemoved=null;_nextRemoved=null;_nextAdded=null;_nextMoved=null;_nextIdentityChange=null;constructor(n,t){this.item=n,this.trackById=t}}class Toe{_head=null;_tail=null;add(n){null===this._head?(this._head=this._tail=n,n._nextDup=null,n._prevDup=null):(this._tail._nextDup=n,n._prevDup=this._tail,n._nextDup=null,this._tail=n)}get(n,t){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===t||t<=r.currentIndex)&&Object.is(r.trackById,n))return r;return null}remove(n){const t=n._prevDup,r=n._nextDup;return null===t?this._head=r:t._nextDup=r,null===r?this._tail=t:r._prevDup=t,null===this._head}}class a3{map=new Map;put(n){const t=n.trackById;let r=this.map.get(t);r||(r=new Toe,this.map.set(t,r)),r.add(n)}get(n,t){const s=this.map.get(n);return s?s.get(n,t):null}remove(n){const t=n.trackById;return this.map.get(t).remove(n)&&this.map.delete(t),n}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function l3(e,n,t){const r=e.previousIndex;if(null===r)return r;let s=0;return t&&r<t.length&&(s=t[r]),r+n+s}class u3{constructor(){}supports(n){return n instanceof Map||HD(n)}create(){return new koe}}class koe{_records=new Map;_mapHead=null;_appendAfter=null;_previousMapHead=null;_changesHead=null;_changesTail=null;_additionsHead=null;_additionsTail=null;_removalsHead=null;_removalsTail=null;get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(n){let t;for(t=this._mapHead;null!==t;t=t._next)n(t)}forEachPreviousItem(n){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)n(t)}forEachChangedItem(n){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)n(t)}forEachAddedItem(n){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)n(t)}forEachRemovedItem(n){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)n(t)}diff(n){if(n){if(!(n instanceof Map||HD(n)))throw new te(900,!1)}else n=new Map;return this.check(n)?this:null}onDestroy(){}check(n){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(n,(r,s)=>{if(t&&t.key===s)this._maybeAddToChanges(t,r),this._appendAfter=t,t=t._next;else{const o=this._getOrCreateRecordForKey(s,r);t=this._insertBeforeOrAppend(t,o)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let r=t;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(n,t){if(n){const r=n._prev;return t._next=n,t._prev=r,n._prev=t,r&&(r._next=t),n===this._mapHead&&(this._mapHead=t),this._appendAfter=n,n}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(n,t){if(this._records.has(n)){const s=this._records.get(n);this._maybeAddToChanges(s,t);const o=s._prev,i=s._next;return o&&(o._next=i),i&&(i._prev=o),s._next=null,s._prev=null,s}const r=new Aoe(n);return this._records.set(n,r),r.currentValue=t,this._addToAdditions(r),r}_reset(){if(this.isDirty){let n;for(this._previousMapHead=this._mapHead,n=this._previousMapHead;null!==n;n=n._next)n._nextPrevious=n._next;for(n=this._changesHead;null!==n;n=n._nextChanged)n.previousValue=n.currentValue;for(n=this._additionsHead;null!=n;n=n._nextAdded)n.previousValue=n.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(n,t){Object.is(t,n.currentValue)||(n.previousValue=n.currentValue,n.currentValue=t,this._addToChanges(n))}_addToAdditions(n){null===this._additionsHead?this._additionsHead=this._additionsTail=n:(this._additionsTail._nextAdded=n,this._additionsTail=n)}_addToChanges(n){null===this._changesHead?this._changesHead=this._changesTail=n:(this._changesTail._nextChanged=n,this._changesTail=n)}_forEach(n,t){n instanceof Map?n.forEach(t):Object.keys(n).forEach(r=>t(n[r],r))}}class Aoe{key;previousValue=null;currentValue=null;_nextPrevious=null;_next=null;_prev=null;_nextAdded=null;_nextRemoved=null;_nextChanged=null;constructor(n){this.key=n}}function c3(){return new $N([new i3])}let $N=(()=>{class e{factories;static \u0275prov=_e({token:e,providedIn:"root",factory:c3});constructor(t){this.factories=t}static create(t,r){if(null!=r){const s=r.factories.slice();t=t.concat(s)}return new e(t)}static extend(t){return{provide:e,useFactory:r=>e.create(t,r||c3()),deps:[[e,new y_,new g_]]}}find(t){const r=this.factories.find(s=>s.supports(t));if(null!=r)return r;throw new te(901,!1)}}return e})();function d3(){return new jw([new u3])}let jw=(()=>{class e{static \u0275prov=_e({token:e,providedIn:"root",factory:d3});factories;constructor(t){this.factories=t}static create(t,r){if(r){const s=r.factories.slice();t=t.concat(s)}return new e(t)}static extend(t){return{provide:e,useFactory:r=>e.create(t,r||d3()),deps:[[e,new y_,new g_]]}}find(t){const r=this.factories.find(s=>s.supports(t));if(r)return r;throw new te(901,!1)}}return e})();function joe(e){try{const{rootComponent:n,appProviders:t,platformProviders:r}=e,s=function woe(e=[]){if(Nl)return Nl;const n=function e3(e=[],n){return Vn.create({name:n,providers:[{provide:S_,useValue:"platform"},{provide:Uw,useValue:new Set([()=>Nl=null])},...e]})}(e);return Nl=n,function LL(){!function nX(e){bO=e}(()=>{throw new te(600,!1)})}(),function t3(e){const n=e.get(hE,null);Oo(e,()=>{n?.forEach(t=>t())})}(n),n}(r),o=[NN({}),{provide:Ia,useExisting:qm},...t||[]];return function ZB(e){const n=Km(e)?e.r3Injector:e.moduleRef.injector,t=n.get(Vt);return t.run(()=>{Km(e)?e.r3Injector.resolveInjectorInitializers():e.moduleRef.resolveInjectorInitializers();const r=n.get(Ri,null);let s;if(t.runOutsideAngular(()=>{s=t.onError.subscribe({next:o=>{r.handleError(o)}})}),Km(e)){const o=()=>n.destroy(),i=e.platformInjector.get(Uw);i.add(o),n.onDestroy(()=>{s.unsubscribe(),i.delete(o)})}else{const o=()=>e.moduleRef.destroy(),i=e.platformInjector.get(Uw);i.add(o),e.moduleRef.onDestroy(()=>{Nw(e.allPlatformModules,e.moduleRef),s.unsubscribe(),i.delete(o)})}return function wte(e,n,t){try{const r=t();return Am(r)?r.catch(s=>{throw n.runOutsideAngular(()=>e.handleError(s)),s}):r}catch(r){throw n.runOutsideAngular(()=>e.handleError(r)),r}}(r,t,()=>{const o=n.get($L);return o.runInitializers(),o.donePromise.then(()=>{if(function nre(e){"string"==typeof e&&(SV=e.toLowerCase().replace(/_/g,"-"))}(n.get(Dl,Mw)||Mw),!n.get(goe,!0))return Km(e)?n.get(ho):(e.allPlatformModules.push(e.moduleRef),e.moduleRef);if(Km(e)){const l=n.get(ho);return void 0!==e.rootComponent&&l.bootstrap(e.rootComponent),l}return function yoe(e,n){const t=e.injector.get(ho);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(r=>t.bootstrap(r));else{if(!e.instance.ngDoBootstrap)throw new te(-403,!1);e.instance.ngDoBootstrap(t)}n.push(e)}(e.moduleRef,e.allPlatformModules),e.moduleRef})})})}({r3Injector:new uL({providers:o,parent:s,debugName:"",runEnvironmentInitializers:!1}).injector,platformInjector:s,rootComponent:n})}catch(n){return Promise.reject(n)}}function ph(e){return"boolean"==typeof e?e:null!=e&&"false"!==e}function Vi(e,n){Fr("NgSignals");const t=function JK(e){const n=Object.create(eX);n.computation=e;const t=()=>{if(sl(n),Iu(n),n.value===Np)throw n.error;return n.value};return t[gr]=n,t}(e);return n?.equal&&(t[gr].equal=n.equal),t}function Qr(e){const n=st(null);try{return e()}finally{st(n)}}let U3=null;function Tl(){return U3}class Bie{}const fo=new fe("");let UN=(()=>{class e{historyGo(t){throw new Error("")}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>Z(Uie),providedIn:"platform"})}return e})();const zie=new fe("");let Uie=(()=>{class e extends UN{_location;_history;_doc=Z(fo);constructor(){super(),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Tl().getBaseHref(this._doc)}onPopState(t){const r=Tl().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",t,!1),()=>r.removeEventListener("popstate",t)}onHashChange(t){const r=Tl().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",t,!1),()=>r.removeEventListener("hashchange",t)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(t){this._location.pathname=t}pushState(t,r,s){this._history.pushState(t,r,s)}replaceState(t,r,s){this._history.replaceState(t,r,s)}forward(){this._history.forward()}back(){this._history.back()}historyGo(t=0){this._history.go(t)}getState(){return this._history.state}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>new e,providedIn:"platform"})}return e})();function WN(e,n){if(0==e.length)return n;if(0==n.length)return e;let t=0;return e.endsWith("/")&&t++,n.startsWith("/")&&t++,2==t?e+n.substring(1):1==t?e+n:e+"/"+n}function W3(e){const n=e.match(/#|\?|$/),t=n&&n.index||e.length;return e.slice(0,t-("/"===e[t-1]?1:0))+e.slice(t)}function Na(e){return e&&"?"!==e[0]?"?"+e:e}let ac=(()=>{class e{historyGo(t){throw new Error("")}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>Z(H3),providedIn:"root"})}return e})();const HN=new fe("");let H3=(()=>{class e extends ac{_platformLocation;_baseHref;_removeListenerFns=[];constructor(t,r){super(),this._platformLocation=t,this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Z(fo).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(t){this._removeListenerFns.push(this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t))}getBaseHref(){return this._baseHref}prepareExternalUrl(t){return WN(this._baseHref,t)}path(t=!1){const r=this._platformLocation.pathname+Na(this._platformLocation.search),s=this._platformLocation.hash;return s&&t?`${r}${s}`:r}pushState(t,r,s,o){const i=this.prepareExternalUrl(s+Na(o));this._platformLocation.pushState(t,r,i)}replaceState(t,r,s,o){const i=this.prepareExternalUrl(s+Na(o));this._platformLocation.replaceState(t,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(t=0){this._platformLocation.historyGo?.(t)}static \u0275fac=function(r){return new(r||e)($e(UN),$e(HN,8))};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),Wie=(()=>{class e extends ac{_platformLocation;_baseHref="";_removeListenerFns=[];constructor(t,r){super(),this._platformLocation=t,null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(t){this._removeListenerFns.push(this._platformLocation.onPopState(t),this._platformLocation.onHashChange(t))}getBaseHref(){return this._baseHref}path(t=!1){const r=this._platformLocation.hash??"#";return r.length>0?r.substring(1):r}prepareExternalUrl(t){const r=WN(this._baseHref,t);return r.length>0?"#"+r:r}pushState(t,r,s,o){let i=this.prepareExternalUrl(s+Na(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.pushState(t,r,i)}replaceState(t,r,s,o){let i=this.prepareExternalUrl(s+Na(o));0==i.length&&(i=this._platformLocation.pathname),this._platformLocation.replaceState(t,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(t=0){this._platformLocation.historyGo?.(t)}static \u0275fac=function(r){return new(r||e)($e(UN),$e(HN,8))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})(),tg=(()=>{class e{_subject=new Ls;_basePath;_locationStrategy;_urlChangeListeners=[];_urlChangeSubscription=null;constructor(t){this._locationStrategy=t;const r=this._locationStrategy.getBaseHref();this._basePath=function Gie(e){if(new RegExp("^(https?:)?//").test(e)){const[,t]=e.split(/\/\/[^\/]+/);return t}return e}(W3(j3(r))),this._locationStrategy.onPopState(s=>{this._subject.next({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(t=!1){return this.normalize(this._locationStrategy.path(t))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(t,r=""){return this.path()==this.normalize(t+Na(r))}normalize(t){return e.stripTrailingSlash(function jie(e,n){if(!e||!n.startsWith(e))return n;const t=n.substring(e.length);return""===t||["/",";","?","#"].includes(t[0])?t:n}(this._basePath,j3(t)))}prepareExternalUrl(t){return t&&"/"!==t[0]&&(t="/"+t),this._locationStrategy.prepareExternalUrl(t)}go(t,r="",s=null){this._locationStrategy.pushState(s,"",t,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Na(r)),s)}replaceState(t,r="",s=null){this._locationStrategy.replaceState(s,"",t,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(t+Na(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(t=0){this._locationStrategy.historyGo?.(t)}onUrlChange(t){return this._urlChangeListeners.push(t),this._urlChangeSubscription??=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)}),()=>{const r=this._urlChangeListeners.indexOf(t);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(t="",r){this._urlChangeListeners.forEach(s=>s(t,r))}subscribe(t,r,s){return this._subject.subscribe({next:t,error:r??void 0,complete:s??void 0})}static normalizeQueryParams=Na;static joinWithSlash=WN;static stripTrailingSlash=W3;static \u0275fac=function(r){return new(r||e)($e(ac))};static \u0275prov=_e({token:e,factory:()=>function Hie(){return new tg($e(ac))}(),providedIn:"root"})}return e})();function j3(e){return e.replace(/\/index.html$/,"")}function ez(e,n){n=encodeURIComponent(n);for(const t of e.split(";")){const r=t.indexOf("="),[s,o]=-1==r?[t,""]:[t.slice(0,r),t.slice(r+1)];if(s.trim()===n)return decodeURIComponent(o)}return null}class Rae{$implicit;ngForOf;index;count;constructor(n,t,r,s){this.$implicit=n,this.ngForOf=t,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let tT=(()=>{class e{_viewContainer;_template;_differs;set ngForOf(t){this._ngForOf=t,this._ngForOfDirty=!0}set ngForTrackBy(t){this._trackByFn=t}get ngForTrackBy(){return this._trackByFn}_ngForOf=null;_ngForOfDirty=!0;_differ=null;_trackByFn;constructor(t,r,s){this._viewContainer=t,this._template=r,this._differs=s}set ngForTemplate(t){t&&(this._template=t)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const t=this._ngForOf;!this._differ&&t&&(this._differ=this._differs.find(t).create(this.ngForTrackBy))}if(this._differ){const t=this._differ.diff(this._ngForOf);t&&this._applyChanges(t)}}_applyChanges(t){const r=this._viewContainer;t.forEachOperation((s,o,i)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new Rae(s.item,this._ngForOf,-1,-1),null===i?void 0:i);else if(null==i)r.remove(null===o?void 0:o);else if(null!==o){const a=r.get(o);r.move(a,i),rz(a,s)}});for(let s=0,o=r.length;s<o;s++){const a=r.get(s).context;a.index=s,a.count=o,a.ngForOf=this._ngForOf}t.forEachIdentityChange(s=>{rz(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(t,r){return!0}static \u0275fac=function(r){return new(r||e)(se(ri),se(_a),se($N))};static \u0275dir=Je({type:e,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"}})}return e})();function rz(e,n){e.context.$implicit=n.item}let sz=(()=>{class e{_viewContainer;_context=new Mae;_thenTemplateRef=null;_elseTemplateRef=null;_thenViewRef=null;_elseViewRef=null;constructor(t,r){this._viewContainer=t,this._thenTemplateRef=r}set ngIf(t){this._context.$implicit=this._context.ngIf=t,this._updateView()}set ngIfThen(t){oz("ngIfThen",t),this._thenTemplateRef=t,this._thenViewRef=null,this._updateView()}set ngIfElse(t){oz("ngIfElse",t),this._elseTemplateRef=t,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngIfUseIfTypeGuard;static ngTemplateGuard_ngIf;static ngTemplateContextGuard(t,r){return!0}static \u0275fac=function(r){return new(r||e)(se(ri),se(_a))};static \u0275dir=Je({type:e,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}})}return e})();class Mae{$implicit=null;ngIf=null}function oz(e,n){if(n&&!n.createEmbeddedView)throw new Error(`${e} must be a TemplateRef, but received '${vr(n)}'.`)}let az=(()=>{class e{_ngEl;_differs;_renderer;_ngStyle=null;_differ=null;constructor(t,r,s){this._ngEl=t,this._differs=r,this._renderer=s}set ngStyle(t){this._ngStyle=t,!this._differ&&t&&(this._differ=this._differs.find(t).create())}ngDoCheck(){if(this._differ){const t=this._differ.diff(this._ngStyle);t&&this._applyChanges(t)}}_setStyle(t,r){const[s,o]=t.split("."),i=-1===s.indexOf("-")?void 0:bl.DashCase;null!=r?this._renderer.setStyle(this._ngEl.nativeElement,s,o?`${r}${o}`:r,i):this._renderer.removeStyle(this._ngEl.nativeElement,s,i)}_applyChanges(t){t.forEachRemovedItem(r=>this._setStyle(r.key,null)),t.forEachAddedItem(r=>this._setStyle(r.key,r.currentValue)),t.forEachChangedItem(r=>this._setStyle(r.key,r.currentValue))}static \u0275fac=function(r){return new(r||e)(se(uo),se(jw),se(Ea))};static \u0275dir=Je({type:e,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"}})}return e})(),iT=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275mod=Ju({type:e});static \u0275inj=il({})}return e})();function cz(e){return"server"===e}let ile=(()=>{class e{static \u0275prov=_e({token:e,providedIn:"root",factory:()=>new ale(Z(fo),window)})}return e})();class ale{document;window;offset=()=>[0,0];constructor(n,t){this.document=n,this.window=t}setOffset(n){this.offset=Array.isArray(n)?()=>n:n}getScrollPosition(){return[this.window.scrollX,this.window.scrollY]}scrollToPosition(n){this.window.scrollTo(n[0],n[1])}scrollToAnchor(n){const t=function lle(e,n){const t=e.getElementById(n)||e.getElementsByName(n)[0];if(t)return t;if("function"==typeof e.createTreeWalker&&e.body&&"function"==typeof e.body.attachShadow){const r=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const o=s.shadowRoot;if(o){const i=o.getElementById(n)||o.querySelector(`[name="${n}"]`);if(i)return i}s=r.nextNode()}}return null}(this.document,n);t&&(this.scrollToElement(t),t.focus())}setHistoryScrollRestoration(n){this.window.history.scrollRestoration=n}scrollToElement(n){const t=n.getBoundingClientRect(),r=t.left+this.window.pageXOffset,s=t.top+this.window.pageYOffset,o=this.offset();this.window.scrollTo(r-o[0],s-o[1])}}class dz{}class $le extends Bie{supportsDOMEvents=!0}class cT extends $le{static makeCurrent(){!function Vie(e){U3??=e}(new cT)}onAndCancel(n,t,r,s){return n.addEventListener(t,r,s),()=>{n.removeEventListener(t,r,s)}}dispatchEvent(n,t){n.dispatchEvent(t)}remove(n){n.remove()}createElement(n,t){return(t=t||this.getDefaultDocument()).createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,t){return"window"===t?window:"document"===t?n:"body"===t?n.body:null}getBaseHref(n){const t=function Ple(){return og=og||document.querySelector("base"),og?og.getAttribute("href"):null}();return null==t?null:function Lle(e){return new URL(e,document.baseURI).pathname}(t)}resetBaseElement(){og=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return ez(document.cookie,n)}}let og=null,Ble=(()=>{class e{build(){return new XMLHttpRequest}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();const dT=new fe("");let Cz=(()=>{class e{_zone;_plugins;_eventNameToPlugin=new Map;constructor(t,r){this._zone=r,t.forEach(s=>{s.manager=this}),this._plugins=t.slice().reverse()}addEventListener(t,r,s,o){return this._findPluginFor(r).addEventListener(t,r,s,o)}getZone(){return this._zone}_findPluginFor(t){let r=this._eventNameToPlugin.get(t);if(r)return r;if(r=this._plugins.find(o=>o.supports(t)),!r)throw new te(5101,!1);return this._eventNameToPlugin.set(t,r),r}static \u0275fac=function(r){return new(r||e)($e(dT),$e(Vt))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();class Iz{_doc;constructor(n){this._doc=n}manager}const yx="ng-app-id";function Sz(e){for(const n of e)n.remove()}function _z(e,n){const t=n.createElement("style");return t.textContent=e,t}function hT(e,n){const t=n.createElement("link");return t.setAttribute("rel","stylesheet"),t.setAttribute("href",e),t}let Ez=(()=>{class e{doc;appId;nonce;inline=new Map;external=new Map;hosts=new Set;isServer;constructor(t,r,s,o={}){this.doc=t,this.appId=r,this.nonce=s,this.isServer=cz(o),function zle(e,n,t,r){const s=e.head?.querySelectorAll(`style[${yx}="${n}"],link[${yx}="${n}"]`);if(s)for(const o of s)o.removeAttribute(yx),o instanceof HTMLLinkElement?r.set(o.href.slice(o.href.lastIndexOf("/")+1),{usage:0,elements:[o]}):o.textContent&&t.set(o.textContent,{usage:0,elements:[o]})}(t,r,this.inline,this.external),this.hosts.add(t.head)}addStyles(t,r){for(const s of t)this.addUsage(s,this.inline,_z);r?.forEach(s=>this.addUsage(s,this.external,hT))}removeStyles(t,r){for(const s of t)this.removeUsage(s,this.inline);r?.forEach(s=>this.removeUsage(s,this.external))}addUsage(t,r,s){const o=r.get(t);o?o.usage++:r.set(t,{usage:1,elements:[...this.hosts].map(i=>this.addElement(i,s(t,this.doc)))})}removeUsage(t,r){const s=r.get(t);s&&(s.usage--,s.usage<=0&&(Sz(s.elements),r.delete(t)))}ngOnDestroy(){for(const[,{elements:t}]of[...this.inline,...this.external])Sz(t);this.hosts.clear()}addHost(t){this.hosts.add(t);for(const[r,{elements:s}]of this.inline)s.push(this.addElement(t,_z(r,this.doc)));for(const[r,{elements:s}]of this.external)s.push(this.addElement(t,hT(r,this.doc)))}removeHost(t){this.hosts.delete(t)}addElement(t,r){return this.nonce&&r.setAttribute("nonce",this.nonce),this.isServer&&r.setAttribute(yx,this.appId),t.appendChild(r)}static \u0275fac=function(r){return new(r||e)($e(fo),$e(Wu),$e(DF,8),$e(Hu))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();const fT={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},pT=/%COMP%/g,jle=new fe("",{providedIn:"root",factory:()=>!0});function Nz(e,n){return n.map(t=>t.replace(pT,e))}let Tz=(()=>{class e{eventManager;sharedStylesHost;appId;removeStylesOnCompDestroy;doc;platformId;ngZone;nonce;tracingService;rendererByCompId=new Map;defaultRenderer;platformIsServer;constructor(t,r,s,o,i,a,l,u=null,c=null){this.eventManager=t,this.sharedStylesHost=r,this.appId=s,this.removeStylesOnCompDestroy=o,this.doc=i,this.platformId=a,this.ngZone=l,this.nonce=u,this.tracingService=c,this.platformIsServer=cz(a),this.defaultRenderer=new mT(t,i,l,this.platformIsServer,this.tracingService)}createRenderer(t,r){if(!t||!r)return this.defaultRenderer;this.platformIsServer&&r.encapsulation===Lo.ShadowDom&&(r={...r,encapsulation:Lo.Emulated});const s=this.getOrCreateRenderer(t,r);return s instanceof Az?s.applyToHost(t):s instanceof gT&&s.applyStyles(),s}getOrCreateRenderer(t,r){const s=this.rendererByCompId;let o=s.get(r.id);if(!o){const i=this.doc,a=this.ngZone,l=this.eventManager,u=this.sharedStylesHost,c=this.removeStylesOnCompDestroy,d=this.platformIsServer;switch(r.encapsulation){case Lo.Emulated:o=new Az(l,u,r,this.appId,c,i,a,d,this.tracingService);break;case Lo.ShadowDom:return new Xle(l,u,t,r,i,a,this.nonce,d,this.tracingService);default:o=new gT(l,u,r,c,i,a,d,this.tracingService)}s.set(r.id,o)}return o}ngOnDestroy(){this.rendererByCompId.clear()}componentReplaced(t){this.rendererByCompId.delete(t)}static \u0275fac=function(r){return new(r||e)($e(Cz),$e(Ez),$e(Wu),$e(jle),$e(fo),$e(Hu),$e(Vt),$e(DF),$e(kd,8))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();class mT{eventManager;doc;ngZone;platformIsServer;tracingService;data=Object.create(null);throwOnSyntheticProps=!0;constructor(n,t,r,s,o){this.eventManager=n,this.doc=t,this.ngZone=r,this.platformIsServer=s,this.tracingService=o}destroy(){}destroyNode=null;createElement(n,t){return t?this.doc.createElementNS(fT[t]||t,n):this.doc.createElement(n)}createComment(n){return this.doc.createComment(n)}createText(n){return this.doc.createTextNode(n)}appendChild(n,t){(kz(n)?n.content:n).appendChild(t)}insertBefore(n,t,r){n&&(kz(n)?n.content:n).insertBefore(t,r)}removeChild(n,t){t.remove()}selectRootElement(n,t){let r="string"==typeof n?this.doc.querySelector(n):n;if(!r)throw new te(-5104,!1);return t||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,t,r,s){if(s){t=s+":"+t;const o=fT[s];o?n.setAttributeNS(o,t,r):n.setAttribute(t,r)}else n.setAttribute(t,r)}removeAttribute(n,t,r){if(r){const s=fT[r];s?n.removeAttributeNS(s,t):n.removeAttribute(`${r}:${t}`)}else n.removeAttribute(t)}addClass(n,t){n.classList.add(t)}removeClass(n,t){n.classList.remove(t)}setStyle(n,t,r,s){s&(bl.DashCase|bl.Important)?n.style.setProperty(t,r,s&bl.Important?"important":""):n.style[t]=r}removeStyle(n,t,r){r&bl.DashCase?n.style.removeProperty(t):n.style[t]=""}setProperty(n,t,r){null!=n&&(n[t]=r)}setValue(n,t){n.nodeValue=t}listen(n,t,r,s){if("string"==typeof n&&!(n=Tl().getGlobalEventTarget(this.doc,n)))throw new Error(`Unsupported event target ${n} for event ${t}`);let o=this.decoratePreventDefault(r);return null!==this.tracingService&&this.tracingService.wrapEventListener&&(o=this.tracingService.wrapEventListener(n,t,o)),this.eventManager.addEventListener(n,t,o,s)}decoratePreventDefault(n){return t=>{if("__ngUnwrap__"===t)return n;!1===(this.platformIsServer?this.ngZone.runGuarded(()=>n(t)):n(t))&&t.preventDefault()}}}function kz(e){return"TEMPLATE"===e.tagName&&void 0!==e.content}class Xle extends mT{sharedStylesHost;hostEl;shadowRoot;constructor(n,t,r,s,o,i,a,l,u){super(n,o,i,l,u),this.sharedStylesHost=t,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const c=Nz(s.id,s.styles);for(const h of c){const f=document.createElement("style");a&&f.setAttribute("nonce",a),f.textContent=h,this.shadowRoot.appendChild(f)}const d=s.getExternalStyles?.();if(d)for(const h of d){const f=hT(h,o);a&&f.setAttribute("nonce",a),this.shadowRoot.appendChild(f)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,t){return super.appendChild(this.nodeOrShadowRoot(n),t)}insertBefore(n,t,r){return super.insertBefore(this.nodeOrShadowRoot(n),t,r)}removeChild(n,t){return super.removeChild(null,t)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}}class gT extends mT{sharedStylesHost;removeStylesOnCompDestroy;styles;styleUrls;constructor(n,t,r,s,o,i,a,l,u){super(n,o,i,a,l),this.sharedStylesHost=t,this.removeStylesOnCompDestroy=s,this.styles=u?Nz(u,r.styles):r.styles,this.styleUrls=r.getExternalStyles?.(u)}applyStyles(){this.sharedStylesHost.addStyles(this.styles,this.styleUrls)}destroy(){this.removeStylesOnCompDestroy&&this.sharedStylesHost.removeStyles(this.styles,this.styleUrls)}}class Az extends gT{contentAttr;hostAttr;constructor(n,t,r,s,o,i,a,l,u){const c=s+"-"+r.id;super(n,t,r,o,i,a,l,u,c),this.contentAttr=function Gle(e){return"_ngcontent-%COMP%".replace(pT,e)}(c),this.hostAttr=function qle(e){return"_nghost-%COMP%".replace(pT,e)}(c)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,t){const r=super.createElement(n,t);return super.setAttribute(r,this.contentAttr,""),r}}const Rz=["alt","control","meta","shift"],Zle={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Qle={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};function Mz(e){return{appProviders:[...iue,...e?.providers??[]],platformProviders:sue}}const sue=[{provide:Hu,useValue:"browser"},{provide:hE,useValue:function tue(){cT.makeCurrent()},multi:!0},{provide:fo,useFactory:function rue(){return function W7(e){dE=e}(document),document},deps:[]}],iue=[{provide:S_,useValue:"root"},{provide:Ri,useFactory:function nue(){return new Ri},deps:[]},{provide:dT,useClass:(()=>{class e extends Iz{constructor(t){super(t)}supports(t){return!0}addEventListener(t,r,s,o){return t.addEventListener(r,s,o),()=>this.removeEventListener(t,r,s,o)}removeEventListener(t,r,s,o){return t.removeEventListener(r,s,o)}static \u0275fac=function(r){return new(r||e)($e(fo))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})(),multi:!0,deps:[fo,Vt,Hu]},{provide:dT,useClass:(()=>{class e extends Iz{constructor(t){super(t)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,r,s,o){const i=e.parseEventName(r),a=e.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Tl().onAndCancel(t,i.domEventName,a,o))}static parseEventName(t){const r=t.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const o=e._normalizeKey(r.pop());let i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),Rz.forEach(u=>{const c=r.indexOf(u);c>-1&&(r.splice(c,1),i+=u+".")}),i+=o,0!=r.length||0===o.length)return null;const l={};return l.domEventName=s,l.fullKey=i,l}static matchEventFullKeyCode(t,r){let s=Zle[t.key]||t.key,o="";return r.indexOf("code.")>-1&&(s=t.code,o="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),Rz.forEach(i=>{i!==s&&(0,Qle[i])(t)&&(o+=i+".")}),o+=s,o===r)}static eventCallback(t,r,s){return o=>{e.matchEventFullKeyCode(o,t)&&s.runGuarded(()=>r(o))}}static _normalizeKey(t){return"esc"===t?"escape":t}static \u0275fac=function(r){return new(r||e)($e(fo))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})(),multi:!0,deps:[fo]},Tz,Ez,Cz,{provide:ND,useExisting:Tz},{provide:dz,useClass:Ble,deps:[]},[]];let aue=(()=>{class e{_doc;constructor(t){this._doc=t}getTitle(){return this._doc.title}setTitle(t){this._doc.title=t||""}static \u0275fac=function(r){return new(r||e)($e(fo))};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function yT(e){return e[e.length-1]}function $z(e){return mn(yT(e))?e.pop():void 0}function vx(e){return function due(e){return e&&mn(e.schedule)}(yT(e))?e.pop():void 0}function Al(e){return this instanceof Al?(this.v=e,this):new Al(e)}function Bz(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,n=e[Symbol.asyncIterator];return n?n.call(e):(e=function xT(e){var n="function"==typeof Symbol&&Symbol.iterator,t=n&&e[n],r=0;if(t)return t.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(o){t[o]=e[o]&&function(i){return new Promise(function(a,l){!function s(o,i,a,l){Promise.resolve(l).then(function(u){o({value:u,done:a})},i)}(a,l,(i=e[o](i)).done,i.value)})}}}"function"==typeof SuppressedError&&SuppressedError;const zz=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function Uz(e){return mn(e?.then)}function Wz(e){return mn(e[r_])}function Hz(e){return Symbol.asyncIterator&&mn(e?.[Symbol.asyncIterator])}function jz(e){return new TypeError(`You provided ${null!==e&&"object"==typeof e?"an invalid object":`'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const Gz=function Lue(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function qz(e){return mn(e?.[Gz])}function Kz(e){return function Vz(e,n,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=t.apply(e,n||[]),o=[];return s=Object.create(("function"==typeof AsyncIterator?AsyncIterator:Object).prototype),a("next"),a("throw"),a("return",function i(f){return function(p){return Promise.resolve(p).then(f,d)}}),s[Symbol.asyncIterator]=function(){return this},s;function a(f,p){r[f]&&(s[f]=function(m){return new Promise(function(g,y){o.push([f,m,g,y])>1||l(f,m)})},p&&(s[f]=p(s[f])))}function l(f,p){try{!function u(f){f.value instanceof Al?Promise.resolve(f.value.v).then(c,d):h(o[0][2],f)}(r[f](p))}catch(m){h(o[0][3],m)}}function c(f){l("next",f)}function d(f){l("throw",f)}function h(f,p){f(p),o.shift(),o.length&&l(o[0][0],o[0][1])}}(this,arguments,function*(){const t=e.getReader();try{for(;;){const{value:r,done:s}=yield Al(t.read());if(s)return yield Al(void 0);yield yield Al(r)}}finally{t.releaseLock()}})}function Xz(e){return mn(e?.getReader)}function Bi(e){if(e instanceof sr)return e;if(null!=e){if(Wz(e))return function Vue(e){return new sr(n=>{const t=e[r_]();if(mn(t.subscribe))return t.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(e);if(zz(e))return function Bue(e){return new sr(n=>{for(let t=0;t<e.length&&!n.closed;t++)n.next(e[t]);n.complete()})}(e);if(Uz(e))return function zue(e){return new sr(n=>{e.then(t=>{n.closed||(n.next(t),n.complete())},t=>n.error(t)).then(null,SO)})}(e);if(Hz(e))return Yz(e);if(qz(e))return function Uue(e){return new sr(n=>{for(const t of e)if(n.next(t),n.closed)return;n.complete()})}(e);if(Xz(e))return function Wue(e){return Yz(Kz(e))}(e)}throw jz(e)}function Yz(e){return new sr(n=>{(function Hue(e,n){var t,r,s,o;return function Pz(e,n,t,r){return new(t||(t=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof t?o:new t(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(e,n||[])).next())})}(this,void 0,void 0,function*(){try{for(t=Bz(e);!(r=yield t.next()).done;)if(n.next(r.value),n.closed)return}catch(i){s={error:i}}finally{try{r&&!r.done&&(o=t.return)&&(yield o.call(t))}finally{if(s)throw s.error}}n.complete()})})(e,n).catch(t=>n.error(t))})}function ka(e,n,t,r=0,s=!1){const o=n.schedule(function(){t(),s?e.add(this.schedule(null,r)):this.unsubscribe()},r);if(e.add(o),!s)return o}function Zz(e,n=0){return Kr((t,r)=>{t.subscribe(yr(r,s=>ka(r,e,()=>r.next(s),n),()=>ka(r,e,()=>r.complete(),n),s=>ka(r,e,()=>r.error(s),n)))})}function Qz(e,n=0){return Kr((t,r)=>{r.add(e.schedule(()=>t.subscribe(r),n))})}function Jz(e,n){if(!e)throw new Error("Iterable cannot be null");return new sr(t=>{ka(t,n,()=>{const r=e[Symbol.asyncIterator]();ka(t,n,()=>{r.next().then(s=>{s.done?t.complete():t.next(s.value)})},0,!0)})})}function Sr(e,n){return n?function Yue(e,n){if(null!=e){if(Wz(e))return function jue(e,n){return Bi(e).pipe(Qz(n),Zz(n))}(e,n);if(zz(e))return function que(e,n){return new sr(t=>{let r=0;return n.schedule(function(){r===e.length?t.complete():(t.next(e[r++]),t.closed||this.schedule())})})}(e,n);if(Uz(e))return function Gue(e,n){return Bi(e).pipe(Qz(n),Zz(n))}(e,n);if(Hz(e))return Jz(e,n);if(qz(e))return function Kue(e,n){return new sr(t=>{let r;return ka(t,n,()=>{r=e[Gz](),ka(t,n,()=>{let s,o;try{({value:s,done:o}=r.next())}catch(i){return void t.error(i)}o?t.complete():t.next(s)},0,!0)}),()=>mn(r?.return)&&r.return()})}(e,n);if(Xz(e))return function Xue(e,n){return Jz(Kz(e),n)}(e,n)}throw jz(e)}(e,n):Bi(e)}function Qe(...e){return Sr(e,vx(e))}function as(e,n,t=1/0){return mn(n)?as((r,s)=>Rt((o,i)=>n(r,o,s,i))(Bi(e(r,s))),t):("number"==typeof n&&(t=n),Kr((r,s)=>function Zue(e,n,t,r,s,o,i,a){const l=[];let u=0,c=0,d=!1;const h=()=>{d&&!l.length&&!u&&n.complete()},f=m=>u<r?p(m):l.push(m),p=m=>{o&&n.next(m),u++;let g=!1;Bi(t(m,c++)).subscribe(yr(n,y=>{s?.(y),o?f(y):n.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(u--;l.length&&u<r;){const y=l.shift();i?ka(n,i,()=>p(y)):p(y)}h()}catch(y){n.error(y)}}))};return e.subscribe(yr(n,f,()=>{d=!0,h()})),()=>{a?.()}}(r,s,e,t)))}function yh(e,n){return mn(n)?as(e,n,1):as(e,1)}function Aa(e,n){return Kr((t,r)=>{let s=0;t.subscribe(yr(r,o=>e.call(n,o,s++)&&r.next(o)))})}function ag(e){return Kr((n,t)=>{try{n.subscribe(t)}finally{t.add(e)}})}function ui(e,n){return Kr((t,r)=>{let s=null,o=0,i=!1;const a=()=>i&&!s&&r.complete();t.subscribe(yr(r,l=>{s?.unsubscribe();let u=0;const c=o++;Bi(e(l,c)).subscribe(s=yr(r,d=>r.next(n?n(l,d,c,u++):d),()=>{s=null,a()}))},()=>{i=!0,a()}))})}class bx{}class wx{}class _r{headers;normalizedNames=new Map;lazyInit;lazyUpdate=null;constructor(n){n?"string"==typeof n?this.lazyInit=()=>{this.headers=new Map,n.split("\n").forEach(t=>{const r=t.indexOf(":");if(r>0){const s=t.slice(0,r),o=t.slice(r+1).trim();this.addHeaderEntry(s,o)}})}:typeof Headers<"u"&&n instanceof Headers?(this.headers=new Map,n.forEach((t,r)=>{this.addHeaderEntry(r,t)})):this.lazyInit=()=>{this.headers=new Map,Object.entries(n).forEach(([t,r])=>{this.setHeaderEntries(t,r)})}:this.headers=new Map}has(n){return this.init(),this.headers.has(n.toLowerCase())}get(n){this.init();const t=this.headers.get(n.toLowerCase());return t&&t.length>0?t[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(n){return this.init(),this.headers.get(n.toLowerCase())||null}append(n,t){return this.clone({name:n,value:t,op:"a"})}set(n,t){return this.clone({name:n,value:t,op:"s"})}delete(n,t){return this.clone({name:n,value:t,op:"d"})}maybeSetNormalizedName(n,t){this.normalizedNames.has(t)||this.normalizedNames.set(t,n)}init(){this.lazyInit&&(this.lazyInit instanceof _r?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(n=>this.applyUpdate(n)),this.lazyUpdate=null))}copyFrom(n){n.init(),Array.from(n.headers.keys()).forEach(t=>{this.headers.set(t,n.headers.get(t)),this.normalizedNames.set(t,n.normalizedNames.get(t))})}clone(n){const t=new _r;return t.lazyInit=this.lazyInit&&this.lazyInit instanceof _r?this.lazyInit:this,t.lazyUpdate=(this.lazyUpdate||[]).concat([n]),t}applyUpdate(n){const t=n.name.toLowerCase();switch(n.op){case"a":case"s":let r=n.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(n.name,t);const s=("a"===n.op?this.headers.get(t):void 0)||[];s.push(...r),this.headers.set(t,s);break;case"d":const o=n.value;if(o){let i=this.headers.get(t);if(!i)return;i=i.filter(a=>-1===o.indexOf(a)),0===i.length?(this.headers.delete(t),this.normalizedNames.delete(t)):this.headers.set(t,i)}else this.headers.delete(t),this.normalizedNames.delete(t)}}addHeaderEntry(n,t){const r=n.toLowerCase();this.maybeSetNormalizedName(n,r),this.headers.has(r)?this.headers.get(r).push(t):this.headers.set(r,[t])}setHeaderEntries(n,t){const r=(Array.isArray(t)?t:[t]).map(o=>o.toString()),s=n.toLowerCase();this.headers.set(s,r),this.maybeSetNormalizedName(n,s)}forEach(n){this.init(),Array.from(this.normalizedNames.keys()).forEach(t=>n(this.normalizedNames.get(t),this.headers.get(t)))}}class Que{encodeKey(n){return eU(n)}encodeValue(n){return eU(n)}decodeKey(n){return decodeURIComponent(n)}decodeValue(n){return decodeURIComponent(n)}}const ece=/%(\d[a-f0-9])/gi,tce={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function eU(e){return encodeURIComponent(e).replace(ece,(n,t)=>tce[t]??n)}function xx(e){return`${e}`}class Rl{map;encoder;updates=null;cloneFrom=null;constructor(n={}){if(this.encoder=n.encoder||new Que,n.fromString){if(n.fromObject)throw new te(2805,!1);this.map=function Jue(e,n){const t=new Map;return e.length>0&&e.replace(/^\?/,"").split("&").forEach(s=>{const o=s.indexOf("="),[i,a]=-1==o?[n.decodeKey(s),""]:[n.decodeKey(s.slice(0,o)),n.decodeValue(s.slice(o+1))],l=t.get(i)||[];l.push(a),t.set(i,l)}),t}(n.fromString,this.encoder)}else n.fromObject?(this.map=new Map,Object.keys(n.fromObject).forEach(t=>{const r=n.fromObject[t],s=Array.isArray(r)?r.map(xx):[xx(r)];this.map.set(t,s)})):this.map=null}has(n){return this.init(),this.map.has(n)}get(n){this.init();const t=this.map.get(n);return t?t[0]:null}getAll(n){return this.init(),this.map.get(n)||null}keys(){return this.init(),Array.from(this.map.keys())}append(n,t){return this.clone({param:n,value:t,op:"a"})}appendAll(n){const t=[];return Object.keys(n).forEach(r=>{const s=n[r];Array.isArray(s)?s.forEach(o=>{t.push({param:r,value:o,op:"a"})}):t.push({param:r,value:s,op:"a"})}),this.clone(t)}set(n,t){return this.clone({param:n,value:t,op:"s"})}delete(n,t){return this.clone({param:n,value:t,op:"d"})}toString(){return this.init(),this.keys().map(n=>{const t=this.encoder.encodeKey(n);return this.map.get(n).map(r=>t+"="+this.encoder.encodeValue(r)).join("&")}).filter(n=>""!==n).join("&")}clone(n){const t=new Rl({encoder:this.encoder});return t.cloneFrom=this.cloneFrom||this,t.updates=(this.updates||[]).concat(n),t}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(n=>this.map.set(n,this.cloneFrom.map.get(n))),this.updates.forEach(n=>{switch(n.op){case"a":case"s":const t=("a"===n.op?this.map.get(n.param):void 0)||[];t.push(xx(n.value)),this.map.set(n.param,t);break;case"d":if(void 0===n.value){this.map.delete(n.param);break}{let r=this.map.get(n.param)||[];const s=r.indexOf(xx(n.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(n.param,r):this.map.delete(n.param)}}}),this.cloneFrom=this.updates=null)}}class nce{map=new Map;set(n,t){return this.map.set(n,t),this}get(n){return this.map.has(n)||this.map.set(n,n.defaultValue()),this.map.get(n)}delete(n){return this.map.delete(n),this}has(n){return this.map.has(n)}keys(){return this.map.keys()}}function tU(e){return typeof ArrayBuffer<"u"&&e instanceof ArrayBuffer}function nU(e){return typeof Blob<"u"&&e instanceof Blob}function rU(e){return typeof FormData<"u"&&e instanceof FormData}const lg="Content-Type",IT="X-Request-URL",sU="text/plain",oU="application/json",iU=`${oU}, ${sU}, */*`;class ug{url;body=null;headers;context;reportProgress=!1;withCredentials=!1;responseType="json";method;params;urlWithParams;transferCache;constructor(n,t,r,s){let o;if(this.url=t,this.method=n.toUpperCase(),function rce(e){switch(e){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,o=s):o=r,o&&(this.reportProgress=!!o.reportProgress,this.withCredentials=!!o.withCredentials,o.responseType&&(this.responseType=o.responseType),o.headers&&(this.headers=o.headers),o.context&&(this.context=o.context),o.params&&(this.params=o.params),this.transferCache=o.transferCache),this.headers??=new _r,this.context??=new nce,this.params){const i=this.params.toString();if(0===i.length)this.urlWithParams=t;else{const a=t.indexOf("?");this.urlWithParams=t+(-1===a?"?":a<t.length-1?"&":"")+i}}else this.params=new Rl,this.urlWithParams=t}serializeBody(){return null===this.body?null:"string"==typeof this.body||tU(this.body)||nU(this.body)||rU(this.body)||function sce(e){return typeof URLSearchParams<"u"&&e instanceof URLSearchParams}(this.body)?this.body:this.body instanceof Rl?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||rU(this.body)?null:nU(this.body)?this.body.type||null:tU(this.body)?null:"string"==typeof this.body?sU:this.body instanceof Rl?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?oU:null}clone(n={}){const t=n.method||this.method,r=n.url||this.url,s=n.responseType||this.responseType,o=n.transferCache??this.transferCache,i=void 0!==n.body?n.body:this.body,a=n.withCredentials??this.withCredentials,l=n.reportProgress??this.reportProgress;let u=n.headers||this.headers,c=n.params||this.params;const d=n.context??this.context;return void 0!==n.setHeaders&&(u=Object.keys(n.setHeaders).reduce((h,f)=>h.set(f,n.setHeaders[f]),u)),n.setParams&&(c=Object.keys(n.setParams).reduce((h,f)=>h.set(f,n.setParams[f]),c)),new ug(t,r,i,{params:c,headers:u,context:d,reportProgress:l,responseType:s,withCredentials:a,transferCache:o})}}var Ml=function(e){return e[e.Sent=0]="Sent",e[e.UploadProgress=1]="UploadProgress",e[e.ResponseHeader=2]="ResponseHeader",e[e.DownloadProgress=3]="DownloadProgress",e[e.Response=4]="Response",e[e.User=5]="User",e}(Ml||{});class ST{headers;status;statusText;url;ok;type;constructor(n,t=200,r="OK"){this.headers=n.headers||new _r,this.status=void 0!==n.status?n.status:t,this.statusText=n.statusText||r,this.url=n.url||null,this.ok=this.status>=200&&this.status<300}}class Cx extends ST{constructor(n={}){super(n)}type=Ml.ResponseHeader;clone(n={}){return new Cx({headers:n.headers||this.headers,status:void 0!==n.status?n.status:this.status,statusText:n.statusText||this.statusText,url:n.url||this.url||void 0})}}class lc extends ST{body;constructor(n={}){super(n),this.body=void 0!==n.body?n.body:null}type=Ml.Response;clone(n={}){return new lc({body:void 0!==n.body?n.body:this.body,headers:n.headers||this.headers,status:void 0!==n.status?n.status:this.status,statusText:n.statusText||this.statusText,url:n.url||this.url||void 0})}}class vh extends ST{name="HttpErrorResponse";message;error;ok=!1;constructor(n){super(n,0,"Unknown Error"),this.message=this.status>=200&&this.status<300?`Http failure during parsing for ${n.url||"(unknown url)"}`:`Http failure response for ${n.url||"(unknown url)"}: ${n.status} ${n.statusText}`,this.error=n.error||null}}function _T(e,n){return{body:n,headers:e.headers,context:e.context,observe:e.observe,params:e.params,reportProgress:e.reportProgress,responseType:e.responseType,withCredentials:e.withCredentials,transferCache:e.transferCache}}let bh=(()=>{class e{handler;constructor(t){this.handler=t}request(t,r,s={}){let o;if(t instanceof ug)o=t;else{let l,u;l=s.headers instanceof _r?s.headers:new _r(s.headers),s.params&&(u=s.params instanceof Rl?s.params:new Rl({fromObject:s.params})),o=new ug(t,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:u,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials,transferCache:s.transferCache})}const i=Qe(o).pipe(yh(l=>this.handler.handle(l)));if(t instanceof ug||"events"===s.observe)return i;const a=i.pipe(Aa(l=>l instanceof lc));switch(s.observe||"body"){case"body":switch(o.responseType){case"arraybuffer":return a.pipe(Rt(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(Rt(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(Rt(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(Rt(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(t,r={}){return this.request("DELETE",t,r)}get(t,r={}){return this.request("GET",t,r)}head(t,r={}){return this.request("HEAD",t,r)}jsonp(t,r){return this.request("JSONP",t,{params:(new Rl).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(t,r={}){return this.request("OPTIONS",t,r)}patch(t,r,s={}){return this.request("PATCH",t,_T(s,r))}post(t,r,s={}){return this.request("POST",t,_T(s,r))}put(t,r,s={}){return this.request("PUT",t,_T(s,r))}static \u0275fac=function(r){return new(r||e)($e(bx))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();const uU=new fe("");function cU(e,n){return n(e)}function cce(e,n){return(t,r)=>n.intercept(t,{handle:s=>e(s,r)})}const hce=new fe(""),cg=new fe(""),dU=new fe(""),hU=new fe("",{providedIn:"root",factory:()=>!0});function fce(){let e=null;return(n,t)=>{null===e&&(e=(Z(hce,{optional:!0})??[]).reduceRight(cce,cU));const r=Z(ti);if(Z(hU)){const o=r.add();return e(n,t).pipe(ag(()=>r.remove(o)))}return e(n,t)}}let fU=(()=>{class e extends bx{backend;injector;chain=null;pendingTasks=Z(ti);contributeToStability=Z(hU);constructor(t,r){super(),this.backend=t,this.injector=r}handle(t){if(null===this.chain){const r=Array.from(new Set([...this.injector.get(cg),...this.injector.get(dU,[])]));this.chain=r.reduceRight((s,o)=>function dce(e,n,t){return(r,s)=>Oo(t,()=>n(r,o=>e(o,s)))}(s,o,this.injector),cU)}if(this.contributeToStability){const r=this.pendingTasks.add();return this.chain(t,s=>this.backend.handle(s)).pipe(ag(()=>this.pendingTasks.remove(r)))}return this.chain(t,r=>this.backend.handle(r))}static \u0275fac=function(r){return new(r||e)($e(wx),$e(ws))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();const vce=/^\)\]\}',?\n/,bce=RegExp(`^${IT}:`,"m");let mU=(()=>{class e{xhrFactory;constructor(t){this.xhrFactory=t}handle(t){if("JSONP"===t.method)throw new te(-2800,!1);const r=this.xhrFactory;return(r.\u0275loadImpl?Sr(r.\u0275loadImpl()):Qe(null)).pipe(ui(()=>new sr(o=>{const i=r.build();if(i.open(t.method,t.urlWithParams),t.withCredentials&&(i.withCredentials=!0),t.headers.forEach((m,g)=>i.setRequestHeader(m,g.join(","))),t.headers.has("Accept")||i.setRequestHeader("Accept",iU),!t.headers.has(lg)){const m=t.detectContentTypeHeader();null!==m&&i.setRequestHeader(lg,m)}if(t.responseType){const m=t.responseType.toLowerCase();i.responseType="json"!==m?m:"text"}const a=t.serializeBody();let l=null;const u=()=>{if(null!==l)return l;const m=i.statusText||"OK",g=new _r(i.getAllResponseHeaders()),y=function wce(e){return"responseURL"in e&&e.responseURL?e.responseURL:bce.test(e.getAllResponseHeaders())?e.getResponseHeader(IT):null}(i)||t.url;return l=new Cx({headers:g,status:i.status,statusText:m,url:y}),l},c=()=>{let{headers:m,status:g,statusText:y,url:v}=u(),b=null;204!==g&&(b=typeof i.response>"u"?i.responseText:i.response),0===g&&(g=b?200:0);let w=g>=200&&g<300;if("json"===t.responseType&&"string"==typeof b){const x=b;b=b.replace(vce,"");try{b=""!==b?JSON.parse(b):null}catch(I){b=x,w&&(w=!1,b={error:I,text:b})}}w?(o.next(new lc({body:b,headers:m,status:g,statusText:y,url:v||void 0})),o.complete()):o.error(new vh({error:b,headers:m,status:g,statusText:y,url:v||void 0}))},d=m=>{const{url:g}=u(),y=new vh({error:m,status:i.status||0,statusText:i.statusText||"Unknown Error",url:g||void 0});o.error(y)};let h=!1;const f=m=>{h||(o.next(u()),h=!0);let g={type:Ml.DownloadProgress,loaded:m.loaded};m.lengthComputable&&(g.total=m.total),"text"===t.responseType&&i.responseText&&(g.partialText=i.responseText),o.next(g)},p=m=>{let g={type:Ml.UploadProgress,loaded:m.loaded};m.lengthComputable&&(g.total=m.total),o.next(g)};return i.addEventListener("load",c),i.addEventListener("error",d),i.addEventListener("timeout",d),i.addEventListener("abort",d),t.reportProgress&&(i.addEventListener("progress",f),null!==a&&i.upload&&i.upload.addEventListener("progress",p)),i.send(a),o.next({type:Ml.Sent}),()=>{i.removeEventListener("error",d),i.removeEventListener("abort",d),i.removeEventListener("load",c),i.removeEventListener("timeout",d),t.reportProgress&&(i.removeEventListener("progress",f),null!==a&&i.upload&&i.upload.removeEventListener("progress",p)),i.readyState!==i.DONE&&i.abort()}})))}static \u0275fac=function(r){return new(r||e)($e(dz))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();const NT=new fe(""),gU=new fe("",{providedIn:"root",factory:()=>"XSRF-TOKEN"}),yU=new fe("",{providedIn:"root",factory:()=>"X-XSRF-TOKEN"});class vU{}let Ice=(()=>{class e{doc;platform;cookieName;lastCookieString="";lastToken=null;parseCount=0;constructor(t,r,s){this.doc=t,this.platform=r,this.cookieName=s}getToken(){if("server"===this.platform)return null;const t=this.doc.cookie||"";return t!==this.lastCookieString&&(this.parseCount++,this.lastToken=ez(t,this.cookieName),this.lastCookieString=t),this.lastToken}static \u0275fac=function(r){return new(r||e)($e(fo),$e(Hu),$e(gU))};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();function Sce(e,n){const t=e.url.toLowerCase();if(!Z(NT)||"GET"===e.method||"HEAD"===e.method||t.startsWith("http://")||t.startsWith("https://"))return n(e);const r=Z(vU).getToken(),s=Z(yU);return null!=r&&!e.headers.has(s)&&(e=e.clone({headers:e.headers.set(s,r)})),n(e)}var Ol=function(e){return e[e.Interceptors=0]="Interceptors",e[e.LegacyInterceptors=1]="LegacyInterceptors",e[e.CustomXsrfConfiguration=2]="CustomXsrfConfiguration",e[e.NoXsrfProtection=3]="NoXsrfProtection",e[e.JsonpSupport=4]="JsonpSupport",e[e.RequestsMadeViaParent=5]="RequestsMadeViaParent",e[e.Fetch=6]="Fetch",e}(Ol||{});function bU(...e){const n=[bh,mU,fU,{provide:bx,useExisting:fU},{provide:wx,useFactory:()=>Z(uU,{optional:!0})??Z(mU)},{provide:cg,useValue:Sce,multi:!0},{provide:NT,useValue:!0},{provide:vU,useClass:Ice}];for(const t of e)n.push(...t.\u0275providers);return ya(n)}const wU=new fe("");function _ce(){return function uc(e,n){return{\u0275kind:e,\u0275providers:n}}(Ol.LegacyInterceptors,[{provide:wU,useFactory:fce},{provide:cg,useExisting:wU,multi:!0}])}let TT=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275mod=Ju({type:e});static \u0275inj=il({providers:[bU(_ce())]})}return e})();const{isArray:Vce}=Array,{getPrototypeOf:Bce,prototype:zce,keys:Uce}=Object;function CU(e){if(1===e.length){const n=e[0];if(Vce(n))return{args:n,keys:null};if(function Wce(e){return e&&"object"==typeof e&&Bce(e)===zce}(n)){const t=Uce(n);return{args:t.map(r=>n[r]),keys:t}}}return{args:e,keys:null}}const{isArray:Hce}=Array;function IU(e){return Rt(n=>function jce(e,n){return Hce(n)?e(...n):e(n)}(e,n))}function SU(e,n){return e.reduce((t,r,s)=>(t[r]=n[s],t),{})}function kT(...e){const n=vx(e),t=$z(e),{args:r,keys:s}=CU(e);if(0===r.length)return Sr([],n);const o=new sr(function Gce(e,n,t=Du){return r=>{_U(n,()=>{const{length:s}=e,o=new Array(s);let i=s,a=s;for(let l=0;l<s;l++)_U(n,()=>{const u=Sr(e[l],n);let c=!1;u.subscribe(yr(r,d=>{o[l]=d,c||(c=!0,a--),a||r.next(t(o.slice()))},()=>{--i||r.complete()}))},r)},r)}}(r,n,s?i=>SU(s,i):Du));return t?o.pipe(IU(t)):o}function _U(e,n,t){e?ka(t,e,n):n()}const Sx=KS(e=>function(){e(this),this.name="EmptyError",this.message="no elements in sequence"});function dg(e=1/0){return as(Du,e)}function AT(...e){return function qce(){return dg(1)}()(Sr(e,vx(e)))}function EU(e){return new sr(n=>{Bi(e()).subscribe(n)})}function _x(e,n){const t=mn(e)?e:()=>e,r=s=>s.error(t());return new sr(n?s=>n.schedule(r,0,s):r)}const zi=new sr(e=>e.complete());function RT(){return Kr((e,n)=>{let t=null;e._refCount++;const r=yr(n,void 0,void 0,void 0,()=>{if(!e||e._refCount<=0||0<--e._refCount)return void(t=null);const s=e._connection,o=t;t=null,s&&(!o||s===o)&&s.unsubscribe(),n.unsubscribe()});e.subscribe(r),r.closed||(t=e.connect())})}class DU extends sr{constructor(n,t){super(),this.source=n,this.subjectFactory=t,this._subject=null,this._refCount=0,this._connection=null,NO(n)&&(this.lift=n.lift)}_subscribe(n){return this.getSubject().subscribe(n)}getSubject(){const n=this._subject;return(!n||n.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:n}=this;this._subject=this._connection=null,n?.unsubscribe()}connect(){let n=this._connection;if(!n){n=this._connection=new bs;const t=this.getSubject();n.add(this.source.subscribe(yr(t,void 0,()=>{this._teardown(),t.complete()},r=>{this._teardown(),t.error(r)},()=>this._teardown()))),n.closed&&(this._connection=null,n=bs.EMPTY)}return n}refCount(){return RT()(this)}}function wh(e){return e<=0?()=>zi:Kr((n,t)=>{let r=0;n.subscribe(yr(t,s=>{++r<=e&&(t.next(s),e<=r&&t.complete())}))})}function Ex(e){return Kr((n,t)=>{let r=!1;n.subscribe(yr(t,s=>{r=!0,t.next(s)},()=>{r||t.next(e),t.complete()}))})}function NU(e=Yce){return Kr((n,t)=>{let r=!1;n.subscribe(yr(t,s=>{r=!0,t.next(s)},()=>r?t.complete():t.error(e())))})}function Yce(){return new Sx}function cc(e,n){const t=arguments.length>=2;return r=>r.pipe(e?Aa((s,o)=>e(s,o,r)):Du,wh(1),t?Ex(n):NU(()=>new Sx))}function Ds(e,n,t){const r=mn(e)||n||t?{next:e,error:n,complete:t}:e;return r?Kr((s,o)=>{var i;null===(i=r.subscribe)||void 0===i||i.call(r);let a=!0;s.subscribe(yr(o,l=>{var u;null===(u=r.next)||void 0===u||u.call(r,l),o.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),o.complete()},l=>{var u;a=!1,null===(u=r.error)||void 0===u||u.call(r,l),o.error(l)},()=>{var l,u;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(u=r.finalize)||void 0===u||u.call(r)}))}):Du}function xh(e){return Kr((n,t)=>{let o,r=null,s=!1;r=n.subscribe(yr(t,void 0,void 0,i=>{o=Bi(e(i,xh(e)(n))),r?(r.unsubscribe(),r=null,o.subscribe(t)):s=!0})),s&&(r.unsubscribe(),r=null,o.subscribe(t))})}function MT(e){return e<=0?()=>zi:Kr((n,t)=>{let r=[];n.subscribe(yr(t,s=>{r.push(s),e<r.length&&r.shift()},()=>{for(const s of r)t.next(s);t.complete()},void 0,()=>{r=null}))})}const ft="primary",hg=Symbol("RouteTitle");class tde{params;constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){const t=this.params[n];return Array.isArray(t)?t[0]:t}return null}getAll(n){if(this.has(n)){const t=this.params[n];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function Ch(e){return new tde(e)}function nde(e,n,t){const r=t.path.split("/");if(r.length>e.length||"full"===t.pathMatch&&(n.hasChildren()||r.length<e.length))return null;const s={};for(let o=0;o<r.length;o++){const i=r[o],a=e[o];if(":"===i[0])s[i.substring(1)]=a;else if(i!==a.path)return null}return{consumed:e.slice(0,r.length),posParams:s}}function Ui(e,n){const t=e?OT(e):void 0,r=n?OT(n):void 0;if(!t||!r||t.length!=r.length)return!1;let s;for(let o=0;o<t.length;o++)if(s=t[o],!TU(e[s],n[s]))return!1;return!0}function OT(e){return[...Object.keys(e),...Object.getOwnPropertySymbols(e)]}function TU(e,n){if(Array.isArray(e)&&Array.isArray(n)){if(e.length!==n.length)return!1;const t=[...e].sort(),r=[...n].sort();return t.every((s,o)=>r[o]===s)}return e===n}function kU(e){return e.length>0?e[e.length-1]:null}function Fl(e){return function Lce(e){return!!e&&(e instanceof sr||mn(e.lift)&&mn(e.subscribe))}(e)?e:Am(e)?Sr(Promise.resolve(e)):Qe(e)}const sde={exact:function MU(e,n,t){if(!hc(e.segments,n.segments)||!Dx(e.segments,n.segments,t)||e.numberOfChildren!==n.numberOfChildren)return!1;for(const r in n.children)if(!e.children[r]||!MU(e.children[r],n.children[r],t))return!1;return!0},subset:OU},AU={exact:function ode(e,n){return Ui(e,n)},subset:function ide(e,n){return Object.keys(n).length<=Object.keys(e).length&&Object.keys(n).every(t=>TU(e[t],n[t]))},ignored:()=>!0};function RU(e,n,t){return sde[t.paths](e.root,n.root,t.matrixParams)&&AU[t.queryParams](e.queryParams,n.queryParams)&&!("exact"===t.fragment&&e.fragment!==n.fragment)}function OU(e,n,t){return FU(e,n,n.segments,t)}function FU(e,n,t,r){if(e.segments.length>t.length){const s=e.segments.slice(0,t.length);return!(!hc(s,t)||n.hasChildren()||!Dx(s,t,r))}if(e.segments.length===t.length){if(!hc(e.segments,t)||!Dx(e.segments,t,r))return!1;for(const s in n.children)if(!e.children[s]||!OU(e.children[s],n.children[s],r))return!1;return!0}{const s=t.slice(0,e.segments.length),o=t.slice(e.segments.length);return!!(hc(e.segments,s)&&Dx(e.segments,s,r)&&e.children[ft])&&FU(e.children[ft],n,o,r)}}function Dx(e,n,t){return n.every((r,s)=>AU[t](e[s].parameters,r.parameters))}class dc{root;queryParams;fragment;_queryParamMap;constructor(n=new Qt([],{}),t={},r=null){this.root=n,this.queryParams=t,this.fragment=r}get queryParamMap(){return this._queryParamMap??=Ch(this.queryParams),this._queryParamMap}toString(){return ude.serialize(this)}}class Qt{segments;children;parent=null;constructor(n,t){this.segments=n,this.children=t,Object.values(t).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Tx(this)}}class fg{path;parameters;_parameterMap;constructor(n,t){this.path=n,this.parameters=t}get parameterMap(){return this._parameterMap??=Ch(this.parameters),this._parameterMap}toString(){return LU(this)}}function hc(e,n){return e.length===n.length&&e.every((t,r)=>t.path===n[r].path)}let Ih=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>new Nx,providedIn:"root"})}return e})();class Nx{parse(n){const t=new wde(n);return new dc(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(n){const t=`/${pg(n.root,!0)}`,r=function hde(e){const n=Object.entries(e).map(([t,r])=>Array.isArray(r)?r.map(s=>`${kx(t)}=${kx(s)}`).join("&"):`${kx(t)}=${kx(r)}`).filter(t=>t);return n.length?`?${n.join("&")}`:""}(n.queryParams);return`${t}${r}${"string"==typeof n.fragment?`#${function cde(e){return encodeURI(e)}(n.fragment)}`:""}`}}const ude=new Nx;function Tx(e){return e.segments.map(n=>LU(n)).join("/")}function pg(e,n){if(!e.hasChildren())return Tx(e);if(n){const t=e.children[ft]?pg(e.children[ft],!1):"",r=[];return Object.entries(e.children).forEach(([s,o])=>{s!==ft&&r.push(`${s}:${pg(o,!1)}`)}),r.length>0?`${t}(${r.join("//")})`:t}{const t=function lde(e,n){let t=[];return Object.entries(e.children).forEach(([r,s])=>{r===ft&&(t=t.concat(n(s,r)))}),Object.entries(e.children).forEach(([r,s])=>{r!==ft&&(t=t.concat(n(s,r)))}),t}(e,(r,s)=>s===ft?[pg(e.children[ft],!1)]:[`${s}:${pg(r,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children[ft]?`${Tx(e)}/${t[0]}`:`${Tx(e)}/(${t.join("//")})`}}function $U(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function kx(e){return $U(e).replace(/%3B/gi,";")}function FT(e){return $U(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Ax(e){return decodeURIComponent(e)}function PU(e){return Ax(e.replace(/\+/g,"%20"))}function LU(e){return`${FT(e.path)}${function dde(e){return Object.entries(e).map(([n,t])=>`;${FT(n)}=${FT(t)}`).join("")}(e.parameters)}`}const fde=/^[^\/()?;#]+/;function $T(e){const n=e.match(fde);return n?n[0]:""}const pde=/^[^\/()?;=#]+/,gde=/^[^=?&#]+/,vde=/^[^&#]+/;class wde{url;remaining;constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Qt([],{}):new Qt([],this.parseChildren())}parseQueryParams(){const n={};if(this.consumeOptional("?"))do{this.parseQueryParam(n)}while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const n=[];for(this.peekStartsWith("(")||n.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),n.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(n.length>0||Object.keys(t).length>0)&&(r[ft]=new Qt(n,t)),r}parseSegment(){const n=$T(this.remaining);if(""===n&&this.peekStartsWith(";"))throw new te(4009,!1);return this.capture(n),new fg(Ax(n),this.parseMatrixParams())}parseMatrixParams(){const n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){const t=function mde(e){const n=e.match(pde);return n?n[0]:""}(this.remaining);if(!t)return;this.capture(t);let r="";if(this.consumeOptional("=")){const s=$T(this.remaining);s&&(r=s,this.capture(r))}n[Ax(t)]=Ax(r)}parseQueryParam(n){const t=function yde(e){const n=e.match(gde);return n?n[0]:""}(this.remaining);if(!t)return;this.capture(t);let r="";if(this.consumeOptional("=")){const i=function bde(e){const n=e.match(vde);return n?n[0]:""}(this.remaining);i&&(r=i,this.capture(r))}const s=PU(t),o=PU(r);if(n.hasOwnProperty(s)){let i=n[s];Array.isArray(i)||(i=[i],n[s]=i),i.push(o)}else n[s]=o}parseParens(n){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=$T(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new te(4010,!1);let o;r.indexOf(":")>-1?(o=r.slice(0,r.indexOf(":")),this.capture(o),this.capture(":")):n&&(o=ft);const i=this.parseChildren();t[o]=1===Object.keys(i).length?i[ft]:new Qt([],i),this.consumeOptional("//")}return t}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return!!this.peekStartsWith(n)&&(this.remaining=this.remaining.substring(n.length),!0)}capture(n){if(!this.consumeOptional(n))throw new te(4011,!1)}}function VU(e){return e.segments.length>0?new Qt([],{[ft]:e}):e}function BU(e){const n={};for(const[r,s]of Object.entries(e.children)){const o=BU(s);if(r===ft&&0===o.segments.length&&o.hasChildren())for(const[i,a]of Object.entries(o.children))n[i]=a;else(o.segments.length>0||o.hasChildren())&&(n[r]=o)}return function xde(e){if(1===e.numberOfChildren&&e.children[ft]){const n=e.children[ft];return new Qt(e.segments.concat(n.segments),n.children)}return e}(new Qt(e.segments,n))}function fc(e){return e instanceof dc}function zU(e){let n;const s=VU(function t(o){const i={};for(const l of o.children){const u=t(l);i[l.outlet]=u}const a=new Qt(o.url,i);return o===e&&(n=a),a}(e.root));return n??s}function UU(e,n,t,r){let s=e;for(;s.parent;)s=s.parent;if(0===n.length)return PT(s,s,s,t,r);const o=function Ide(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new HU(!0,0,e);let n=0,t=!1;const r=e.reduce((s,o,i)=>{if("object"==typeof o&&null!=o){if(o.outlets){const a={};return Object.entries(o.outlets).forEach(([l,u])=>{a[l]="string"==typeof u?u.split("/"):u}),[...s,{outlets:a}]}if(o.segmentPath)return[...s,o.segmentPath]}return"string"!=typeof o?[...s,o]:0===i?(o.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?t=!0:".."===a?n++:""!=a&&s.push(a))}),s):[...s,o]},[]);return new HU(t,n,r)}(n);if(o.toRoot())return PT(s,s,new Qt([],{}),t,r);const i=function Sde(e,n,t){if(e.isAbsolute)return new Mx(n,!0,0);if(!t)return new Mx(n,!1,NaN);if(null===t.parent)return new Mx(t,!0,0);const r=Rx(e.commands[0])?0:1;return function _de(e,n,t){let r=e,s=n,o=t;for(;o>s;){if(o-=s,r=r.parent,!r)throw new te(4005,!1);s=r.segments.length}return new Mx(r,!1,s-o)}(t,t.segments.length-1+r,e.numberOfDoubleDots)}(o,s,e),a=i.processChildren?gg(i.segmentGroup,i.index,o.commands):jU(i.segmentGroup,i.index,o.commands);return PT(s,i.segmentGroup,a,t,r)}function Rx(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function mg(e){return"object"==typeof e&&null!=e&&e.outlets}function PT(e,n,t,r,s){let i,o={};r&&Object.entries(r).forEach(([l,u])=>{o[l]=Array.isArray(u)?u.map(c=>`${c}`):`${u}`}),i=e===n?t:WU(e,n,t);const a=VU(BU(i));return new dc(a,o,s)}function WU(e,n,t){const r={};return Object.entries(e.children).forEach(([s,o])=>{r[s]=o===n?t:WU(o,n,t)}),new Qt(e.segments,r)}class HU{isAbsolute;numberOfDoubleDots;commands;constructor(n,t,r){if(this.isAbsolute=n,this.numberOfDoubleDots=t,this.commands=r,n&&r.length>0&&Rx(r[0]))throw new te(4003,!1);const s=r.find(mg);if(s&&s!==kU(r))throw new te(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Mx{segmentGroup;processChildren;index;constructor(n,t,r){this.segmentGroup=n,this.processChildren=t,this.index=r}}function jU(e,n,t){if(e??=new Qt([],{}),0===e.segments.length&&e.hasChildren())return gg(e,n,t);const r=function Dde(e,n,t){let r=0,s=n;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<e.segments.length;){if(r>=t.length)return o;const i=e.segments[s],a=t[r];if(mg(a))break;const l=`${a}`,u=r<t.length-1?t[r+1]:null;if(s>0&&void 0===l)break;if(l&&u&&"object"==typeof u&&void 0===u.outlets){if(!qU(l,u,i))return o;r+=2}else{if(!qU(l,{},i))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(e,n,t),s=t.slice(r.commandIndex);if(r.match&&r.pathIndex<e.segments.length){const o=new Qt(e.segments.slice(0,r.pathIndex),{});return o.children[ft]=new Qt(e.segments.slice(r.pathIndex),e.children),gg(o,0,s)}return r.match&&0===s.length?new Qt(e.segments,{}):r.match&&!e.hasChildren()?LT(e,n,t):r.match?gg(e,0,s):LT(e,n,t)}function gg(e,n,t){if(0===t.length)return new Qt(e.segments,{});{const r=function Ede(e){return mg(e[0])?e[0].outlets:{[ft]:e}}(t),s={};if(Object.keys(r).some(o=>o!==ft)&&e.children[ft]&&1===e.numberOfChildren&&0===e.children[ft].segments.length){const o=gg(e.children[ft],n,t);return new Qt(e.segments,o.children)}return Object.entries(r).forEach(([o,i])=>{"string"==typeof i&&(i=[i]),null!==i&&(s[o]=jU(e.children[o],n,i))}),Object.entries(e.children).forEach(([o,i])=>{void 0===r[o]&&(s[o]=i)}),new Qt(e.segments,s)}}function LT(e,n,t){const r=e.segments.slice(0,n);let s=0;for(;s<t.length;){const o=t[s];if(mg(o)){const l=Nde(o.outlets);return new Qt(r,l)}if(0===s&&Rx(t[0])){r.push(new fg(e.segments[n].path,GU(t[0]))),s++;continue}const i=mg(o)?o.outlets[ft]:`${o}`,a=s<t.length-1?t[s+1]:null;i&&a&&Rx(a)?(r.push(new fg(i,GU(a))),s+=2):(r.push(new fg(i,{})),s++)}return new Qt(r,{})}function Nde(e){const n={};return Object.entries(e).forEach(([t,r])=>{"string"==typeof r&&(r=[r]),null!==r&&(n[t]=LT(new Qt([],{}),0,r))}),n}function GU(e){const n={};return Object.entries(e).forEach(([t,r])=>n[t]=`${r}`),n}function qU(e,n,t){return e==t.path&&Ui(n,t.parameters)}const yg="imperative";var kt=function(e){return e[e.NavigationStart=0]="NavigationStart",e[e.NavigationEnd=1]="NavigationEnd",e[e.NavigationCancel=2]="NavigationCancel",e[e.NavigationError=3]="NavigationError",e[e.RoutesRecognized=4]="RoutesRecognized",e[e.ResolveStart=5]="ResolveStart",e[e.ResolveEnd=6]="ResolveEnd",e[e.GuardsCheckStart=7]="GuardsCheckStart",e[e.GuardsCheckEnd=8]="GuardsCheckEnd",e[e.RouteConfigLoadStart=9]="RouteConfigLoadStart",e[e.RouteConfigLoadEnd=10]="RouteConfigLoadEnd",e[e.ChildActivationStart=11]="ChildActivationStart",e[e.ChildActivationEnd=12]="ChildActivationEnd",e[e.ActivationStart=13]="ActivationStart",e[e.ActivationEnd=14]="ActivationEnd",e[e.Scroll=15]="Scroll",e[e.NavigationSkipped=16]="NavigationSkipped",e}(kt||{});class Wi{id;url;constructor(n,t){this.id=n,this.url=t}}class Ox extends Wi{type=kt.NavigationStart;navigationTrigger;restoredState;constructor(n,t,r="imperative",s=null){super(n,t),this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Ra extends Wi{urlAfterRedirects;type=kt.NavigationEnd;constructor(n,t,r){super(n,t),this.urlAfterRedirects=r}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}var mo=function(e){return e[e.Redirect=0]="Redirect",e[e.SupersededByNewNavigation=1]="SupersededByNewNavigation",e[e.NoDataFromResolver=2]="NoDataFromResolver",e[e.GuardRejected=3]="GuardRejected",e}(mo||{}),Fx=function(e){return e[e.IgnoredSameUrlNavigation=0]="IgnoredSameUrlNavigation",e[e.IgnoredByUrlHandlingStrategy=1]="IgnoredByUrlHandlingStrategy",e}(Fx||{});class pc extends Wi{reason;code;type=kt.NavigationCancel;constructor(n,t,r,s){super(n,t),this.reason=r,this.code=s}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Sh extends Wi{reason;code;type=kt.NavigationSkipped;constructor(n,t,r,s){super(n,t),this.reason=r,this.code=s}}class VT extends Wi{error;target;type=kt.NavigationError;constructor(n,t,r,s){super(n,t),this.error=r,this.target=s}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class KU extends Wi{urlAfterRedirects;state;type=kt.RoutesRecognized;constructor(n,t,r,s){super(n,t),this.urlAfterRedirects=r,this.state=s}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Tde extends Wi{urlAfterRedirects;state;type=kt.GuardsCheckStart;constructor(n,t,r,s){super(n,t),this.urlAfterRedirects=r,this.state=s}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class kde extends Wi{urlAfterRedirects;state;shouldActivate;type=kt.GuardsCheckEnd;constructor(n,t,r,s,o){super(n,t),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=o}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Ade extends Wi{urlAfterRedirects;state;type=kt.ResolveStart;constructor(n,t,r,s){super(n,t),this.urlAfterRedirects=r,this.state=s}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Rde extends Wi{urlAfterRedirects;state;type=kt.ResolveEnd;constructor(n,t,r,s){super(n,t),this.urlAfterRedirects=r,this.state=s}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Mde{route;type=kt.RouteConfigLoadStart;constructor(n){this.route=n}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class Ode{route;type=kt.RouteConfigLoadEnd;constructor(n){this.route=n}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Fde{snapshot;type=kt.ChildActivationStart;constructor(n){this.snapshot=n}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class $de{snapshot;type=kt.ChildActivationEnd;constructor(n){this.snapshot=n}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Pde{snapshot;type=kt.ActivationStart;constructor(n){this.snapshot=n}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Lde{snapshot;type=kt.ActivationEnd;constructor(n){this.snapshot=n}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class XU{routerEvent;position;anchor;type=kt.Scroll;constructor(n,t,r){this.routerEvent=n,this.position=t,this.anchor=r}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class BT{}class $x{url;navigationBehaviorOptions;constructor(n,t){this.url=n,this.navigationBehaviorOptions=t}}function ci(e){return e.outlet||ft}function vg(e){if(!e)return null;if(e.routeConfig?._injector)return e.routeConfig._injector;for(let n=e.parent;n;n=n.parent){const t=n.routeConfig;if(t?._loadedInjector)return t._loadedInjector;if(t?._injector)return t._injector}return null}class Hde{rootInjector;outlet=null;route=null;children;attachRef=null;get injector(){return vg(this.route?.snapshot)??this.rootInjector}constructor(n){this.rootInjector=n,this.children=new bg(this.rootInjector)}}let bg=(()=>{class e{rootInjector;contexts=new Map;constructor(t){this.rootInjector=t}onChildOutletCreated(t,r){const s=this.getOrCreateContext(t);s.outlet=r,this.contexts.set(t,s)}onChildOutletDestroyed(t){const r=this.getContext(t);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let r=this.getContext(t);return r||(r=new Hde(this.rootInjector),this.contexts.set(t,r)),r}getContext(t){return this.contexts.get(t)||null}static \u0275fac=function(r){return new(r||e)($e(ws))};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();class YU{_root;constructor(n){this._root=n}get root(){return this._root.value}parent(n){const t=this.pathFromRoot(n);return t.length>1?t[t.length-2]:null}children(n){const t=zT(n,this._root);return t?t.children.map(r=>r.value):[]}firstChild(n){const t=zT(n,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(n){const t=UT(n,this._root);return t.length<2?[]:t[t.length-2].children.map(s=>s.value).filter(s=>s!==n)}pathFromRoot(n){return UT(n,this._root).map(t=>t.value)}}function zT(e,n){if(e===n.value)return n;for(const t of n.children){const r=zT(e,t);if(r)return r}return null}function UT(e,n){if(e===n.value)return[n];for(const t of n.children){const r=UT(e,t);if(r.length)return r.unshift(n),r}return[]}class di{value;children;constructor(n,t){this.value=n,this.children=t}toString(){return`TreeNode(${this.value})`}}function _h(e){const n={};return e&&e.children.forEach(t=>n[t.value.outlet]=t),n}class ZU extends YU{snapshot;constructor(n,t){super(n),this.snapshot=t,WT(this,n)}toString(){return this.snapshot.toString()}}function QU(e){const n=function jde(e){const o=new Lx([],{},{},"",{},ft,e,null,{});return new JU("",new di(o,[]))}(e),t=new Ro([new fg("",{})]),r=new Ro({}),s=new Ro({}),o=new Ro({}),i=new Ro(""),a=new $l(t,r,o,i,s,ft,e,n.root);return a.snapshot=n.root,new ZU(new di(a,[]),n)}class $l{urlSubject;paramsSubject;queryParamsSubject;fragmentSubject;dataSubject;outlet;component;snapshot;_futureSnapshot;_routerState;_paramMap;_queryParamMap;title;url;params;queryParams;fragment;data;constructor(n,t,r,s,o,i,a,l){this.urlSubject=n,this.paramsSubject=t,this.queryParamsSubject=r,this.fragmentSubject=s,this.dataSubject=o,this.outlet=i,this.component=a,this._futureSnapshot=l,this.title=this.dataSubject?.pipe(Rt(u=>u[hg]))??Qe(void 0),this.url=n,this.params=t,this.queryParams=r,this.fragment=s,this.data=o}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=this.params.pipe(Rt(n=>Ch(n))),this._paramMap}get queryParamMap(){return this._queryParamMap??=this.queryParams.pipe(Rt(n=>Ch(n))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Px(e,n,t="emptyOnly"){let r;const{routeConfig:s}=e;return r=null===n||"always"!==t&&""!==s?.path&&(n.component||n.routeConfig?.loadComponent)?{params:{...e.params},data:{...e.data},resolve:{...e.data,...e._resolvedData??{}}}:{params:{...n.params,...e.params},data:{...n.data,...e.data},resolve:{...e.data,...n.data,...s?.data,...e._resolvedData}},s&&tW(s)&&(r.resolve[hg]=s.title),r}class Lx{url;params;queryParams;fragment;data;outlet;component;routeConfig;_resolve;_resolvedData;_routerState;_paramMap;_queryParamMap;get title(){return this.data?.[hg]}constructor(n,t,r,s,o,i,a,l,u){this.url=n,this.params=t,this.queryParams=r,this.fragment=s,this.data=o,this.outlet=i,this.component=a,this.routeConfig=l,this._resolve=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=Ch(this.params),this._paramMap}get queryParamMap(){return this._queryParamMap??=Ch(this.queryParams),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class JU extends YU{url;constructor(n,t){super(t),this.url=n,WT(this,t)}toString(){return eW(this._root)}}function WT(e,n){n.value._routerState=e,n.children.forEach(t=>WT(e,t))}function eW(e){const n=e.children.length>0?` { ${e.children.map(eW).join(", ")} } `:"";return`${e.value}${n}`}function HT(e){if(e.snapshot){const n=e.snapshot,t=e._futureSnapshot;e.snapshot=t,Ui(n.queryParams,t.queryParams)||e.queryParamsSubject.next(t.queryParams),n.fragment!==t.fragment&&e.fragmentSubject.next(t.fragment),Ui(n.params,t.params)||e.paramsSubject.next(t.params),function rde(e,n){if(e.length!==n.length)return!1;for(let t=0;t<e.length;++t)if(!Ui(e[t],n[t]))return!1;return!0}(n.url,t.url)||e.urlSubject.next(t.url),Ui(n.data,t.data)||e.dataSubject.next(t.data)}else e.snapshot=e._futureSnapshot,e.dataSubject.next(e._futureSnapshot.data)}function jT(e,n){const t=Ui(e.params,n.params)&&function ade(e,n){return hc(e,n)&&e.every((t,r)=>Ui(t.parameters,n[r].parameters))}(e.url,n.url);return t&&!(!e.parent!=!n.parent)&&(!e.parent||jT(e.parent,n.parent))}function tW(e){return"string"==typeof e.title||null===e.title}const Gde=new fe("");let GT=(()=>{class e{activated=null;get activatedComponentRef(){return this.activated}_activatedRoute=null;name=ft;activateEvents=new or;deactivateEvents=new or;attachEvents=new or;detachEvents=new or;routerOutletData=b7(void 0);parentContexts=Z(bg);location=Z(ri);changeDetector=Z(Xm);inputBinder=Z(Vx,{optional:!0});supportsBindingToComponentInputs=!0;ngOnChanges(t){if(t.name){const{firstChange:r,previousValue:s}=t.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(t){return this.parentContexts.getContext(t)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const t=this.parentContexts.getContext(this.name);t?.route&&(t.attachRef?this.attach(t.attachRef,t.route):this.activateWith(t.route,t.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new te(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new te(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new te(4012,!1);this.location.detach();const t=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(t.instance),t}attach(t,r){this.activated=t,this._activatedRoute=r,this.location.insert(t.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(t.instance)}deactivate(){if(this.activated){const t=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(t)}}activateWith(t,r){if(this.isActivated)throw new te(4013,!1);this._activatedRoute=t;const s=this.location,i=t.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new qT(t,a,s.injector,this.routerOutletData);this.activated=s.createComponent(i,{index:s.length,injector:l,environmentInjector:r}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}static \u0275fac=function(r){return new(r||e)};static \u0275dir=Je({type:e,selectors:[["router-outlet"]],inputs:{name:"name",routerOutletData:[1,"routerOutletData"]},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],features:[Jo]})}return e})();class qT{route;childContexts;parent;outletData;__ngOutletInjector(n){return new qT(this.route,this.childContexts,n,this.outletData)}constructor(n,t,r,s){this.route=n,this.childContexts=t,this.parent=r,this.outletData=s}get(n,t){return n===$l?this.route:n===bg?this.childContexts:n===Gde?this.outletData:this.parent.get(n,t)}}const Vx=new fe("");let nW=(()=>{class e{outletDataSubscriptions=new Map;bindActivatedRouteToOutletComponent(t){this.unsubscribeFromRouteData(t),this.subscribeToRouteData(t)}unsubscribeFromRouteData(t){this.outletDataSubscriptions.get(t)?.unsubscribe(),this.outletDataSubscriptions.delete(t)}subscribeToRouteData(t){const{activatedRoute:r}=t,s=kT([r.queryParams,r.params,r.data]).pipe(ui(([o,i,a],l)=>(a={...o,...i,...a},0===l?Qe(a):Promise.resolve(a)))).subscribe(o=>{if(!t.isActivated||!t.activatedComponentRef||t.activatedRoute!==r||null===r.component)return void this.unsubscribeFromRouteData(t);const i=function Lie(e){const n=dt(e);if(!n)return null;const t=new _m(n);return{get selector(){return t.selector},get type(){return t.componentType},get inputs(){return t.inputs},get outputs(){return t.outputs},get ngContentSelectors(){return t.ngContentSelectors},get isStandalone(){return n.standalone},get isSignal(){return n.signals}}}(r.component);if(i)for(const{templateName:a}of i.inputs)t.activatedComponentRef.setInput(a,o[a]);else this.unsubscribeFromRouteData(t)});this.outletDataSubscriptions.set(t,s)}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();function wg(e,n,t){if(t&&e.shouldReuseRoute(n.value,t.value.snapshot)){const r=t.value;r._futureSnapshot=n.value;const s=function Kde(e,n,t){return n.children.map(r=>{for(const s of t.children)if(e.shouldReuseRoute(r.value,s.value.snapshot))return wg(e,r,s);return wg(e,r)})}(e,n,t);return new di(r,s)}{if(e.shouldAttach(n.value)){const o=e.retrieve(n.value);if(null!==o){const i=o.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>wg(e,a)),i}}const r=function Xde(e){return new $l(new Ro(e.url),new Ro(e.params),new Ro(e.queryParams),new Ro(e.fragment),new Ro(e.data),e.outlet,e.component,e)}(n.value),s=n.children.map(o=>wg(e,o));return new di(r,s)}}class KT{redirectTo;navigationBehaviorOptions;constructor(n,t){this.redirectTo=n,this.navigationBehaviorOptions=t}}const rW="ngNavigationCancelingError";function Bx(e,n){const{redirectTo:t,navigationBehaviorOptions:r}=fc(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,s=sW(!1,mo.Redirect);return s.url=t,s.navigationBehaviorOptions=r,s}function sW(e,n){const t=new Error(`NavigationCancelingError: ${e||""}`);return t[rW]=!0,t.cancellationCode=n,t}function oW(e){return!!e&&e[rW]}class Qde{routeReuseStrategy;futureState;currState;forwardEvent;inputBindingEnabled;constructor(n,t,r,s,o){this.routeReuseStrategy=n,this.futureState=t,this.currState=r,this.forwardEvent=s,this.inputBindingEnabled=o}activate(n){const t=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,r,n),HT(this.futureState.root),this.activateChildRoutes(t,r,n)}deactivateChildRoutes(n,t,r){const s=_h(t);n.children.forEach(o=>{const i=o.value.outlet;this.deactivateRoutes(o,s[i],r),delete s[i]}),Object.values(s).forEach(o=>{this.deactivateRouteAndItsChildren(o,r)})}deactivateRoutes(n,t,r){const s=n.value,o=t?t.value:null;if(s===o)if(s.component){const i=r.getContext(s.outlet);i&&this.deactivateChildRoutes(n,t,i.children)}else this.deactivateChildRoutes(n,t,r);else o&&this.deactivateRouteAndItsChildren(t,r)}deactivateRouteAndItsChildren(n,t){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,t):this.deactivateRouteAndOutlet(n,t)}detachAndStoreRouteSubtree(n,t){const r=t.getContext(n.value.outlet),s=r&&n.value.component?r.children:t,o=_h(n);for(const i of Object.values(o))this.deactivateRouteAndItsChildren(i,s);if(r&&r.outlet){const i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,t){const r=t.getContext(n.value.outlet),s=r&&n.value.component?r.children:t,o=_h(n);for(const i of Object.values(o))this.deactivateRouteAndItsChildren(i,s);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(n,t,r){const s=_h(t);n.children.forEach(o=>{this.activateRoutes(o,s[o.value.outlet],r),this.forwardEvent(new Lde(o.value.snapshot))}),n.children.length&&this.forwardEvent(new $de(n.value.snapshot))}activateRoutes(n,t,r){const s=n.value,o=t?t.value:null;if(HT(s),s===o)if(s.component){const i=r.getOrCreateContext(s.outlet);this.activateChildRoutes(n,t,i.children)}else this.activateChildRoutes(n,t,r);else if(s.component){const i=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),HT(a.route.value),this.activateChildRoutes(n,null,i.children)}else i.attachRef=null,i.route=s,i.outlet&&i.outlet.activateWith(s,i.injector),this.activateChildRoutes(n,null,i.children)}else this.activateChildRoutes(n,null,r)}}class iW{path;route;constructor(n){this.path=n,this.route=this.path[this.path.length-1]}}class zx{component;route;constructor(n,t){this.component=n,this.route=t}}function Jde(e,n,t){const r=e._root;return xg(r,n?n._root:null,t,[r.value])}function Eh(e,n){const t=Symbol(),r=n.get(e,t);return r===t?"function"!=typeof e||function EX(e){return null!==eb(e)}(e)?n.get(e):e:r}function xg(e,n,t,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=_h(n);return e.children.forEach(i=>{(function the(e,n,t,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=e.value,i=n?n.value:null,a=t?t.getContext(e.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const l=function nhe(e,n,t){if("function"==typeof t)return t(e,n);switch(t){case"pathParamsChange":return!hc(e.url,n.url);case"pathParamsOrQueryParamsChange":return!hc(e.url,n.url)||!Ui(e.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!jT(e,n)||!Ui(e.queryParams,n.queryParams);default:return!jT(e,n)}}(i,o,o.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new iW(r)):(o.data=i.data,o._resolvedData=i._resolvedData),xg(e,n,o.component?a?a.children:null:t,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new zx(a.outlet.component,i))}else i&&Cg(n,a,s),s.canActivateChecks.push(new iW(r)),xg(e,null,o.component?a?a.children:null:t,r,s)})(i,o[i.value.outlet],t,r.concat([i.value]),s),delete o[i.value.outlet]}),Object.entries(o).forEach(([i,a])=>Cg(a,t.getContext(i),s)),s}function Cg(e,n,t){const r=_h(e),s=e.value;Object.entries(r).forEach(([o,i])=>{Cg(i,s.component?n?n.children.getContext(o):null:n,t)}),t.canDeactivateChecks.push(new zx(s.component&&n&&n.outlet&&n.outlet.isActivated?n.outlet.component:null,s))}function Ig(e){return"function"==typeof e}function aW(e){return e instanceof Sx||"EmptyError"===e?.name}const Ux=Symbol("INITIAL_VALUE");function Dh(){return ui(e=>kT(e.map(n=>n.pipe(wh(1),function Xce(...e){const n=vx(e);return Kr((t,r)=>{(n?AT(e,t,n):AT(e,t)).subscribe(r)})}(Ux)))).pipe(Rt(n=>{for(const t of n)if(!0!==t){if(t===Ux)return Ux;if(!1===t||uhe(t))return t}return!0}),Aa(n=>n!==Ux),wh(1)))}function uhe(e){return fc(e)||e instanceof KT}function lW(e){return function gX(...e){return _O(e)}(Ds(n=>{if("boolean"!=typeof n)throw Bx(0,n)}),Rt(n=>!0===n))}class XT{segmentGroup;constructor(n){this.segmentGroup=n||null}}class Wx extends Error{urlTree;constructor(n){super(),this.urlTree=n}}function Nh(e){return _x(new XT(e))}class Che{urlSerializer;urlTree;constructor(n,t){this.urlSerializer=n,this.urlTree=t}lineralizeSegments(n,t){let r=[],s=t.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return Qe(r);if(s.numberOfChildren>1||!s.children[ft])return _x(new te(4e3,!1));s=s.children[ft]}}applyRedirectCommands(n,t,r,s,o){if("string"!=typeof t){const a=t,{queryParams:l,fragment:u,routeConfig:c,url:d,outlet:h,params:f,data:p,title:m}=s,g=Oo(o,()=>a({params:f,data:p,queryParams:l,fragment:u,routeConfig:c,url:d,outlet:h,title:m}));if(g instanceof dc)throw new Wx(g);t=g}const i=this.applyRedirectCreateUrlTree(t,this.urlSerializer.parse(t),n,r);if("/"===t[0])throw new Wx(i);return i}applyRedirectCreateUrlTree(n,t,r,s){const o=this.createSegmentGroup(n,t.root,r,s);return new dc(o,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(n,t){const r={};return Object.entries(n).forEach(([s,o])=>{if("string"==typeof o&&":"===o[0]){const a=o.substring(1);r[s]=t[a]}else r[s]=o}),r}createSegmentGroup(n,t,r,s){const o=this.createSegments(n,t.segments,r,s);let i={};return Object.entries(t.children).forEach(([a,l])=>{i[a]=this.createSegmentGroup(n,l,r,s)}),new Qt(o,i)}createSegments(n,t,r,s){return t.map(o=>":"===o.path[0]?this.findPosParam(n,o,s):this.findOrReturn(o,r))}findPosParam(n,t,r){const s=r[t.path.substring(1)];if(!s)throw new te(4001,!1);return s}findOrReturn(n,t){let r=0;for(const s of t){if(s.path===n.path)return t.splice(r),s;r++}return n}}const YT={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function Ihe(e,n,t,r,s){const o=uW(e,n,t);return o.matched?(r=function Vde(e,n){return e.providers&&!e._injector&&(e._injector=vw(e.providers,n,`Route: ${e.path}`)),e._injector??n}(n,r),function bhe(e,n,t,r){const s=n.canMatch;return s&&0!==s.length?Qe(s.map(i=>{const a=Eh(i,e);return Fl(function lhe(e){return e&&Ig(e.canMatch)}(a)?a.canMatch(n,t):Oo(e,()=>a(n,t)))})).pipe(Dh(),lW()):Qe(!0)}(r,n,t).pipe(Rt(i=>!0===i?o:{...YT}))):Qe(o)}function uW(e,n,t){if("**"===n.path)return function She(e){return{matched:!0,parameters:e.length>0?kU(e).parameters:{},consumedSegments:e,remainingSegments:[],positionalParamSegments:{}}}(t);if(""===n.path)return"full"===n.pathMatch&&(e.hasChildren()||t.length>0)?{...YT}:{matched:!0,consumedSegments:[],remainingSegments:t,parameters:{},positionalParamSegments:{}};const s=(n.matcher||nde)(t,e,n);if(!s)return{...YT};const o={};Object.entries(s.posParams??{}).forEach(([a,l])=>{o[a]=l.path});const i=s.consumed.length>0?{...o,...s.consumed[s.consumed.length-1].parameters}:o;return{matched:!0,consumedSegments:s.consumed,remainingSegments:t.slice(s.consumed.length),parameters:i,positionalParamSegments:s.posParams??{}}}function cW(e,n,t,r){return t.length>0&&function Dhe(e,n,t){return t.some(r=>Hx(e,n,r)&&ci(r)!==ft)}(e,t,r)?{segmentGroup:new Qt(n,Ehe(r,new Qt(t,e.children))),slicedSegments:[]}:0===t.length&&function Nhe(e,n,t){return t.some(r=>Hx(e,n,r))}(e,t,r)?{segmentGroup:new Qt(e.segments,_he(e,t,r,e.children)),slicedSegments:t}:{segmentGroup:new Qt(e.segments,e.children),slicedSegments:t}}function _he(e,n,t,r){const s={};for(const o of t)if(Hx(e,n,o)&&!r[ci(o)]){const i=new Qt([],{});s[ci(o)]=i}return{...r,...s}}function Ehe(e,n){const t={};t[ft]=n;for(const r of e)if(""===r.path&&ci(r)!==ft){const s=new Qt([],{});t[ci(r)]=s}return t}function Hx(e,n,t){return(!(e.hasChildren()||n.length>0)||"full"!==t.pathMatch)&&""===t.path}class khe{}class Mhe{injector;configLoader;rootComponentType;config;urlTree;paramsInheritanceStrategy;urlSerializer;applyRedirects;absoluteRedirectCount=0;allowRedirects=!0;constructor(n,t,r,s,o,i,a){this.injector=n,this.configLoader=t,this.rootComponentType=r,this.config=s,this.urlTree=o,this.paramsInheritanceStrategy=i,this.urlSerializer=a,this.applyRedirects=new Che(this.urlSerializer,this.urlTree)}noMatchError(n){return new te(4002,`'${n.segmentGroup}'`)}recognize(){const n=cW(this.urlTree.root,[],[],this.config).segmentGroup;return this.match(n).pipe(Rt(({children:t,rootSnapshot:r})=>{const s=new di(r,t),o=new JU("",s),i=function Cde(e,n,t=null,r=null){return UU(zU(e),n,t,r)}(r,[],this.urlTree.queryParams,this.urlTree.fragment);return i.queryParams=this.urlTree.queryParams,o.url=this.urlSerializer.serialize(i),{state:o,tree:i}}))}match(n){const t=new Lx([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,Object.freeze({}),ft,this.rootComponentType,null,{});return this.processSegmentGroup(this.injector,this.config,n,ft,t).pipe(Rt(r=>({children:r,rootSnapshot:t})),xh(r=>{if(r instanceof Wx)return this.urlTree=r.urlTree,this.match(r.urlTree.root);throw r instanceof XT?this.noMatchError(r):r}))}processSegmentGroup(n,t,r,s,o){return 0===r.segments.length&&r.hasChildren()?this.processChildren(n,t,r,o):this.processSegment(n,t,r,r.segments,s,!0,o).pipe(Rt(i=>i instanceof di?[i]:[]))}processChildren(n,t,r,s){const o=[];for(const i of Object.keys(r.children))"primary"===i?o.unshift(i):o.push(i);return Sr(o).pipe(yh(i=>{const a=r.children[i],l=function Wde(e,n){const t=e.filter(r=>ci(r)===n);return t.push(...e.filter(r=>ci(r)!==n)),t}(t,i);return this.processSegmentGroup(n,l,a,i,s)}),function Qce(e,n){return Kr(function Zce(e,n,t,r,s){return(o,i)=>{let a=t,l=n,u=0;o.subscribe(yr(i,c=>{const d=u++;l=a?e(l,c,d):(a=!0,c),r&&i.next(l)},s&&(()=>{a&&i.next(l),i.complete()})))}}(e,n,arguments.length>=2,!0))}((i,a)=>(i.push(...a),i)),Ex(null),function Jce(e,n){const t=arguments.length>=2;return r=>r.pipe(e?Aa((s,o)=>e(s,o,r)):Du,MT(1),t?Ex(n):NU(()=>new Sx))}(),as(i=>{if(null===i)return Nh(r);const a=dW(i);return function Ohe(e){e.sort((n,t)=>n.value.outlet===ft?-1:t.value.outlet===ft?1:n.value.outlet.localeCompare(t.value.outlet))}(a),Qe(a)}))}processSegment(n,t,r,s,o,i,a){return Sr(t).pipe(yh(l=>this.processSegmentAgainstRoute(l._injector??n,t,l,r,s,o,i,a).pipe(xh(u=>{if(u instanceof XT)return Qe(null);throw u}))),cc(l=>!!l),xh(l=>{if(aW(l))return function The(e,n,t){return 0===n.length&&!e.children[t]}(r,s,o)?Qe(new khe):Nh(r);throw l}))}processSegmentAgainstRoute(n,t,r,s,o,i,a,l){return ci(r)===i||i!==ft&&Hx(s,o,r)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(n,s,r,o,i,l):this.allowRedirects&&a?this.expandSegmentAgainstRouteUsingRedirect(n,s,t,r,o,i,l):Nh(s):Nh(s)}expandSegmentAgainstRouteUsingRedirect(n,t,r,s,o,i,a){const{matched:l,parameters:u,consumedSegments:c,positionalParamSegments:d,remainingSegments:h}=uW(t,s,o);if(!l)return Nh(t);"string"==typeof s.redirectTo&&"/"===s.redirectTo[0]&&(this.absoluteRedirectCount++,this.absoluteRedirectCount>31&&(this.allowRedirects=!1));const f=new Lx(o,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,hW(s),ci(s),s.component??s._loadedComponent??null,s,fW(s)),p=Px(f,a,this.paramsInheritanceStrategy);f.params=Object.freeze(p.params),f.data=Object.freeze(p.data);const m=this.applyRedirects.applyRedirectCommands(c,s.redirectTo,d,f,n);return this.applyRedirects.lineralizeSegments(s,m).pipe(as(g=>this.processSegment(n,r,t,g.concat(h),i,!1,a)))}matchSegmentAgainstRoute(n,t,r,s,o,i){const a=Ihe(t,r,s,n);return"**"===r.path&&(t.children={}),a.pipe(ui(l=>l.matched?this.getChildConfig(n=r._injector??n,r,s).pipe(ui(({routes:u})=>{const c=r._loadedInjector??n,{parameters:d,consumedSegments:h,remainingSegments:f}=l,p=new Lx(h,d,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,hW(r),ci(r),r.component??r._loadedComponent??null,r,fW(r)),m=Px(p,i,this.paramsInheritanceStrategy);p.params=Object.freeze(m.params),p.data=Object.freeze(m.data);const{segmentGroup:g,slicedSegments:y}=cW(t,h,f,u);if(0===y.length&&g.hasChildren())return this.processChildren(c,u,g,p).pipe(Rt(b=>new di(p,b)));if(0===u.length&&0===y.length)return Qe(new di(p,[]));const v=ci(r)===o;return this.processSegment(c,u,g,y,v?ft:o,!0,p).pipe(Rt(b=>new di(p,b instanceof di?[b]:[])))})):Nh(t)))}getChildConfig(n,t,r){return t.children?Qe({routes:t.children,injector:n}):t.loadChildren?void 0!==t._loadedRoutes?Qe({routes:t._loadedRoutes,injector:t._loadedInjector}):function vhe(e,n,t,r){const s=n.canLoad;return void 0===s||0===s.length?Qe(!0):Qe(s.map(i=>{const a=Eh(i,e);return Fl(function she(e){return e&&Ig(e.canLoad)}(a)?a.canLoad(n,t):Oo(e,()=>a(n,t)))})).pipe(Dh(),lW())}(n,t,r).pipe(as(s=>s?this.configLoader.loadChildren(n,t).pipe(Ds(o=>{t._loadedRoutes=o.routes,t._loadedInjector=o.injector})):function xhe(){return _x(sW(!1,mo.GuardRejected))}())):Qe({routes:[],injector:n})}}function Fhe(e){const n=e.value.routeConfig;return n&&""===n.path}function dW(e){const n=[],t=new Set;for(const r of e){if(!Fhe(r)){n.push(r);continue}const s=n.find(o=>r.value.routeConfig===o.value.routeConfig);void 0!==s?(s.children.push(...r.children),t.add(s)):n.push(r)}for(const r of t){const s=dW(r.children);n.push(new di(r.value,s))}return n.filter(r=>!t.has(r))}function hW(e){return e.data||{}}function fW(e){return e.resolve||{}}function pW(e){const n=e.children.map(t=>pW(t)).flat();return[e,...n]}function ZT(e){return ui(n=>{const t=e(n);return t?Sr(t).pipe(Rt(()=>n)):Qe(n)})}let mW=(()=>{class e{buildTitle(t){let r,s=t.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(o=>o.outlet===ft);return r}getResolvedTitleForRoute(t){return t.data[hg]}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>Z(zhe),providedIn:"root"})}return e})(),zhe=(()=>{class e extends mW{title;constructor(t){super(),this.title=t}updateTitle(t){const r=this.buildTitle(t);void 0!==r&&this.title.setTitle(r)}static \u0275fac=function(r){return new(r||e)($e(aue))};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const Th=new fe("",{providedIn:"root",factory:()=>({})});let gW=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275cmp=Cl({type:e,selectors:[["ng-component"]],exportAs:["emptyRouterOutlet"],decls:1,vars:0,template:function(r,s){1&r&&rc(0,"router-outlet")},dependencies:[GT],encapsulation:2})}return e})();function QT(e){const n=e.children&&e.children.map(QT),t=n?{...e,children:n}:{...e};return!t.component&&!t.loadComponent&&(n||t.loadChildren)&&t.outlet&&t.outlet!==ft&&(t.component=gW),t}const kh=new fe("");let JT=(()=>{class e{componentLoaders=new WeakMap;childrenLoaders=new WeakMap;onLoadStartListener;onLoadEndListener;compiler=Z(GB);loadComponent(t){if(this.componentLoaders.get(t))return this.componentLoaders.get(t);if(t._loadedComponent)return Qe(t._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(t);const r=Fl(t.loadComponent()).pipe(Rt(yW),Ds(o=>{this.onLoadEndListener&&this.onLoadEndListener(t),t._loadedComponent=o}),ag(()=>{this.componentLoaders.delete(t)})),s=new DU(r,()=>new Ls).pipe(RT());return this.componentLoaders.set(t,s),s}loadChildren(t,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Qe({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const o=function Uhe(e,n,t,r){return Fl(e.loadChildren()).pipe(Rt(yW),as(s=>s instanceof lL||Array.isArray(s)?Qe(s):Sr(n.compileModuleAsync(s))),Rt(s=>{r&&r(e);let o,i,a=!1;return Array.isArray(s)?(i=s,!0):(o=s.create(t).injector,i=o.get(kh,[],{optional:!0,self:!0}).flat()),{routes:i.map(QT),injector:o}}))}(r,this.compiler,t,this.onLoadEndListener).pipe(ag(()=>{this.childrenLoaders.delete(r)})),i=new DU(o,()=>new Ls).pipe(RT());return this.childrenLoaders.set(r,i),i}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function yW(e){return function Whe(e){return e&&"object"==typeof e&&"default"in e}(e)?e.default:e}let e1=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>Z(Hhe),providedIn:"root"})}return e})(),Hhe=(()=>{class e{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,r){return t}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const vW=new fe(""),bW=new fe("");function jhe(e,n,t){const r=e.get(bW),s=e.get(fo);return e.get(Vt).runOutsideAngular(()=>{if(!s.startViewTransition||r.skipNextTransition)return r.skipNextTransition=!1,new Promise(u=>setTimeout(u));let o;const i=new Promise(u=>{o=u}),a=s.startViewTransition(()=>(o(),function Ghe(e){return new Promise(n=>{Yp({read:()=>setTimeout(n)},{injector:e})})}(e))),{onViewTransitionCreated:l}=r;return l&&Oo(e,()=>l({transition:a,from:n,to:t})),i})}const t1=new fe("");let jx=(()=>{class e{currentNavigation=null;currentTransition=null;lastSuccessfulNavigation=null;events=new Ls;transitionAbortSubject=new Ls;configLoader=Z(JT);environmentInjector=Z(ws);urlSerializer=Z(Ih);rootContexts=Z(bg);location=Z(tg);inputBindingEnabled=null!==Z(Vx,{optional:!0});titleStrategy=Z(mW);options=Z(Th,{optional:!0})||{};paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly";urlHandlingStrategy=Z(e1);createViewTransition=Z(vW,{optional:!0});navigationErrorHandler=Z(t1,{optional:!0});navigationId=0;get hasRequestedNavigation(){return 0!==this.navigationId}transitions;afterPreactivation=()=>Qe(void 0);rootComponentType=null;constructor(){this.configLoader.onLoadEndListener=s=>this.events.next(new Ode(s)),this.configLoader.onLoadStartListener=s=>this.events.next(new Mde(s))}complete(){this.transitions?.complete()}handleNavigationRequest(t){const r=++this.navigationId;this.transitions?.next({...this.transitions.value,...t,id:r})}setupNavigations(t,r,s){return this.transitions=new Ro({id:0,currentUrlTree:r,currentRawUrl:r,extractedUrl:this.urlHandlingStrategy.extract(r),urlAfterRedirects:this.urlHandlingStrategy.extract(r),rawUrl:r,extras:{},resolve:()=>{},reject:()=>{},promise:Promise.resolve(!0),source:yg,restoredState:null,currentSnapshot:s.snapshot,targetSnapshot:null,currentRouterState:s,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe(Aa(o=>0!==o.id),Rt(o=>({...o,extractedUrl:this.urlHandlingStrategy.extract(o.rawUrl)})),ui(o=>{let i=!1,a=!1;return Qe(o).pipe(ui(l=>{if(this.navigationId>o.id)return this.cancelNavigationTransition(o,"",mo.SupersededByNewNavigation),zi;this.currentTransition=o,this.currentNavigation={id:l.id,initialUrl:l.rawUrl,extractedUrl:l.extractedUrl,targetBrowserUrl:"string"==typeof l.extras.browserUrl?this.urlSerializer.parse(l.extras.browserUrl):l.extras.browserUrl,trigger:l.source,extras:l.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null};const u=!t.navigated||this.isUpdatingInternalState()||this.isUpdatedBrowserUrl();if(!u&&"reload"!==(l.extras.onSameUrlNavigation??t.onSameUrlNavigation)){const d="";return this.events.next(new Sh(l.id,this.urlSerializer.serialize(l.rawUrl),d,Fx.IgnoredSameUrlNavigation)),l.resolve(!1),zi}if(this.urlHandlingStrategy.shouldProcessUrl(l.rawUrl))return Qe(l).pipe(ui(d=>{const h=this.transitions?.getValue();return this.events.next(new Ox(d.id,this.urlSerializer.serialize(d.extractedUrl),d.source,d.restoredState)),h!==this.transitions?.getValue()?zi:Promise.resolve(d)}),function $he(e,n,t,r,s,o){return as(i=>function Ahe(e,n,t,r,s,o,i="emptyOnly"){return new Mhe(e,n,t,r,s,i,o).recognize()}(e,n,t,r,i.extractedUrl,s,o).pipe(Rt(({state:a,tree:l})=>({...i,targetSnapshot:a,urlAfterRedirects:l}))))}(this.environmentInjector,this.configLoader,this.rootComponentType,t.config,this.urlSerializer,this.paramsInheritanceStrategy),Ds(d=>{o.targetSnapshot=d.targetSnapshot,o.urlAfterRedirects=d.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:d.urlAfterRedirects};const h=new KU(d.id,this.urlSerializer.serialize(d.extractedUrl),this.urlSerializer.serialize(d.urlAfterRedirects),d.targetSnapshot);this.events.next(h)}));if(u&&this.urlHandlingStrategy.shouldProcessUrl(l.currentRawUrl)){const{id:d,extractedUrl:h,source:f,restoredState:p,extras:m}=l,g=new Ox(d,this.urlSerializer.serialize(h),f,p);this.events.next(g);const y=QU(this.rootComponentType).snapshot;return this.currentTransition=o={...l,targetSnapshot:y,urlAfterRedirects:h,extras:{...m,skipLocationChange:!1,replaceUrl:!1}},this.currentNavigation.finalUrl=h,Qe(o)}{const d="";return this.events.next(new Sh(l.id,this.urlSerializer.serialize(l.extractedUrl),d,Fx.IgnoredByUrlHandlingStrategy)),l.resolve(!1),zi}}),Ds(l=>{const u=new Tde(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot);this.events.next(u)}),Rt(l=>(this.currentTransition=o={...l,guards:Jde(l.targetSnapshot,l.currentSnapshot,this.rootContexts)},o)),function che(e,n){return as(t=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=t;return 0===i.length&&0===o.length?Qe({...t,guardsResult:!0}):function dhe(e,n,t,r){return Sr(e).pipe(as(s=>function yhe(e,n,t,r,s){const o=n&&n.routeConfig?n.routeConfig.canDeactivate:null;return o&&0!==o.length?Qe(o.map(a=>{const l=vg(n)??s,u=Eh(a,l);return Fl(function ahe(e){return e&&Ig(e.canDeactivate)}(u)?u.canDeactivate(e,n,t,r):Oo(l,()=>u(e,n,t,r))).pipe(cc())})).pipe(Dh()):Qe(!0)}(s.component,s.route,t,n,r)),cc(s=>!0!==s,!0))}(i,r,s,e).pipe(as(a=>a&&function rhe(e){return"boolean"==typeof e}(a)?function hhe(e,n,t,r){return Sr(n).pipe(yh(s=>AT(function phe(e,n){return null!==e&&n&&n(new Fde(e)),Qe(!0)}(s.route.parent,r),function fhe(e,n){return null!==e&&n&&n(new Pde(e)),Qe(!0)}(s.route,r),function ghe(e,n,t){const r=n[n.length-1],o=n.slice(0,n.length-1).reverse().map(i=>function ehe(e){const n=e.routeConfig?e.routeConfig.canActivateChild:null;return n&&0!==n.length?{node:e,guards:n}:null}(i)).filter(i=>null!==i).map(i=>EU(()=>Qe(i.guards.map(l=>{const u=vg(i.node)??t,c=Eh(l,u);return Fl(function ihe(e){return e&&Ig(e.canActivateChild)}(c)?c.canActivateChild(r,e):Oo(u,()=>c(r,e))).pipe(cc())})).pipe(Dh())));return Qe(o).pipe(Dh())}(e,s.path,t),function mhe(e,n,t){const r=n.routeConfig?n.routeConfig.canActivate:null;if(!r||0===r.length)return Qe(!0);const s=r.map(o=>EU(()=>{const i=vg(n)??t,a=Eh(o,i);return Fl(function ohe(e){return e&&Ig(e.canActivate)}(a)?a.canActivate(n,e):Oo(i,()=>a(n,e))).pipe(cc())}));return Qe(s).pipe(Dh())}(e,s.route,t))),cc(s=>!0!==s,!0))}(r,o,e,n):Qe(a)),Rt(a=>({...t,guardsResult:a})))})}(this.environmentInjector,l=>this.events.next(l)),Ds(l=>{if(o.guardsResult=l.guardsResult,l.guardsResult&&"boolean"!=typeof l.guardsResult)throw Bx(0,l.guardsResult);const u=new kde(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects),l.targetSnapshot,!!l.guardsResult);this.events.next(u)}),Aa(l=>!!l.guardsResult||(this.cancelNavigationTransition(l,"",mo.GuardRejected),!1)),ZT(l=>{if(l.guards.canActivateChecks.length)return Qe(l).pipe(Ds(u=>{const c=new Ade(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}),ui(u=>{let c=!1;return Qe(u).pipe(function Phe(e,n){return as(t=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=t;if(!s.length)return Qe(t);const o=new Set(s.map(l=>l.route)),i=new Set;for(const l of o)if(!i.has(l))for(const u of pW(l))i.add(u);let a=0;return Sr(i).pipe(yh(l=>o.has(l)?function Lhe(e,n,t,r){const s=e.routeConfig,o=e._resolve;return void 0!==s?.title&&!tW(s)&&(o[hg]=s.title),function Vhe(e,n,t,r){const s=OT(e);if(0===s.length)return Qe({});const o={};return Sr(s).pipe(as(i=>function Bhe(e,n,t,r){const s=vg(n)??r,o=Eh(e,s);return Fl(o.resolve?o.resolve(n,t):Oo(s,()=>o(n,t)))}(e[i],n,t,r).pipe(cc(),Ds(a=>{if(a instanceof KT)throw Bx(new Nx,a);o[i]=a}))),MT(1),Rt(()=>o),xh(i=>aW(i)?zi:_x(i)))}(o,e,n,r).pipe(Rt(i=>(e._resolvedData=i,e.data=Px(e,e.parent,t).resolve,null)))}(l,r,e,n):(l.data=Px(l,l.parent,e).resolve,Qe(void 0))),Ds(()=>a++),MT(1),as(l=>a===i.size?Qe(t):zi))})}(this.paramsInheritanceStrategy,this.environmentInjector),Ds({next:()=>c=!0,complete:()=>{c||this.cancelNavigationTransition(u,"",mo.NoDataFromResolver)}}))}),Ds(u=>{const c=new Rde(u.id,this.urlSerializer.serialize(u.extractedUrl),this.urlSerializer.serialize(u.urlAfterRedirects),u.targetSnapshot);this.events.next(c)}))}),ZT(l=>{const u=c=>{const d=[];c.routeConfig?.loadComponent&&!c.routeConfig._loadedComponent&&d.push(this.configLoader.loadComponent(c.routeConfig).pipe(Ds(h=>{c.component=h}),Rt(()=>{})));for(const h of c.children)d.push(...u(h));return d};return kT(u(l.targetSnapshot.root)).pipe(Ex(null),wh(1))}),ZT(()=>this.afterPreactivation()),ui(()=>{const{currentSnapshot:l,targetSnapshot:u}=o,c=this.createViewTransition?.(this.environmentInjector,l.root,u.root);return c?Sr(c).pipe(Rt(()=>o)):Qe(o)}),Rt(l=>{const u=function qde(e,n,t){const r=wg(e,n._root,t?t._root:void 0);return new ZU(r,n)}(t.routeReuseStrategy,l.targetSnapshot,l.currentRouterState);return this.currentTransition=o={...l,targetRouterState:u},this.currentNavigation.targetRouterState=u,o}),Ds(()=>{this.events.next(new BT)}),((e,n,t,r)=>Rt(s=>(new Qde(n,s.targetRouterState,s.currentRouterState,t,r).activate(e),s)))(this.rootContexts,t.routeReuseStrategy,l=>this.events.next(l),this.inputBindingEnabled),wh(1),Ds({next:l=>{i=!0,this.lastSuccessfulNavigation=this.currentNavigation,this.events.next(new Ra(l.id,this.urlSerializer.serialize(l.extractedUrl),this.urlSerializer.serialize(l.urlAfterRedirects))),this.titleStrategy?.updateTitle(l.targetRouterState.snapshot),l.resolve(!0)},complete:()=>{i=!0}}),function ede(e){return Kr((n,t)=>{Bi(e).subscribe(yr(t,()=>t.complete(),ZS)),!t.closed&&n.subscribe(t)})}(this.transitionAbortSubject.pipe(Ds(l=>{throw l}))),ag(()=>{!i&&!a&&this.cancelNavigationTransition(o,"",mo.SupersededByNewNavigation),this.currentTransition?.id===o.id&&(this.currentNavigation=null,this.currentTransition=null)}),xh(l=>{if(a=!0,oW(l))this.events.next(new pc(o.id,this.urlSerializer.serialize(o.extractedUrl),l.message,l.cancellationCode)),function Yde(e){return oW(e)&&fc(e.url)}(l)?this.events.next(new $x(l.url,l.navigationBehaviorOptions)):o.resolve(!1);else{const u=new VT(o.id,this.urlSerializer.serialize(o.extractedUrl),l,o.targetSnapshot??void 0);try{const c=Oo(this.environmentInjector,()=>this.navigationErrorHandler?.(u));if(!(c instanceof KT))throw this.events.next(u),l;{const{message:d,cancellationCode:h}=Bx(0,c);this.events.next(new pc(o.id,this.urlSerializer.serialize(o.extractedUrl),d,h)),this.events.next(new $x(c.redirectTo,c.navigationBehaviorOptions))}}catch(c){this.options.resolveNavigationPromiseOnError?o.resolve(!1):o.reject(c)}}return zi}))}))}cancelNavigationTransition(t,r,s){const o=new pc(t.id,this.urlSerializer.serialize(t.extractedUrl),r,s);this.events.next(o),t.resolve(!1)}isUpdatingInternalState(){return this.currentTransition?.extractedUrl.toString()!==this.currentTransition?.currentUrlTree.toString()}isUpdatedBrowserUrl(){const t=this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))),r=this.currentNavigation?.targetBrowserUrl??this.currentNavigation?.extractedUrl;return t.toString()!==r?.toString()&&!this.currentNavigation?.extras.skipLocationChange}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function qhe(e){return e!==yg}let Khe=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>Z(Yhe),providedIn:"root"})}return e})();class Xhe{shouldDetach(n){return!1}store(n,t){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,t){return n.routeConfig===t.routeConfig}}let Yhe=(()=>{class e extends Xhe{static \u0275fac=(()=>{let t;return function(s){return(t||(t=Or(e)))(s||e)}})();static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),wW=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:()=>Z(Zhe),providedIn:"root"})}return e})(),Zhe=(()=>{class e extends wW{location=Z(tg);urlSerializer=Z(Ih);options=Z(Th,{optional:!0})||{};canceledNavigationResolution=this.options.canceledNavigationResolution||"replace";urlHandlingStrategy=Z(e1);urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred";currentUrlTree=new dc;getCurrentUrlTree(){return this.currentUrlTree}rawUrlTree=this.currentUrlTree;getRawUrlTree(){return this.rawUrlTree}currentPageId=0;lastSuccessfulId=-1;restoredState(){return this.location.getState()}get browserPageId(){return"computed"!==this.canceledNavigationResolution?this.currentPageId:this.restoredState()?.\u0275routerPageId??this.currentPageId}routerState=QU(null);getRouterState(){return this.routerState}stateMemento=this.createStateMemento();createStateMemento(){return{rawUrlTree:this.rawUrlTree,currentUrlTree:this.currentUrlTree,routerState:this.routerState}}registerNonRouterCurrentEntryChangeListener(t){return this.location.subscribe(r=>{"popstate"===r.type&&t(r.url,r.state)})}handleRouterEvent(t,r){if(t instanceof Ox)this.stateMemento=this.createStateMemento();else if(t instanceof Sh)this.rawUrlTree=r.initialUrl;else if(t instanceof KU){if("eager"===this.urlUpdateStrategy&&!r.extras.skipLocationChange){const s=this.urlHandlingStrategy.merge(r.finalUrl,r.initialUrl);this.setBrowserUrl(r.targetBrowserUrl??s,r)}}else t instanceof BT?(this.currentUrlTree=r.finalUrl,this.rawUrlTree=this.urlHandlingStrategy.merge(r.finalUrl,r.initialUrl),this.routerState=r.targetRouterState,"deferred"===this.urlUpdateStrategy&&!r.extras.skipLocationChange&&this.setBrowserUrl(r.targetBrowserUrl??this.rawUrlTree,r)):t instanceof pc&&(t.code===mo.GuardRejected||t.code===mo.NoDataFromResolver)?this.restoreHistory(r):t instanceof VT?this.restoreHistory(r,!0):t instanceof Ra&&(this.lastSuccessfulId=t.id,this.currentPageId=this.browserPageId)}setBrowserUrl(t,r){const s=t instanceof dc?this.urlSerializer.serialize(t):t;if(this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl){const i={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId)};this.location.replaceState(s,"",i)}else{const o={...r.extras.state,...this.generateNgRouterState(r.id,this.browserPageId+1)};this.location.go(s,"",o)}}restoreHistory(t,r=!1){if("computed"===this.canceledNavigationResolution){const o=this.currentPageId-this.browserPageId;0!==o?this.location.historyGo(o):this.currentUrlTree===t.finalUrl&&0===o&&(this.resetState(t),this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(t),this.resetUrlToCurrentUrlTree())}resetState(t){this.routerState=this.stateMemento.routerState,this.currentUrlTree=this.stateMemento.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.finalUrl??this.rawUrlTree)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(t,r){return"computed"===this.canceledNavigationResolution?{navigationId:t,\u0275routerPageId:r}:{navigationId:t}}static \u0275fac=(()=>{let t;return function(s){return(t||(t=Or(e)))(s||e)}})();static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();function xW(e,n){e.events.pipe(Aa(t=>t instanceof Ra||t instanceof pc||t instanceof VT||t instanceof Sh),Rt(t=>t instanceof Ra||t instanceof Sh?0:t instanceof pc&&(t.code===mo.Redirect||t.code===mo.SupersededByNewNavigation)?2:1),Aa(t=>2!==t),wh(1)).subscribe(()=>{n()})}const Qhe={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Jhe={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Uo=(()=>{class e{get currentUrlTree(){return this.stateManager.getCurrentUrlTree()}get rawUrlTree(){return this.stateManager.getRawUrlTree()}disposed=!1;nonRouterCurrentEntryChangeSubscription;console=Z(DL);stateManager=Z(wW);options=Z(Th,{optional:!0})||{};pendingTasks=Z(ti);urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred";navigationTransitions=Z(jx);urlSerializer=Z(Ih);location=Z(tg);urlHandlingStrategy=Z(e1);_events=new Ls;get events(){return this._events}get routerState(){return this.stateManager.getRouterState()}navigated=!1;routeReuseStrategy=Z(Khe);onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore";config=Z(kh,{optional:!0})?.flat()??[];componentInputBindingEnabled=!!Z(Vx,{optional:!0});constructor(){this.resetConfig(this.config),this.navigationTransitions.setupNavigations(this,this.currentUrlTree,this.routerState).subscribe({error:t=>{this.console.warn(t)}}),this.subscribeToNavigationEvents()}eventsSubscription=new bs;subscribeToNavigationEvents(){const t=this.navigationTransitions.events.subscribe(r=>{try{const s=this.navigationTransitions.currentTransition,o=this.navigationTransitions.currentNavigation;if(null!==s&&null!==o)if(this.stateManager.handleRouterEvent(r,o),r instanceof pc&&r.code!==mo.Redirect&&r.code!==mo.SupersededByNewNavigation)this.navigated=!0;else if(r instanceof Ra)this.navigated=!0;else if(r instanceof $x){const i=r.navigationBehaviorOptions,a=this.urlHandlingStrategy.merge(r.url,s.currentRawUrl),l={browserUrl:s.extras.browserUrl,info:s.extras.info,skipLocationChange:s.extras.skipLocationChange,replaceUrl:s.extras.replaceUrl||"eager"===this.urlUpdateStrategy||qhe(s.source),...i};this.scheduleNavigation(a,yg,null,l,{resolve:s.resolve,reject:s.reject,promise:s.promise})}(function tfe(e){return!(e instanceof BT||e instanceof $x)})(r)&&this._events.next(r)}catch(s){this.navigationTransitions.transitionAbortSubject.next(s)}});this.eventsSubscription.add(t)}resetRootComponentType(t){this.routerState.root.component=t,this.navigationTransitions.rootComponentType=t}initialNavigation(){this.setUpLocationChangeListener(),this.navigationTransitions.hasRequestedNavigation||this.navigateToSyncWithBrowser(this.location.path(!0),yg,this.stateManager.restoredState())}setUpLocationChangeListener(){this.nonRouterCurrentEntryChangeSubscription??=this.stateManager.registerNonRouterCurrentEntryChangeListener((t,r)=>{setTimeout(()=>{this.navigateToSyncWithBrowser(t,"popstate",r)},0)})}navigateToSyncWithBrowser(t,r,s){const o={replaceUrl:!0},i=s?.navigationId?s:null;if(s){const l={...s};delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&&(o.state=l)}const a=this.parseUrl(t);this.scheduleNavigation(a,r,i,o)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(t){this.config=t.map(QT),this.navigated=!1}ngOnDestroy(){this.dispose()}dispose(){this._events.unsubscribe(),this.navigationTransitions.complete(),this.nonRouterCurrentEntryChangeSubscription&&(this.nonRouterCurrentEntryChangeSubscription.unsubscribe(),this.nonRouterCurrentEntryChangeSubscription=void 0),this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(t,r={}){const{relativeTo:s,queryParams:o,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,u=l?this.currentUrlTree.fragment:i;let d,c=null;switch(a??this.options.defaultQueryParamsHandling){case"merge":c={...this.currentUrlTree.queryParams,...o};break;case"preserve":c=this.currentUrlTree.queryParams;break;default:c=o||null}null!==c&&(c=this.removeEmptyProps(c));try{d=zU(s?s.snapshot:this.routerState.snapshot.root)}catch{("string"!=typeof t[0]||"/"!==t[0][0])&&(t=[]),d=this.currentUrlTree.root}return UU(d,t,c,u??null)}navigateByUrl(t,r={skipLocationChange:!1}){const s=fc(t)?t:this.parseUrl(t),o=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(o,yg,null,r)}navigate(t,r={skipLocationChange:!1}){return function efe(e){for(let n=0;n<e.length;n++)if(null==e[n])throw new te(4008,!1)}(t),this.navigateByUrl(this.createUrlTree(t,r),r)}serializeUrl(t){return this.urlSerializer.serialize(t)}parseUrl(t){try{return this.urlSerializer.parse(t)}catch{return this.urlSerializer.parse("/")}}isActive(t,r){let s;if(s=!0===r?{...Qhe}:!1===r?{...Jhe}:r,fc(t))return RU(this.currentUrlTree,t,s);const o=this.parseUrl(t);return RU(this.currentUrlTree,o,s)}removeEmptyProps(t){return Object.entries(t).reduce((r,[s,o])=>(null!=o&&(r[s]=o),r),{})}scheduleNavigation(t,r,s,o,i){if(this.disposed)return Promise.resolve(!1);let a,l,u;i?(a=i.resolve,l=i.reject,u=i.promise):u=new Promise((d,h)=>{a=d,l=h});const c=this.pendingTasks.add();return xW(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(c))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:s,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:t,extras:o,resolve:a,reject:l,promise:u,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),u.catch(d=>Promise.reject(d))}static \u0275fac=function(r){return new(r||e)};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})(),mc=(()=>{class e{router;route;tabIndexAttribute;renderer;el;locationStrategy;href=null;target;queryParams;fragment;queryParamsHandling;state;info;relativeTo;isAnchorElement;subscription;onChanges=new Ls;constructor(t,r,s,o,i,a){this.router=t,this.route=r,this.tabIndexAttribute=s,this.renderer=o,this.el=i,this.locationStrategy=a;const l=i.nativeElement.tagName?.toLowerCase();this.isAnchorElement="a"===l||"area"===l,this.isAnchorElement?this.subscription=t.events.subscribe(u=>{u instanceof Ra&&this.updateHref()}):this.setTabIndexIfNotOnNativeEl("0")}preserveFragment=!1;skipLocationChange=!1;replaceUrl=!1;setTabIndexIfNotOnNativeEl(t){null!=this.tabIndexAttribute||this.isAnchorElement||this.applyAttributeValue("tabindex",t)}ngOnChanges(t){this.isAnchorElement&&this.updateHref(),this.onChanges.next(this)}routerLinkInput=null;set routerLink(t){null==t?(this.routerLinkInput=null,this.setTabIndexIfNotOnNativeEl(null)):(this.routerLinkInput=fc(t)||Array.isArray(t)?t:[t],this.setTabIndexIfNotOnNativeEl("0"))}onClick(t,r,s,o,i){const a=this.urlTree;return!!(null===a||this.isAnchorElement&&(0!==t||r||s||o||i||"string"==typeof this.target&&"_self"!=this.target))||(this.router.navigateByUrl(a,{skipLocationChange:this.skipLocationChange,replaceUrl:this.replaceUrl,state:this.state,info:this.info}),!this.isAnchorElement)}ngOnDestroy(){this.subscription?.unsubscribe()}updateHref(){const t=this.urlTree;this.href=null!==t&&this.locationStrategy?this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(t)):null;const r=null===this.href?null:function w$(e,n,t){return function nZ(e,n){return"src"===n&&("embed"===e||"frame"===e||"iframe"===e||"media"===e||"script"===e)||"href"===n&&("base"===e||"link"===e)?b$:am}(n,t)(e)}(this.href,this.el.nativeElement.tagName.toLowerCase(),"href");this.applyAttributeValue("href",r)}applyAttributeValue(t,r){const s=this.renderer,o=this.el.nativeElement;null!==r?s.setAttribute(o,t,r):s.removeAttribute(o,t)}get urlTree(){return null===this.routerLinkInput?null:fc(this.routerLinkInput)?this.routerLinkInput:this.router.createUrlTree(this.routerLinkInput,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:this.preserveFragment})}static \u0275fac=function(r){return new(r||e)(se(Uo),se($l),function Up(e){return function K9(e,n){if("class"===n)return e.classes;if("style"===n)return e.styles;const t=e.attrs;if(t){const r=t.length;let s=0;for(;s<r;){const o=t[s];if(k2(o))break;if(0===o)s+=2;else if("number"==typeof o)for(s++;s<r&&"string"==typeof t[s];)s++;else{if(o===n)return t[s+1];s+=2}}}return null}(ht(),e)}("tabindex"),se(Ea),se(uo),se(ac))};static \u0275dir=Je({type:e,selectors:[["","routerLink",""]],hostVars:1,hostBindings:function(r,s){1&r&&hn("click",function(i){return s.onClick(i.button,i.ctrlKey,i.shiftKey,i.altKey,i.metaKey)}),2&r&&$i("target",s.target)},inputs:{target:"target",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",state:"state",info:"info",relativeTo:"relativeTo",preserveFragment:[2,"preserveFragment","preserveFragment",ph],skipLocationChange:[2,"skipLocationChange","skipLocationChange",ph],replaceUrl:[2,"replaceUrl","replaceUrl",ph],routerLink:"routerLink"},features:[vL,Jo]})}return e})();class CW{}let sfe=(()=>{class e{router;injector;preloadingStrategy;loader;subscription;constructor(t,r,s,o,i){this.router=t,this.injector=s,this.preloadingStrategy=o,this.loader=i}setUpPreloading(){this.subscription=this.router.events.pipe(Aa(t=>t instanceof Ra),yh(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(t,r){const s=[];for(const o of r){o.providers&&!o._injector&&(o._injector=vw(o.providers,t,`Route: ${o.path}`));const i=o._injector??t,a=o._loadedInjector??i;(o.loadChildren&&!o._loadedRoutes&&void 0===o.canLoad||o.loadComponent&&!o._loadedComponent)&&s.push(this.preloadConfig(i,o)),(o.children||o._loadedRoutes)&&s.push(this.processRoutes(a,o.children??o._loadedRoutes))}return Sr(s).pipe(dg())}preloadConfig(t,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(t,r):Qe(null);const o=s.pipe(as(i=>null===i?Qe(void 0):(r._loadedRoutes=i.routes,r._loadedInjector=i.injector,this.processRoutes(i.injector??t,i.routes))));return r.loadComponent&&!r._loadedComponent?Sr([o,this.loader.loadComponent(r)]).pipe(dg()):o})}static \u0275fac=function(r){return new(r||e)($e(Uo),$e(GB),$e(ws),$e(CW),$e(JT))};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const n1=new fe("");let IW=(()=>{class e{urlSerializer;transitions;viewportScroller;zone;options;routerEventsSubscription;scrollEventsSubscription;lastId=0;lastSource="imperative";restoredId=0;store={};constructor(t,r,s,o,i={}){this.urlSerializer=t,this.transitions=r,this.viewportScroller=s,this.zone=o,this.options=i,i.scrollPositionRestoration||="disabled",i.anchorScrolling||="disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe(t=>{t instanceof Ox?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=t.navigationTrigger,this.restoredId=t.restoredState?t.restoredState.navigationId:0):t instanceof Ra?(this.lastId=t.id,this.scheduleScrollEvent(t,this.urlSerializer.parse(t.urlAfterRedirects).fragment)):t instanceof Sh&&t.code===Fx.IgnoredSameUrlNavigation&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(t,this.urlSerializer.parse(t.url).fragment))})}consumeScrollEvents(){return this.transitions.events.subscribe(t=>{t instanceof XU&&(t.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(t.position):t.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(t.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(t,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.transitions.events.next(new XU(t,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}static \u0275fac=function(r){!function M$(){throw new Error("invalid")}()};static \u0275prov=_e({token:e,factory:e.\u0275fac})}return e})();function SW(e){return e.routerState.root}function Hi(e,n){return{\u0275kind:e,\u0275providers:n}}function _W(){const e=Z(Vn);return n=>{const t=e.get(ho);if(n!==t.components[0])return;const r=e.get(Uo),s=e.get(EW);1===e.get(r1)&&r.initialNavigation(),e.get(DW,null,xt.Optional)?.setUpPreloading(),e.get(n1,null,xt.Optional)?.init(),r.resetRootComponentType(t.componentTypes[0]),s.closed||(s.next(),s.complete(),s.unsubscribe())}}const EW=new fe("",{factory:()=>new Ls}),r1=new fe("",{providedIn:"root",factory:()=>1}),DW=new fe("");function ufe(e){return Hi(0,[{provide:DW,useExisting:sfe},{provide:CW,useExisting:e}])}function dfe(e){return Hi(9,[{provide:vW,useValue:jhe},{provide:bW,useValue:{skipNextTransition:!!e?.skipInitialTransition,...e}}])}const hfe=[tg,{provide:Ih,useClass:Nx},Uo,bg,{provide:$l,useFactory:SW,deps:[Uo]},JT,[]];let Ah=(()=>{class e{constructor(){}static forRoot(t,r){return{ngModule:e,providers:[hfe,[],{provide:kh,multi:!0,useValue:t},[],r?.errorHandler?{provide:t1,useValue:r.errorHandler}:[],{provide:Th,useValue:r||{}},r?.useHash?{provide:ac,useClass:Wie}:{provide:ac,useClass:H3},{provide:n1,useFactory:()=>{const e=Z(ile),n=Z(Vt),t=Z(Th),r=Z(jx),s=Z(Ih);return t.scrollOffset&&e.setOffset(t.scrollOffset),new IW(s,r,e,n,t)}},r?.preloadingStrategy?ufe(r.preloadingStrategy).\u0275providers:[],r?.initialNavigation?gfe(r):[],r?.bindToComponentInputs?Hi(8,[nW,{provide:Vx,useExisting:nW}]).\u0275providers:[],r?.enableViewTransitions?dfe().\u0275providers:[],[{provide:NW,useFactory:_W},{provide:Qd,multi:!0,useExisting:NW}]]}}static forChild(t){return{ngModule:e,providers:[{provide:kh,multi:!0,useValue:t}]}}static \u0275fac=function(r){return new(r||e)};static \u0275mod=Ju({type:e});static \u0275inj=il({})}return e})();function gfe(e){return["disabled"===e.initialNavigation?Hi(3,[{provide:Dw,multi:!0,useFactory:()=>{const n=Z(Uo);return()=>{n.setUpLocationChangeListener()}}},{provide:r1,useValue:2}]).\u0275providers:[],"enabledBlocking"===e.initialNavigation?Hi(2,[{provide:r1,useValue:0},{provide:Dw,multi:!0,deps:[Vn],useFactory:n=>{const t=n.get(zie,Promise.resolve());return()=>t.then(()=>new Promise(r=>{const s=n.get(Uo),o=n.get(EW);xW(s,()=>{r(!0)}),n.get(jx).afterPreactivation=()=>(r(!0),o.closed?Qe(void 0):o),s.initialNavigation()}))}}]).\u0275providers:[]]}const NW=new fe("");let bfe=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275cmp=Cl({type:e,selectors:[["app-root"]],decls:1,vars:0,template:function(r,s){1&r&&rc(0,"router-outlet")},dependencies:[Ah,GT],encapsulation:2})}return e})(),TW=(()=>{class e{_renderer;_elementRef;onChange=t=>{};onTouched=()=>{};constructor(t,r){this._renderer=t,this._elementRef=r}setProperty(t,r){this._renderer.setProperty(this._elementRef.nativeElement,t,r)}registerOnTouched(t){this.onTouched=t}registerOnChange(t){this.onChange=t}setDisabledState(t){this.setProperty("disabled",t)}static \u0275fac=function(r){return new(r||e)(se(Ea),se(uo))};static \u0275dir=Je({type:e})}return e})(),gc=(()=>{class e extends TW{static \u0275fac=(()=>{let t;return function(s){return(t||(t=Or(e)))(s||e)}})();static \u0275dir=Je({type:e,features:[qt]})}return e})();const ji=new fe(""),Cfe={provide:ji,useExisting:cn(()=>Sg),multi:!0},Sfe=new fe("");let Sg=(()=>{class e extends TW{_compositionMode;_composing=!1;constructor(t,r,s){super(t,r),this._compositionMode=s,null==this._compositionMode&&(this._compositionMode=!function Ife(){const e=Tl()?Tl().getUserAgent():"";return/android (\d+)/.test(e.toLowerCase())}())}writeValue(t){this.setProperty("value",t??"")}_handleInput(t){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(t)}_compositionStart(){this._composing=!0}_compositionEnd(t){this._composing=!1,this._compositionMode&&this.onChange(t)}static \u0275fac=function(r){return new(r||e)(se(Ea),se(uo),se(Sfe,8))};static \u0275dir=Je({type:e,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(r,s){1&r&&hn("input",function(i){return s._handleInput(i.target.value)})("blur",function(){return s.onTouched()})("compositionstart",function(){return s._compositionStart()})("compositionend",function(i){return s._compositionEnd(i.target.value)})},standalone:!1,features:[Sn([Cfe]),qt]})}return e})();const ls=new fe(""),Ll=new fe("");function OW(e){return function Pl(e){return null==e||("string"==typeof e||Array.isArray(e))&&0===e.length}(e.value)?{required:!0}:null}function Gx(e){return null}function BW(e){return null!=e}function zW(e){return Am(e)?Sr(e):e}function UW(e){let n={};return e.forEach(t=>{n=null!=t?{...n,...t}:n}),0===Object.keys(n).length?null:n}function WW(e,n){return n.map(t=>t(e))}function HW(e){return e.map(n=>function Efe(e){return!e.validate}(n)?n:t=>n.validate(t))}function s1(e){return null!=e?function jW(e){if(!e)return null;const n=e.filter(BW);return 0==n.length?null:function(t){return UW(WW(t,n))}}(HW(e)):null}function o1(e){return null!=e?function GW(e){if(!e)return null;const n=e.filter(BW);return 0==n.length?null:function(t){return function wfe(...e){const n=$z(e),{args:t,keys:r}=CU(e),s=new sr(o=>{const{length:i}=t;if(!i)return void o.complete();const a=new Array(i);let l=i,u=i;for(let c=0;c<i;c++){let d=!1;Bi(t[c]).subscribe(yr(o,h=>{d||(d=!0,u--),a[c]=h},()=>l--,void 0,()=>{(!l||!d)&&(u||o.next(r?SU(r,a):a),o.complete())}))}});return n?s.pipe(IU(n)):s}(WW(t,n).map(zW)).pipe(Rt(UW))}}(HW(e)):null}function qW(e,n){return null===e?[n]:Array.isArray(e)?[...e,n]:[e,n]}function i1(e){return e?Array.isArray(e)?e:[e]:[]}function qx(e,n){return Array.isArray(e)?e.includes(n):e===n}function YW(e,n){const t=i1(n);return i1(e).forEach(s=>{qx(t,s)||t.push(s)}),t}function ZW(e,n){return i1(n).filter(t=>!qx(e,t))}class QW{get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_composedValidatorFn;_composedAsyncValidatorFn;_rawValidators=[];_rawAsyncValidators=[];_setValidators(n){this._rawValidators=n||[],this._composedValidatorFn=s1(this._rawValidators)}_setAsyncValidators(n){this._rawAsyncValidators=n||[],this._composedAsyncValidatorFn=o1(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_onDestroyCallbacks=[];_registerOnDestroy(n){this._onDestroyCallbacks.push(n)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(n=>n()),this._onDestroyCallbacks=[]}reset(n=void 0){this.control&&this.control.reset(n)}hasError(n,t){return!!this.control&&this.control.hasError(n,t)}getError(n,t){return this.control?this.control.getError(n,t):null}}class Ns extends QW{name;get formDirective(){return null}get path(){return null}}class Vl extends QW{_parent=null;name=null;valueAccessor=null}class JW{_cd;constructor(n){this._cd=n}get isTouched(){return this._cd?.control?._touched?.(),!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return this._cd?.control?._pristine?.(),!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return this._cd?.control?._status?.(),!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return this._cd?._submitted?.(),!!this._cd?.submitted}}let a1=(()=>{class e extends JW{constructor(t){super(t)}static \u0275fac=function(r){return new(r||e)(se(Vl,2))};static \u0275dir=Je({type:e,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(r,s){2&r&&kw("ng-untouched",s.isUntouched)("ng-touched",s.isTouched)("ng-pristine",s.isPristine)("ng-dirty",s.isDirty)("ng-valid",s.isValid)("ng-invalid",s.isInvalid)("ng-pending",s.isPending)},standalone:!1,features:[qt]})}return e})(),l1=(()=>{class e extends JW{constructor(t){super(t)}static \u0275fac=function(r){return new(r||e)(se(Ns,10))};static \u0275dir=Je({type:e,selectors:[["","formGroupName",""],["","formArrayName",""],["","ngModelGroup",""],["","formGroup",""],["form",3,"ngNoForm",""],["","ngForm",""]],hostVars:16,hostBindings:function(r,s){2&r&&kw("ng-untouched",s.isUntouched)("ng-touched",s.isTouched)("ng-pristine",s.isPristine)("ng-dirty",s.isDirty)("ng-valid",s.isValid)("ng-invalid",s.isInvalid)("ng-pending",s.isPending)("ng-submitted",s.isSubmitted)},standalone:!1,features:[qt]})}return e})();const _g="VALID",Xx="INVALID",Rh="PENDING",Eg="DISABLED";class Mh{}class t4 extends Mh{value;source;constructor(n,t){super(),this.value=n,this.source=t}}class d1 extends Mh{pristine;source;constructor(n,t){super(),this.pristine=n,this.source=t}}class h1 extends Mh{touched;source;constructor(n,t){super(),this.touched=n,this.source=t}}class Yx extends Mh{status;source;constructor(n,t){super(),this.status=n,this.source=t}}function f1(e){return(Zx(e)?e.validators:e)||null}function p1(e,n){return(Zx(n)?n.asyncValidators:e)||null}function Zx(e){return null!=e&&!Array.isArray(e)&&"object"==typeof e}class m1{_pendingDirty=!1;_hasOwnPendingAsyncValidator=null;_pendingTouched=!1;_onCollectionChange=()=>{};_updateOn;_parent=null;_asyncValidationSubscription;_composedValidatorFn;_composedAsyncValidatorFn;_rawValidators;_rawAsyncValidators;value;constructor(n,t){this._assignValidators(n),this._assignAsyncValidators(t)}get validator(){return this._composedValidatorFn}set validator(n){this._rawValidators=this._composedValidatorFn=n}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(n){this._rawAsyncValidators=this._composedAsyncValidatorFn=n}get parent(){return this._parent}get status(){return Qr(this.statusReactive)}set status(n){Qr(()=>this.statusReactive.set(n))}_status=Vi(()=>this.statusReactive());statusReactive=Uu(void 0);get valid(){return this.status===_g}get invalid(){return this.status===Xx}get pending(){return this.status==Rh}get disabled(){return this.status===Eg}get enabled(){return this.status!==Eg}errors;get pristine(){return Qr(this.pristineReactive)}set pristine(n){Qr(()=>this.pristineReactive.set(n))}_pristine=Vi(()=>this.pristineReactive());pristineReactive=Uu(!0);get dirty(){return!this.pristine}get touched(){return Qr(this.touchedReactive)}set touched(n){Qr(()=>this.touchedReactive.set(n))}_touched=Vi(()=>this.touchedReactive());touchedReactive=Uu(!1);get untouched(){return!this.touched}_events=new Ls;events=this._events.asObservable();valueChanges;statusChanges;get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(n){this._assignValidators(n)}setAsyncValidators(n){this._assignAsyncValidators(n)}addValidators(n){this.setValidators(YW(n,this._rawValidators))}addAsyncValidators(n){this.setAsyncValidators(YW(n,this._rawAsyncValidators))}removeValidators(n){this.setValidators(ZW(n,this._rawValidators))}removeAsyncValidators(n){this.setAsyncValidators(ZW(n,this._rawAsyncValidators))}hasValidator(n){return qx(this._rawValidators,n)}hasAsyncValidator(n){return qx(this._rawAsyncValidators,n)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(n={}){const t=!1===this.touched;this.touched=!0;const r=n.sourceControl??this;this._parent&&!n.onlySelf&&this._parent.markAsTouched({...n,sourceControl:r}),t&&!1!==n.emitEvent&&this._events.next(new h1(!0,r))}markAllAsTouched(n={}){this.markAsTouched({onlySelf:!0,emitEvent:n.emitEvent,sourceControl:this}),this._forEachChild(t=>t.markAllAsTouched(n))}markAsUntouched(n={}){const t=!0===this.touched;this.touched=!1,this._pendingTouched=!1;const r=n.sourceControl??this;this._forEachChild(s=>{s.markAsUntouched({onlySelf:!0,emitEvent:n.emitEvent,sourceControl:r})}),this._parent&&!n.onlySelf&&this._parent._updateTouched(n,r),t&&!1!==n.emitEvent&&this._events.next(new h1(!1,r))}markAsDirty(n={}){const t=!0===this.pristine;this.pristine=!1;const r=n.sourceControl??this;this._parent&&!n.onlySelf&&this._parent.markAsDirty({...n,sourceControl:r}),t&&!1!==n.emitEvent&&this._events.next(new d1(!1,r))}markAsPristine(n={}){const t=!1===this.pristine;this.pristine=!0,this._pendingDirty=!1;const r=n.sourceControl??this;this._forEachChild(s=>{s.markAsPristine({onlySelf:!0,emitEvent:n.emitEvent})}),this._parent&&!n.onlySelf&&this._parent._updatePristine(n,r),t&&!1!==n.emitEvent&&this._events.next(new d1(!0,r))}markAsPending(n={}){this.status=Rh;const t=n.sourceControl??this;!1!==n.emitEvent&&(this._events.next(new Yx(this.status,t)),this.statusChanges.emit(this.status)),this._parent&&!n.onlySelf&&this._parent.markAsPending({...n,sourceControl:t})}disable(n={}){const t=this._parentMarkedDirty(n.onlySelf);this.status=Eg,this.errors=null,this._forEachChild(s=>{s.disable({...n,onlySelf:!0})}),this._updateValue();const r=n.sourceControl??this;!1!==n.emitEvent&&(this._events.next(new t4(this.value,r)),this._events.next(new Yx(this.status,r)),this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...n,skipPristineCheck:t},this),this._onDisabledChange.forEach(s=>s(!0))}enable(n={}){const t=this._parentMarkedDirty(n.onlySelf);this.status=_g,this._forEachChild(r=>{r.enable({...n,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent}),this._updateAncestors({...n,skipPristineCheck:t},this),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(n,t){this._parent&&!n.onlySelf&&(this._parent.updateValueAndValidity(n),n.skipPristineCheck||this._parent._updatePristine({},t),this._parent._updateTouched({},t))}setParent(n){this._parent=n}getRawValue(){return this.value}updateValueAndValidity(n={}){if(this._setInitialStatus(),this._updateValue(),this.enabled){const r=this._cancelExistingSubscription();this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===_g||this.status===Rh)&&this._runAsyncValidator(r,n.emitEvent)}const t=n.sourceControl??this;!1!==n.emitEvent&&(this._events.next(new t4(this.value,t)),this._events.next(new Yx(this.status,t)),this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!n.onlySelf&&this._parent.updateValueAndValidity({...n,sourceControl:t})}_updateTreeValidity(n={emitEvent:!0}){this._forEachChild(t=>t._updateTreeValidity(n)),this.updateValueAndValidity({onlySelf:!0,emitEvent:n.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Eg:_g}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(n,t){if(this.asyncValidator){this.status=Rh,this._hasOwnPendingAsyncValidator={emitEvent:!1!==t};const r=zW(this.asyncValidator(this));this._asyncValidationSubscription=r.subscribe(s=>{this._hasOwnPendingAsyncValidator=null,this.setErrors(s,{emitEvent:t,shouldHaveEmitted:n})})}}_cancelExistingSubscription(){if(this._asyncValidationSubscription){this._asyncValidationSubscription.unsubscribe();const n=this._hasOwnPendingAsyncValidator?.emitEvent??!1;return this._hasOwnPendingAsyncValidator=null,n}return!1}setErrors(n,t={}){this.errors=n,this._updateControlsErrors(!1!==t.emitEvent,this,t.shouldHaveEmitted)}get(n){let t=n;return null==t||(Array.isArray(t)||(t=t.split(".")),0===t.length)?null:t.reduce((r,s)=>r&&r._find(s),this)}getError(n,t){const r=t?this.get(t):this;return r&&r.errors?r.errors[n]:null}hasError(n,t){return!!this.getError(n,t)}get root(){let n=this;for(;n._parent;)n=n._parent;return n}_updateControlsErrors(n,t,r){this.status=this._calculateStatus(),n&&this.statusChanges.emit(this.status),(n||r)&&this._events.next(new Yx(this.status,t)),this._parent&&this._parent._updateControlsErrors(n,t,r)}_initObservables(){this.valueChanges=new or,this.statusChanges=new or}_calculateStatus(){return this._allControlsDisabled()?Eg:this.errors?Xx:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(Rh)?Rh:this._anyControlsHaveStatus(Xx)?Xx:_g}_anyControlsHaveStatus(n){return this._anyControls(t=>t.status===n)}_anyControlsDirty(){return this._anyControls(n=>n.dirty)}_anyControlsTouched(){return this._anyControls(n=>n.touched)}_updatePristine(n,t){const r=!this._anyControlsDirty(),s=this.pristine!==r;this.pristine=r,this._parent&&!n.onlySelf&&this._parent._updatePristine(n,t),s&&this._events.next(new d1(this.pristine,t))}_updateTouched(n={},t){this.touched=this._anyControlsTouched(),this._events.next(new h1(this.touched,t)),this._parent&&!n.onlySelf&&this._parent._updateTouched(n,t)}_onDisabledChange=[];_registerOnCollectionChange(n){this._onCollectionChange=n}_setUpdateStrategy(n){Zx(n)&&null!=n.updateOn&&(this._updateOn=n.updateOn)}_parentMarkedDirty(n){return!n&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(n){return null}_assignValidators(n){this._rawValidators=Array.isArray(n)?n.slice():n,this._composedValidatorFn=function Mfe(e){return Array.isArray(e)?s1(e):e||null}(this._rawValidators)}_assignAsyncValidators(n){this._rawAsyncValidators=Array.isArray(n)?n.slice():n,this._composedAsyncValidatorFn=function Ofe(e){return Array.isArray(e)?o1(e):e||null}(this._rawAsyncValidators)}}class g1 extends m1{constructor(n,t,r){super(f1(t),p1(r,t)),this.controls=n,this._initObservables(),this._setUpdateStrategy(t),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}controls;registerControl(n,t){return this.controls[n]?this.controls[n]:(this.controls[n]=t,t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange),t)}addControl(n,t,r={}){this.registerControl(n,t),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(n,t={}){this.controls[n]&&this.controls[n]._registerOnCollectionChange(()=>{}),delete this.controls[n],this.updateValueAndValidity({emitEvent:t.emitEvent}),this._onCollectionChange()}setControl(n,t,r={}){this.controls[n]&&this.controls[n]._registerOnCollectionChange(()=>{}),delete this.controls[n],t&&this.registerControl(n,t),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(n){return this.controls.hasOwnProperty(n)&&this.controls[n].enabled}setValue(n,t={}){(function r4(e,n,t){e._forEachChild((r,s)=>{if(void 0===t[s])throw new te(1002,"")})})(this,0,n),Object.keys(n).forEach(r=>{(function n4(e,n,t){const r=e.controls;if(!(n?Object.keys(r):r).length)throw new te(1e3,"");if(!r[t])throw new te(1001,"")})(this,!0,r),this.controls[r].setValue(n[r],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t)}patchValue(n,t={}){null!=n&&(Object.keys(n).forEach(r=>{const s=this.controls[r];s&&s.patchValue(n[r],{onlySelf:!0,emitEvent:t.emitEvent})}),this.updateValueAndValidity(t))}reset(n={},t={}){this._forEachChild((r,s)=>{r.reset(n?n[s]:null,{onlySelf:!0,emitEvent:t.emitEvent})}),this._updatePristine(t,this),this._updateTouched(t,this),this.updateValueAndValidity(t)}getRawValue(){return this._reduceChildren({},(n,t,r)=>(n[r]=t.getRawValue(),n))}_syncPendingControls(){let n=this._reduceChildren(!1,(t,r)=>!!r._syncPendingControls()||t);return n&&this.updateValueAndValidity({onlySelf:!0}),n}_forEachChild(n){Object.keys(this.controls).forEach(t=>{const r=this.controls[t];r&&n(r,t)})}_setUpControls(){this._forEachChild(n=>{n.setParent(this),n._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(n){for(const[t,r]of Object.entries(this.controls))if(this.contains(t)&&n(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(t,r,s)=>((r.enabled||this.disabled)&&(t[s]=r.value),t))}_reduceChildren(n,t){let r=n;return this._forEachChild((s,o)=>{r=t(r,s,o)}),r}_allControlsDisabled(){for(const n of Object.keys(this.controls))if(this.controls[n].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(n){return this.controls.hasOwnProperty(n)?this.controls[n]:null}}const Oh=new fe("",{providedIn:"root",factory:()=>Qx}),Qx="always";function Dg(e,n,t=Qx){y1(e,n),n.valueAccessor.writeValue(e.value),(e.disabled||"always"===t)&&n.valueAccessor.setDisabledState?.(e.disabled),function Pfe(e,n){n.valueAccessor.registerOnChange(t=>{e._pendingValue=t,e._pendingChange=!0,e._pendingDirty=!0,"change"===e.updateOn&&s4(e,n)})}(e,n),function Vfe(e,n){const t=(r,s)=>{n.valueAccessor.writeValue(r),s&&n.viewToModelUpdate(r)};e.registerOnChange(t),n._registerOnDestroy(()=>{e._unregisterOnChange(t)})}(e,n),function Lfe(e,n){n.valueAccessor.registerOnTouched(()=>{e._pendingTouched=!0,"blur"===e.updateOn&&e._pendingChange&&s4(e,n),"submit"!==e.updateOn&&e.markAsTouched()})}(e,n),function $fe(e,n){if(n.valueAccessor.setDisabledState){const t=r=>{n.valueAccessor.setDisabledState(r)};e.registerOnDisabledChange(t),n._registerOnDestroy(()=>{e._unregisterOnDisabledChange(t)})}}(e,n)}function t0(e,n){e.forEach(t=>{t.registerOnValidatorChange&&t.registerOnValidatorChange(n)})}function y1(e,n){const t=function KW(e){return e._rawValidators}(e);null!==n.validator?e.setValidators(qW(t,n.validator)):"function"==typeof t&&e.setValidators([t]);const r=function XW(e){return e._rawAsyncValidators}(e);null!==n.asyncValidator?e.setAsyncValidators(qW(r,n.asyncValidator)):"function"==typeof r&&e.setAsyncValidators([r]);const s=()=>e.updateValueAndValidity();t0(n._rawValidators,s),t0(n._rawAsyncValidators,s)}function s4(e,n){e._pendingDirty&&e.markAsDirty(),e.setValue(e._pendingValue,{emitModelToViewChange:!1}),n.viewToModelUpdate(e._pendingValue),e._pendingChange=!1}const Hfe={provide:Ns,useExisting:cn(()=>Tg)},Ng=Promise.resolve();let Tg=(()=>{class e extends Ns{callSetDisabledState;get submitted(){return Qr(this.submittedReactive)}_submitted=Vi(()=>this.submittedReactive());submittedReactive=Uu(!1);_directives=new Set;form;ngSubmit=new or;options;constructor(t,r,s){super(),this.callSetDisabledState=s,this.form=new g1({},s1(t),o1(r))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(t){Ng.then(()=>{const r=this._findContainer(t.path);t.control=r.registerControl(t.name,t.control),Dg(t.control,t,this.callSetDisabledState),t.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(t)})}getControl(t){return this.form.get(t.path)}removeControl(t){Ng.then(()=>{const r=this._findContainer(t.path);r&&r.removeControl(t.name),this._directives.delete(t)})}addFormGroup(t){Ng.then(()=>{const r=this._findContainer(t.path),s=new g1({});(function o4(e,n){y1(e,n)})(s,t),r.registerControl(t.name,s),s.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(t){Ng.then(()=>{const r=this._findContainer(t.path);r&&r.removeControl(t.name)})}getFormGroup(t){return this.form.get(t.path)}updateModel(t,r){Ng.then(()=>{this.form.get(t.path).setValue(r)})}setValue(t){this.control.setValue(t)}onSubmit(t){return this.submittedReactive.set(!0),function i4(e,n){e._syncPendingControls(),n.forEach(t=>{const r=t.control;"submit"===r.updateOn&&r._pendingChange&&(t.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}(this.form,this._directives),this.ngSubmit.emit(t),"dialog"===t?.target?.method}onReset(){this.resetForm()}resetForm(t=void 0){this.form.reset(t),this.submittedReactive.set(!1)}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(t){return t.pop(),t.length?this.form.get(t):this.form}static \u0275fac=function(r){return new(r||e)(se(ls,10),se(Ll,10),se(Oh,8))};static \u0275dir=Je({type:e,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(r,s){1&r&&hn("submit",function(i){return s.onSubmit(i)})("reset",function(){return s.onReset()})},inputs:{options:[0,"ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],standalone:!1,features:[Sn([Hfe]),qt]})}return e})();function a4(e,n){const t=e.indexOf(n);t>-1&&e.splice(t,1)}function l4(e){return"object"==typeof e&&null!==e&&2===Object.keys(e).length&&"value"in e&&"disabled"in e}const u4=class extends m1{defaultValue=null;_onChange=[];_pendingValue;_pendingChange=!1;constructor(n=null,t,r){super(f1(t),p1(r,t)),this._applyFormState(n),this._setUpdateStrategy(t),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),Zx(t)&&(t.nonNullable||t.initialValueIsDefault)&&(this.defaultValue=l4(n)?n.value:n)}setValue(n,t={}){this.value=this._pendingValue=n,this._onChange.length&&!1!==t.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==t.emitViewToModelChange)),this.updateValueAndValidity(t)}patchValue(n,t={}){this.setValue(n,t)}reset(n=this.defaultValue,t={}){this._applyFormState(n),this.markAsPristine(t),this.markAsUntouched(t),this.setValue(this.value,t),this._pendingChange=!1}_updateValue(){}_anyControls(n){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(n){this._onChange.push(n)}_unregisterOnChange(n){a4(this._onChange,n)}registerOnDisabledChange(n){this._onDisabledChange.push(n)}_unregisterOnDisabledChange(n){a4(this._onDisabledChange,n)}_forEachChild(n){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(n){l4(n)?(this.value=this._pendingValue=n.value,n.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=n}},qfe={provide:Vl,useExisting:cn(()=>r0)},h4=Promise.resolve();let r0=(()=>{class e extends Vl{_changeDetectorRef;callSetDisabledState;control=new u4;static ngAcceptInputType_isDisabled;_registered=!1;viewModel;name="";isDisabled;model;options;update=new or;constructor(t,r,s,o,i,a){super(),this._changeDetectorRef=i,this.callSetDisabledState=a,this._parent=t,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=function w1(e,n){if(!n)return null;let t,r,s;return Array.isArray(n),n.forEach(o=>{o.constructor===Sg?t=o:function Ufe(e){return Object.getPrototypeOf(e.constructor)===gc}(o)?r=o:s=o}),s||r||t||null}(0,o)}ngOnChanges(t){if(this._checkForErrors(),!this._registered||"name"in t){if(this._registered&&(this._checkName(),this.formDirective)){const r=t.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in t&&this._updateDisabled(t),function b1(e,n){if(!e.hasOwnProperty("model"))return!1;const t=e.model;return!!t.isFirstChange()||!Object.is(n,t.currentValue)}(t,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(t){this.viewModel=t,this.update.emit(t)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Dg(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(t){h4.then(()=>{this.control.setValue(t,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(t){const r=t.isDisabled.currentValue,s=0!==r&&ph(r);h4.then(()=>{s&&!this.control.disabled?this.control.disable():!s&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(t){return this._parent?function Jx(e,n){return[...n.path,e]}(t,this._parent):[t]}static \u0275fac=function(r){return new(r||e)(se(Ns,9),se(ls,10),se(Ll,10),se(ji,10),se(Xm,8),se(Oh,8))};static \u0275dir=Je({type:e,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:[0,"disabled","isDisabled"],model:[0,"ngModel","model"],options:[0,"ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],standalone:!1,features:[Sn([qfe]),qt,Jo]})}return e})(),x1=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275dir=Je({type:e,selectors:[["form",3,"ngNoForm","",3,"ngNativeValidate",""]],hostAttrs:["novalidate",""],standalone:!1})}return e})(),yc=(()=>{class e{_validator=Gx;_onChange;_enabled;ngOnChanges(t){if(this.inputName in t){const r=this.normalizeInput(t[this.inputName].currentValue);this._enabled=this.enabled(r),this._validator=this._enabled?this.createValidator(r):Gx,this._onChange&&this._onChange()}}validate(t){return this._validator(t)}registerOnValidatorChange(t){this._onChange=t}enabled(t){return null!=t}static \u0275fac=function(r){return new(r||e)};static \u0275dir=Je({type:e,features:[Jo]})}return e})();const dpe={provide:ls,useExisting:cn(()=>kg),multi:!0};let kg=(()=>{class e extends yc{required;inputName="required";normalizeInput=ph;createValidator=t=>OW;enabled(t){return t}static \u0275fac=(()=>{let t;return function(s){return(t||(t=Or(e)))(s||e)}})();static \u0275dir=Je({type:e,selectors:[["","required","","formControlName","",3,"type","checkbox"],["","required","","formControl","",3,"type","checkbox"],["","required","","ngModel","",3,"type","checkbox"]],hostVars:1,hostBindings:function(r,s){2&r&&$i("required",s._enabled?"":null)},inputs:{required:"required"},standalone:!1,features:[Sn([dpe]),qt]})}return e})(),ype=(()=>{class e{static \u0275fac=function(r){return new(r||e)};static \u0275mod=Ju({type:e});static \u0275inj=il({})}return e})(),A4=(()=>{class e{static withConfig(t){return{ngModule:e,providers:[{provide:Oh,useValue:t.callSetDisabledState??Qx}]}}static \u0275fac=function(r){return new(r||e)};static \u0275mod=Ju({type:e});static \u0275inj=il({imports:[ype]})}return e})(),D1=(()=>{class e{http;apiUrl="http://localhost:8000/api/login";tokenKey="authToken";constructor(t){this.http=t}login(t){return this.http.post(this.apiUrl,t)}setToken(t){localStorage.setItem(this.tokenKey,t)}getToken(){return localStorage.getItem(this.tokenKey)}clearToken(){localStorage.removeItem(this.tokenKey)}isLoggedIn(){return!!this.getToken()}logout(){localStorage.removeItem(this.tokenKey)}static \u0275fac=function(r){return new(r||e)($e(bh))};static \u0275prov=_e({token:e,factory:e.\u0275fac,providedIn:"root"})}return e})();const bpe=()=>["/register"];let wpe=(()=>{class e{authService;router;credentials={username:"",password:""};message="";constructor(t,r){this.authService=t,this.router=r}onLogin(){this.authService.login(this.credentials).subscribe(t=>{t.success?(this.message="Login successful!",localStorage.setItem("authToken",t.token||""),this.router.navigate(["/gallery"])):this.message="Login failed: "+t.message},t=>{this.message="Error connecting to server."})}static \u0275fac=function(r){return new(r||e)(se(D1),se(Uo))};static \u0275cmp=Cl({type:e,selectors:[["app-login"]],decls:48,vars:5,consts:[[1,"container","mt-5"],[1,"row","justify-content-center"],[1,"col-md-6"],[1,"card","shadow-sm"],[1,"card-header","text-center","bg-secondary","text-white"],[1,"h4","mb-0"],[1,"card-body"],[3,"ngSubmit"],[1,"form-group","mb-3"],["for","username"],["type","text","id","username","name","username","placeholder","Enter your username","required","",1,"form-control",3,"ngModelChange","ngModel"],["for","password"],["type","password","id","password","name","password","placeholder","Enter your password","required","",1,"form-control",3,"ngModelChange","ngModel"],["type","submit",1,"btn","btn-success","w-100"],[1,"mt-3","text-center"],[3,"routerLink"],["role","alert",1,"alert","alert-info","mt-4"],[1,"mb-0"],[1,"text-center","mt-3","text-danger"]],template:function(r,s){1&r&&(ze(0,"div",0)(1,"div",1)(2,"div",2)(3,"div",3)(4,"div",4)(5,"h1",5),bt(6,"Login"),Ye()(),ze(7,"div",6)(8,"form",7),hn("ngSubmit",function(){return s.onLogin()}),ze(9,"div",8)(10,"label",9),bt(11,"Username:"),Ye(),ze(12,"input",10),dh("ngModelChange",function(i){return Um(s.credentials.username,i)||(s.credentials.username=i),i}),Ye()(),ze(13,"div",8)(14,"label",11),bt(15,"Password:"),Ye(),ze(16,"input",12),dh("ngModelChange",function(i){return Um(s.credentials.password,i)||(s.credentials.password=i),i}),Ye()(),ze(17,"button",13),bt(18,"Login"),Ye()(),ze(19,"div",14)(20,"p"),bt(21,"Nie masz konta? "),ze(22,"a",15),bt(23,"Zarejestruj si\u0119 tutaj"),Ye()()(),ze(24,"div",16)(25,"strong"),bt(26,"Kont debugowe:"),Ye(),ze(27,"ul",17)(28,"li")(29,"strong"),bt(30,"User:"),Ye(),bt(31," Username: "),ze(32,"code"),bt(33,"test"),Ye(),bt(34,", Password: "),ze(35,"code"),bt(36,"123"),Ye()(),ze(37,"li")(38,"strong"),bt(39,"User:"),Ye(),bt(40," Username: "),ze(41,"code"),bt(42,"user"),Ye(),bt(43,", Password: "),ze(44,"code"),bt(45,"user123"),Ye()()()(),ze(46,"p",18),bt(47),Ye()()()()()()),2&r&&(In(12),ch("ngModel",s.credentials.username),In(4),ch("ngModel",s.credentials.password),In(6),Zr("routerLink",CN(4,bpe)),In(25),zm(s.message))},dependencies:[A4,x1,Sg,a1,l1,kg,r0,Tg,TT,Ah,mc],encapsulation:2})}return e})();const xpe=["canvas"],Cpe=()=>["/edit"],Ipe=(e,n)=>({filename:e,url:n});function Spe(e,n){if(1&e){const t=sc();ze(0,"div",10)(1,"div",11)(2,"p",12),bt(3),Ye()(),ze(4,"img",13),hn("click",function(){const s=ao(t).$implicit;return lo(ii(2).openImage(s))}),Ye(),ze(5,"div",14)(6,"button",15),hn("click",function(){const s=ao(t).$implicit;return lo(ii(2).onRename(s))}),bt(7,"Rename"),Ye(),ze(8,"button",16),hn("click",function(){const s=ao(t).$implicit;return lo(ii(2).onDelete(s))}),bt(9,"Delete"),Ye(),ze(10,"button",17),bt(11," Edit "),Ye()()()}if(2&e){const t=n.$implicit;In(3),zm(t.filename),In(),Zr("src",t.url,am)("alt",t.filename),In(6),Zr("routerLink",CN(5,Cpe))("queryParams",_B(6,Ipe,t.filename,t.url))}}function _pe(e,n){if(1&e){const t=sc();ze(0,"div")(1,"div",3)(2,"div",4)(3,"input",5),hn("change",function(s){return ao(t),lo(ii().onFileSelected(s))}),Ye(),ze(4,"button",6),hn("click",function(){return ao(t),lo(ii().onUpload())}),bt(5,"Upload"),Ye()(),ze(6,"button",7),hn("click",function(){return ao(t),lo(ii().onLogout())}),bt(7,"Logout"),Ye()(),ze(8,"div",8),Tm(9,Spe,12,9,"div",9),Ye()()}if(2&e){const t=ii();In(9),Zr("ngForOf",t.images)}}function Epe(e,n){if(1&e){const t=sc();ze(0,"div",18)(1,"button",19),hn("click",function(){return ao(t),lo(ii().closeImage())}),bt(2,"Close"),Ye(),rc(3,"img",20),Ye()}if(2&e){const t=ii();In(3),Zr("src",t.selectedImage.url,am)("alt",t.selectedImage.filename)}}let Dpe=(()=>{class e{http;authService;images=[];selectedImage=null;selectedFile=null;canvas;ctx;drawing=!1;tool="brush";constructor(t,r){this.http=t,this.authService=r}ngOnInit(){this.fetchImages()}ngAfterViewInit(){this.selectedImage&&this.initCanvas()}fetchImages(){const t=(new _r).set("Authorization",this.authService.getToken()||"");this.http.get("http://localhost:8000/api/images",{headers:t}).subscribe(r=>{this.images=r},r=>{console.error("Error fetching images:",r)})}openImage(t){this.selectedImage=t,setTimeout(()=>this.initCanvas(),0)}closeImage(){this.selectedImage=null}onRename(t){const r=prompt("Enter new name for the image:",t.filename);if(r){const s=(new _r).set("Authorization",this.authService.getToken()||"");this.http.post("http://localhost:8000/api/rename",{filename:t.filename,newName:r},{headers:s}).subscribe(()=>{console.log(`Renamed ${t.filename} to ${r}`),this.fetchImages()},o=>{console.error("Error renaming image:",o)})}}onDelete(t){if(confirm(`Are you sure you want to delete ${t.filename}?`)){const r=(new _r).set("Authorization",this.authService.getToken()||"");this.http.post("http://localhost:8000/api/delete",{filename:t.filename},{headers:r}).subscribe(()=>{console.log(`Deleted ${t.filename}`),this.fetchImages()},s=>{console.error("Error deleting image:",s)})}}onFileSelected(t){this.selectedFile=t.target.files[0]}onUpload(){if(!this.selectedFile)return;const t=(new _r).set("Authorization",this.authService.getToken()||""),r=new FormData;r.append("image",this.selectedFile),this.http.post("http://localhost:8000/api/upload",r,{headers:t}).subscribe(()=>{this.fetchImages()},s=>{console.error("Error uploading image:",s)})}setBrush(){this.tool="brush"}setEraser(){this.tool="eraser"}applyTransparency(){this.selectedImage?this.canvas.nativeElement.toBlob(r=>{if(!r)return void console.error("Failed to generate blob from canvas.");const s=new FormData;s.append("image",r,this.selectedImage?.filename||"edited-image.png");const o=(new _r).set("Authorization",this.authService.getToken()||"");this.http.post("http://localhost:8000/api/edit",s,{headers:o}).subscribe(()=>{console.log("Transparency applied successfully"),this.closeImage(),this.fetchImages()},i=>{console.error("Error applying transparency:",i)})},"image/png"):console.error("No image selected for editing.")}initCanvas(){const t=this.canvas.nativeElement,r=new Image;r.src=this.selectedImage.url,r.onload=()=>{t.width=r.width,t.height=r.height,this.ctx=t.getContext("2d"),this.ctx.drawImage(r,0,0)},t.addEventListener("mousedown",this.startDrawing.bind(this)),t.addEventListener("mousemove",this.draw.bind(this)),t.addEventListener("mouseup",this.stopDrawing.bind(this)),t.addEventListener("mouseleave",this.stopDrawing.bind(this))}startDrawing(t){this.drawing=!0,this.ctx.beginPath(),this.ctx.moveTo(t.offsetX,t.offsetY)}draw(t){this.drawing&&(this.ctx.lineTo(t.offsetX,t.offsetY),this.ctx.strokeStyle="brush"===this.tool?"black":"white",this.ctx.lineWidth="brush"===this.tool?5:10,this.ctx.stroke())}stopDrawing(){this.drawing=!1,this.ctx.closePath()}onLogout(){this.authService.logout(),window.location.href="/"}static \u0275fac=function(r){return new(r||e)(se(bh),se(D1))};static \u0275cmp=Cl({type:e,selectors:[["app-gallery"]],viewQuery:function(r,s){if(1&r&&Pw(xpe,5),2&r){let o;Vm(o=Bm())&&(s.canvas=o.first)}},decls:3,vars:2,consts:[[1,"container-fluid","mt-4"],[4,"ngIf"],["class","selected-image-container",4,"ngIf"],[1,"d-flex","justify-content-between","align-items-center","mb-4"],[1,"d-flex","align-items-center"],["type","file",1,"form-control","me-2",3,"change"],[1,"btn","btn-primary",3,"click"],[1,"btn","logout-button",3,"click"],[1,"row"],["class","col-2 position-relative d-flex flex-column align-items-center",4,"ngFor","ngForOf"],[1,"col-2","position-relative","d-flex","flex-column","align-items-center"],[1,"file-name","position-absolute","top-0","start-50","translate-middle-x"],[1,"text-center","mb-0"],[1,"img-fluid","rounded",3,"click","src","alt"],[1,"image-buttons","position-absolute","bottom-0","start-50","translate-middle-x","d-flex","gap-2"],[1,"btn","btn-warning","btn-sm",3,"click"],[1,"btn","btn-danger","btn-sm",3,"click"],[1,"btn","btn-info","btn-sm",3,"routerLink","queryParams"],[1,"selected-image-container"],[1,"btn","btn-secondary",3,"click"],[1,"img-fluid",3,"src","alt"]],template:function(r,s){1&r&&(ze(0,"div",0),Tm(1,_pe,10,1,"div",1)(2,Epe,4,2,"div",2),Ye()),2&r&&(In(),Zr("ngIf",!s.selectedImage),In(),Zr("ngIf",s.selectedImage))},dependencies:[iT,tT,sz,TT,Ah,mc],styles:[".container-fluid[_ngcontent-%COMP%]{padding:0;margin:0;gap:0}.row[_ngcontent-%COMP%]{margin:0;gap:0}.col-6[_ngcontent-%COMP%], .col-md-4[_ngcontent-%COMP%], .col-lg-3[_ngcontent-%COMP%]{padding:0;position:relative;overflow:hidden;margin:0;gap:0}.img-fluid[_ngcontent-%COMP%]{max-width:100%;height:auto;border:0px solid #ccc;border-radius:0rem}.file-name[_ngcontent-%COMP%]{z-index:10;background-color:#000c;color:#fff;padding:5px;font-size:14px;font-weight:700;text-align:center;border-radius:.25rem .25rem 0 0;margin-top:2px}.image-buttons[_ngcontent-%COMP%]{z-index:10;background-color:#0009;padding:5px;border-radius:.25rem;display:flex;justify-content:center;gap:5px;margin-bottom:2px}button[_ngcontent-%COMP%]{border:none;padding:10px 20px;border-radius:4px;font-size:14px;cursor:pointer}button.btn-primary[_ngcontent-%COMP%]{background-color:#007bff;color:#fff}button.btn-primary[_ngcontent-%COMP%]:hover{background-color:#0056b3}button.logout-button[_ngcontent-%COMP%]{background-color:#dc3545;color:#fff;padding:10px 30px;margin-right:10px}button.logout-button[_ngcontent-%COMP%]:hover{background-color:#b02a37}button.btn-warning[_ngcontent-%COMP%]{background-color:#ffc107;color:#000;font-size:12px;padding:6px 10px}button.btn-warning[_ngcontent-%COMP%]:hover{background-color:#e0a800}button.btn-danger[_ngcontent-%COMP%]{background-color:#dc3545;color:#fff;font-size:12px;padding:6px 10px}button.btn-danger[_ngcontent-%COMP%]:hover{background-color:#b02a37}button.btn-info[_ngcontent-%COMP%]{background-color:#17a2b8;color:#fff;font-size:16px;padding:10px 16px;font-weight:700}button.btn-info[_ngcontent-%COMP%]:hover{background-color:#117a8b}canvas[_ngcontent-%COMP%]{border:1px solid #ccc;max-width:100%;height:auto}h1[_ngcontent-%COMP%]{font-size:2rem;margin-bottom:0rem}.d-flex[_ngcontent-%COMP%]{display:flex;align-items:center}.justify-content-between[_ngcontent-%COMP%]{justify-content:space-between}.justify-content-center[_ngcontent-%COMP%]{justify-content:center}.mb-4[_ngcontent-%COMP%]{margin-bottom:1.5rem}.row[_ngcontent-%COMP%]{margin:0;gap:0px}.col-2[_ngcontent-%COMP%]{padding:2px;position:relative;overflow:hidden}.selected-image-container[_ngcontent-%COMP%]{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:1050;background:#000c;padding:20px;border-radius:10px;display:flex;flex-direction:column;align-items:center}.selected-image-container[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{max-width:90%;max-height:90vh}"]})}return e})();class N1{constructor(n,t){this.backend=n,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,t){this.dataIdsCount++,this.data.set(n,t)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}}class s0{refCount(n){return qs("refCount")}incRef(n){return qs("incRef")}timerAvailable(){return!0}time(n){return qs("time")}read(n){return qs("read")}readSync(n){return qs("readSync")}readToGPU(n,t){return qs("readToGPU")}numDataIds(){return qs("numDataIds")}disposeData(n,t){return qs("disposeData")}write(n,t,r){return qs("write")}move(n,t,r,s,o){return qs("move")}createTensorFromGPUData(n,t,r){return qs("createTensorFromGPUData")}memory(){return qs("memory")}floatPrecision(){return qs("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return qs("dispose")}}function qs(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function T1(e){let n=e.length,t=0;for(;n>0;)t=Math.random()*n|0,n--,Ma(e,n,t)}function kpe(e,n){if(e.length!==n.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${n.length}`);let t=e.length,r=0;for(;t>0;)r=Math.random()*t|0,t--,Ma(e,t,r),Ma(n,t,r)}function Bl(e,n,t){return Math.max(e,Math.min(n,t))}function o0(e){return e%2==0?e:e+1}function Ma(e,n,t){const r=e[n];e[n]=e[t],e[t]=r}function R4(e){let n=0;for(let t=0;t<e.length;t++)n+=e[t];return n}function Ape(e,n){const t=Math.random();return n*t+(1-t)*e}function Rpe(e,n){let t=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(n[r]);t+=s*s}return t}function S(e,n){if(!e)throw new Error("string"==typeof n?n:n())}function Pr(e,n,t=""){S(wt(e,n),()=>t+` Shapes ${e} and ${n} must match`)}function vc(e){S(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function j(e){if(0===e.length)return 1;let n=e[0];for(let t=1;t<e.length;t++)n*=e[t];return n}function Mpe(e){return 0===e.length}function M4(e,n){if(e===n)return!0;if(null==e||null==n||e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(null!==e[t]&&null!==n[t]&&e[t]!==n[t])return!1;return!0}function wt(e,n){if(e===n)return!0;if(null==e||null==n||e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0}function bc(e){return e%1==0}function Ope(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const n=Math.exp(2*e);return(n-1)/(n+1)}}function a0(e){const n=Math.ceil(Math.sqrt(e));return[n,Math.ceil(e/n)]}function Fpe(e){const n=new Uint32Array(e);for(let t=0;t<e;++t)n[t]=t;return T1(n),n}function wc(e,n){return n<=e.length?e:e+" ".repeat(n-e.length)}function k1(e,n=s=>0,t,r){return new Promise((s,o)=>{let i=0;const a=()=>{if(e())return void s();i++;const l=n(i);null!=t&&i>=t?o():null!=r?r(a,l):setTimeout(a,l)};a()})}function A1(e,n){let t=1,r=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)t*=e[o];else if(-1===e[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(e[o]<0)throw Error(`Shapes can not be < 0. Found ${e[o]} at dim ${o}`);if(-1===r){if(n>0&&n!==t)throw Error(`Size(${n}) must match the product of shape ${e}`);return e}if(0===t)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(n%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${t}`);const s=e.slice();return s[r]=n/t,s}function pt(e,n){const t=n.length;return S((e=null==e?n.map((r,s)=>s):[].concat(e)).every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${e}`),S(e.every(r=>bc(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?t+r:r)}function Oa(e,n){const t=[],r=[],s=null!=n&&Array.isArray(n)&&0===n.length,o=null==n||s?null:pt(n,e).sort();let i=0;for(let a=0;a<e.length;++a){if(null!=o){if(o[i]===a&&1!==e[a])throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===e[a]&&(t.push(e[a]),r.push(a)),o[i]<=a&&i++}1!==e[a]&&(t.push(e[a]),r.push(a))}return{newShape:t,keptDims:r}}function Er(e,n){return On(e,n)}function On(e,n){let t=null;if(null==e||"float32"===e)t=new Float32Array(n);else if("int32"===e)t=new Int32Array(n);else if("bool"===e)t=new Uint8Array(n);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);t=new Array(n)}return t}function O4(e,n){for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}function F4(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function R1(e,n){return!("complex64"===n||"float32"===n&&"complex64"!==e||"int32"===n&&"float32"!==e&&"complex64"!==e||"bool"===n&&"bool"===e)}function Ag(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function $4(e){if(null==e)return 0;let n=0;return e.forEach(t=>n+=t.length),n}function Gi(e){return"string"==typeof e||e instanceof String}function P4(e){return"boolean"==typeof e}function l0(e){return"number"==typeof e}function xc(e){return Array.isArray(e)?xc(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":l0(e)?"float32":Gi(e)?"string":P4(e)?"bool":"float32"}function zl(e){return!!(e&&e.constructor&&e.call&&e.apply)}function u0(e,n){for(let t=n;t<e;++t)if(e%t==0)return t;return e}function Oe(e){const n=e.length;if(n<2)return[];const t=new Array(n-1);t[n-2]=e[n-1];for(let r=n-3;r>=0;--r)t[r]=t[r+1]*e[r+1];return t}function L4(e,n,t,r=!1){const s=new Array;if(1===n.length){const o=n[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=t[e+i]}else{const o=n[0],i=n.slice(1),a=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<o;l++)s[l]=L4(e+l*a,i,t,r)}return s}function go(e,n,t=!1){if(0===e.length)return n[0];const r=e.reduce((s,o)=>s*o)*(t?2:1);if(0===r)return[];if(r!==n.length)throw new Error(`[${e}] does not match the input size ${n.length}${t?" for a complex tensor":""}.`);return L4(0,e,n,t)}function V4(e,n){if(Array.isArray(e))return e;if("float32"===n)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===n)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===n||"string"===n)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${n}`)}function c0(e,n){const t=Lr(e,n);for(let r=0;r<t.length;r++)t[r]=1;return t}function Lr(e,n){if(null==n||"float32"===n||"complex64"===n)return new Float32Array(e);if("int32"===n)return new Int32Array(e);if("bool"===n)return new Uint8Array(e);throw new Error(`Unknown data type ${n}`)}function M1(e,n){const t=e.reduce((r,s)=>r*s,1);if(null==n||"float32"===n)return go(e,new Float32Array(t));if("int32"===n)return go(e,new Int32Array(t));if("bool"===n)return go(e,new Uint8Array(t));throw new Error(`Unknown data type ${n}`)}function Ks(e){e.forEach(n=>{S(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function hi(e,n,t){if(0===n)return 0;if(1===n)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=t[s]*e[s];return r}function Cc(e,n,t){if(0===n)return[];if(1===n)return[e];const r=new Array(n);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/t[s]),e-=r[s]*t[s];return r[r.length-1]=e,r}function Fa(e){return e&&e.then&&"function"==typeof e.then}const B4="tfjsflags";class z4{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=$pe,this.populateURLFlags()}setPlatform(n,t){null!=this.platform&&(V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`)),this.platformName=n,this.platform=t}registerFlag(n,t,r){if(this.flagRegistry[n]={evaluationFn:t,setHook:r},null!=this.urlFlags[n]){const s=this.urlFlags[n];V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Setting feature override from URL ${n}: ${s}.`),this.set(n,s)}}getAsync(n){var t=this;return F(function*(){return n in t.flags||(t.flags[n]=yield t.evaluateFlag(n)),t.flags[n]})()}get(n){if(n in this.flags)return this.flags[n];const t=this.evaluateFlag(n);if(Fa(t))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=t,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getString(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,t){if(null==this.flagRegistry[n])throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=t,null!=this.flagRegistry[n].setHook&&this.flagRegistry[n].setHook(t)}evaluateFlag(n){if(null==this.flagRegistry[n])throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const n=this.getQueryParams(this.global.location.search);B4 in n&&n[B4].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=function Lpe(e,n){const t=n.toLowerCase();return"true"===t||"false"===t?"true"===t:""+ +t===t?+t:n}(0,o)})}}function $pe(e){const n={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(function Ppe(e,n,t){e[decodeURIComponent(n)]=decodeURIComponent(t||"")}(n,r[0],r[1]),r.join("="))),n}function V(){return O1}let F1,O1=null;function U4(){if(null==F1){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");e=self}F1=e}return F1}function $1(e,n){const t=function Bpe(){const e=U4();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(t.has(e))return t.get(e);{const r=n();return t.set(e,r),t.get(e)}}const Rg="Abs",Fh="Acos",$h="Acosh",Ic="Add",Mg="AddN",d0="All",h0="Any",Og="ArgMax",Fg="ArgMin",Ph="Asin",Lh="Asinh",Vh="Atan",Bh="Atanh",zh="Atan2",$g="AvgPool",f0="AvgPoolGrad",Pg="AvgPool3D",p0="AvgPool3DGrad",Lg="BatchMatMul",Vg="BatchToSpaceND",m0="Bincount",Bg="BitwiseAnd",W4="BroadcastTo",g0="BroadcastArgs",Uh="Cast",Wh="Ceil",Hh="ClipByValue",y0="Complex",zg="ComplexAbs",Ug="Concat",Wg="Conv2D",v0="Conv2DBackpropFilter",Hg="Conv2DBackpropInput",jg="Conv3D",b0="Conv3DBackpropFilterV2",w0="Conv3DBackpropInputV2",jh="Cos",Gh="Cosh",x0="Cumprod",Gg="Cumsum",C0="CropAndResize",I0="DenseBincount",S0="DepthToSpace",qg="DepthwiseConv2dNative",_0="DepthwiseConv2dNativeBackpropFilter",E0="DepthwiseConv2dNativeBackpropInput",D0="Diag",Kg="Dilation2D",N0="Dilation2DBackpropInput",T0="Dilation2DBackpropFilter",k0="Draw",qh="RealDiv",A0="Einsum",Kh="Elu",R0="EluGrad",Xh="Erf",Xg="Equal",Yh="Exp",Yg="ExpandDims",Zh="Expm1",M0="FFT",O0="Fill",F0="FlipLeftRight",Qh="Floor",Jh="FloorDiv",Zg="FusedBatchNorm",Qg="GatherV2",$0="GatherNd",Jg="Greater",ef="GreaterEqual",nf="Identity",P0="IFFT",L0="Imag",rf="IsFinite",sf="IsInf",af="IsNan",ey="LeakyRelu",ty="Less",ny="LessEqual",V0="LinSpace",lf="Log",uf="Log1p",ry="LogicalAnd",sy="LogicalNot",oy="LogicalOr",zpe="LogicalXor",H4="LogSoftmax",Upe="LowerBound",iy="LRN",B0="LRNGrad",Wpe="MatrixBandPart",ay="Max",cf="Maximum",ly="MaxPool",z0="MaxPoolGrad",uy="MaxPool3D",U0="MaxPool3DGrad",W0="MaxPoolWithArgmax",cy="Mean",dy="Min",df="Minimum",hy="MirrorPad",hf="Mod",H0="Multinomial",ff="Multiply",fy="Neg",py="NotEqual",j0="NonMaxSuppressionV3",G0="NonMaxSuppressionV4",q0="NonMaxSuppressionV5",my="OnesLike",gy="OneHot",yy="Pack",vy="PadV2",Hpe="Pool",pf="Pow",by="Prelu",wy="Prod",K0="RaggedGather",X0="RaggedRange",Y0="RaggedTensorToTensor",Z0="Range",Q0="Real",mf="Reciprocal",gf="Relu",xy="Reshape",Cy="ResizeNearestNeighbor",J0="ResizeNearestNeighborGrad",Iy="ResizeBilinear",eC="ResizeBilinearGrad",yf="Relu6",Sy="Reverse",vf="Round",bf="Rsqrt",tC="ScatterNd",nC="TensorScatterUpdate",rC="SearchSorted",_y="Select",wf="Selu",Ey="Slice",xf="Sin",Cf="Sinh",If="Sign",Sf="Sigmoid",_f="Softplus",Ef="Sqrt",Dy="Sum",Ny="SpaceToBatchND",Ty="SplitV",ky="Softmax",sC="SparseFillEmptyRows",oC="SparseReshape",iC="SparseSegmentMean",aC="SparseSegmentSum",lC="SparseToDense",Df="SquaredDifference",uC="Square",Ay="StaticRegexReplace",cC="StridedSlice",dC="StringNGrams",hC="StringSplit",fC="StringToHashBucketFast",Nf="Sub",Tf="Tan",kf="Tanh",Af="Tile",pC="TopK",mC="Transform",Sc="Transpose",gC="Unique",Ry="Unpack",My="UnsortedSegmentSum",jpe="UpperBound",Oy="ZerosLike",Rf="Step",yC="FromPixels",vC="RotateWithOffset",Fy="_FusedMatMul",$y="FusedConv2D",Py="FusedDepthwiseConv2D";function yo(...e){V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(...e)}function Gpe(...e){V().getBool("IS_TEST")||V().getBool("PROD")||console.log(...e)}const Mf=$1("kernelRegistry",()=>new Map),Ly=$1("gradRegistry",()=>new Map);function Vy(e,n){const t=L1(e,n);return Mf.get(t)}function P1(e){return Ly.get(e)}function bC(e){const n=Mf.entries(),t=[];for(;;){const{done:r,value:s}=n.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===e&&t.push(i)}return t}function wC(e){const{kernelName:n,backendName:t}=e,r=L1(n,t);Mf.has(r)&&yo(`The kernel '${n}' for backend '${t}' is already registered`),Mf.set(r,e)}function j4(e){const{kernelName:n}=e;Ly.has(n)&&V().getBool("DEBUG")&&yo(`Overriding the gradient for '${n}'`),Ly.set(n,e)}function qpe(e,n){const t=L1(e,n);if(!Mf.has(t))throw new Error(`The kernel '${e}' for backend '${n}' is not registered`);Mf.delete(t)}function Kpe(e){if(!Ly.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Ly.delete(e)}function Xpe(e,n){bC(e).forEach(r=>{wC(Object.assign({},r,{backendName:n}))})}function L1(e,n){return`${n}_${e}`}function G4(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var q4=U(929);const _c=U.n(q4)()||q4;function By(e){return _c.fromString(e,!0,16)}const K4=By("c3a5c85c97cb3127"),Ec=By("b492b66fbe98f273"),us=By("9ae16a3b2f90404f");function V1(e){return e.xor(e.shru(47))}function X4(e,n,t){const r=e.slice(n,n+t);return _c.fromBytes(Array.from(r),!0,!0)}function sn(e,n){return X4(e,n,8)}function Y4(e,n){return X4(e,n,4)}function Dr(e,n){return 0===n?e:e.shru(n).or(e.shl(64-n))}function Ul(e,n,t=By("9ddfea08eb382d69")){let r=e.xor(n).mul(t);r=r.xor(r.shru(47));let s=n.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function xC(e,n,t,r){return function Zpe(e,n,t,r,s,o){s=s.add(e),o=Dr(o.add(s).add(r),21);const i=s;return s=(s=s.add(n)).add(t),o=o.add(Dr(s,44)),[s.add(r),o.add(i)]}(sn(e,n),sn(e,n+8),sn(e,n+16),sn(e,n+24),t,r)}function Z4(e,n=e.length){const t=_c.fromNumber(81,!0);if(n<=32)return n<=16?function Qpe(e,n=e.length){if(n>=8){const t=us.add(2*n),r=sn(e,0).add(us),s=sn(e,n-8);return Ul(Dr(s,37).mul(t).add(r),Dr(r,25).add(s).mul(t),t)}if(n>=4){const t=us.add(2*n);return Ul(Y4(e,0).shl(3).add(n),Y4(e,n-4),t)}if(n>0){const i=n+(e[n-1]<<2);return V1(us.mul(e[0]+(e[n>>1]<<8)).xor(K4.mul(i))).mul(us)}return us}(e,n):function Jpe(e,n=e.length){const t=us.add(2*n),r=sn(e,0).mul(Ec),s=sn(e,8),o=sn(e,n-8).mul(t),i=sn(e,n-16).mul(us);return Ul(Dr(r.add(s),43).add(Dr(o,30)).add(i),r.add(Dr(s.add(us),18)).add(o),t)}(e,n);if(n<=64)return function eme(e,n=e.length){const t=us.add(2*n),r=sn(e,0).mul(us),s=sn(e,8),o=sn(e,n-8).mul(t),i=sn(e,n-16).mul(us),a=Dr(r.add(s),43).add(Dr(o,30)).add(i),l=Ul(a,r.add(Dr(s.add(us),18)).add(o),t),u=sn(e,16).mul(t),c=sn(e,24),d=a.add(sn(e,n-32)).mul(t),h=l.add(sn(e,n-24)).mul(t);return Ul(Dr(u.add(c),43).add(Dr(d,30)).add(h),u.add(Dr(c.add(r),18)).add(d),t)}(e,n);let r=t,s=t.mul(Ec).add(113),o=V1(s.mul(us).add(113)).mul(us),i=[_c.UZERO,_c.UZERO],a=[_c.UZERO,_c.UZERO];r=r.mul(us).add(sn(e,0));let l=0;const u=64*(n-1>>6),c=u+(n-1&63)-63;do{r=Dr(r.add(s).add(i[0]).add(sn(e,l+8)),37).mul(Ec),s=Dr(s.add(i[1]).add(sn(e,l+48)),42).mul(Ec),r=r.xor(a[1]),s=s.add(i[0]).add(sn(e,l+40)),o=Dr(o.add(a[0]),33).mul(Ec),i=xC(e,l,i[1].mul(Ec),r.add(a[0])),a=xC(e,l+32,o.add(a[1]),s.add(sn(e,l+16))),[o,r]=[r,o],l+=64}while(l!==u);const d=Ec.add(o.and(255).shl(1));return l=c,a[0]=a[0].add(n-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Dr(r.add(s).add(i[0]).add(sn(e,l+8)),37).mul(d),s=Dr(s.add(i[1]).add(sn(e,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(sn(e,l+40))),o=Dr(o.add(a[0]),33).mul(d),i=xC(e,l,i[1].mul(d),r.add(a[0])),a=xC(e,l+32,o.add(a[1]),s.add(sn(e,l+16))),[o,r]=[r,o],Ul(Ul(i[0],a[0],d).add(V1(s).mul(K4)).add(o),Ul(i[1],a[1],d).add(r),d)}function $a(e,n){return"string"===n?qi(e):Wl([e],n)}function Wl(e,n){if("string"===n)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ki(e)),V().getBool("DEBUG")&&O4(e,n),function tme(e,n){return e instanceof Float32Array&&"float32"===n||e instanceof Int32Array&&"int32"===n||e instanceof Uint8Array&&"bool"===n}(e,n))return e;if(null==n||"float32"===n||"complex64"===n)return new Float32Array(e);if("int32"===n)return new Int32Array(e);if("bool"===n){const t=new Uint8Array(e.length);for(let r=0;r<t.length;++r)0!==Math.round(e[r])&&(t[r]=1);return t}throw new Error(`Unknown data type ${n}`)}function Vr(){return V().platform.now()}function Q4(e,n){return V().platform.fetch(e,n)}function qi(e,n="utf-8"){return n=n||"utf-8",V().platform.encode(e,n)}function Pa(e,n="utf-8"){return n=n||"utf-8",V().platform.decode(e,n)}function lr(e){return null!=V().platform.isTypedArray?V().platform.isTypedArray(e):G4(e)}function Ki(e,n=[],t=!1){if(null==n&&(n=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||Fa(e)||null==e||lr(e)&&t)n.push(e);else if(Array.isArray(e)||lr(e))for(let r=0;r<e.length;++r)Ki(e[r],n,t);else{let r=-1;for(const s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Ki(e[s],n,t)}return n}class nme{constructor(n,t){this.backendTimer=n,this.logger=t,null==t&&(this.logger=new sme)}profileKernel(n,t,r){let s;const o=()=>{s=r()};let i;const a=Vr();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:Vr()-a})}if(V().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{rme(d,c.dtype,n)})}return{kernelName:n,outputs:s,inputs:t,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(n){const{kernelName:t,outputs:r,timeMs:s,inputs:o,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),s,i]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],o,l[2])})})}}function rme(e,n,t){if("float32"!==n)return!1;for(let r=0;r<e.length;r++){const s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class sme{logKernelProfile(n,t,r,s,o,i){const a="number"==typeof s?wc(`${s}ms`,9):s.error,l=wc(n,25),u=t.rank,c=t.size,d=wc(t.shape.toString(),14);let h="";for(const f in o){const p=o[f];if(null!=p){const m=p.shape||t.shape,g=m.length;h+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ame(e,n,t,r){const s=Oe(n),o=function lme(e,n,t,r){const s=j(n),o=r[r.length-1],i=new Array(o).fill(0),a=n.length,l="complex64"===t?Wy(e):e;if(a>1)for(let u=0;u<s/o;u++){const c=u*o;for(let d=0;d<o;d++)i[d]=Math.max(i[d],Uy(l[c+d],0,t).length)}return i}(e,n,t,s),i=n.length,a=CC(e,n,t,s,o),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join("\n")),l.join("\n")}function Uy(e,n,t){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Gi(e)?`'${e}'`:"bool"===t?eH(e):parseFloat(e.toFixed(7)).toString(),wc(r,n)}function eH(e){return 0===e?"false":"true"}function CC(e,n,t,r,s,o=!0){const i="complex64"===t?2:1,a=n[0],l=n.length;if(0===l)return"complex64"===t?[Uy(Wy(e)[0],0,t)]:"bool"===t?[eH(e[0])]:[e[0].toString()];if(1===l){if(a>20){let y=Array.from(e.slice(0,3*i)),v=Array.from(e.slice((a-3)*i,a*i));return"complex64"===t&&(y=Wy(y),v=Wy(v)),["["+y.map((b,w)=>Uy(b,s[w],t)).join(", ")+", ..., "+v.map((b,w)=>Uy(b,s[a-3+w],t)).join(", ")+"]"]}return["["+("complex64"===t?Wy(e):Array.from(e)).map((g,y)=>Uy(g,s[y],t)).join(", ")+"]"]}const u=n.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...CC(e.slice(g,g+d),u,t,c,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...CC(e.slice(g,g+d),u,t,c,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...CC(e.slice(g,g+d),u,t,c,s,m===a-1))}const f=2===l?",":"";h[0]="["+(a>0?h[0]+f:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+f;let p=",\n";for(let m=2;m<l;m++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":p),h}function Wy(e){const n=[];for(let t=0;t<e.length;t+=2)n.push([e[t],e[t+1]]);return n}class Qn{constructor(n,t,r){if(this.dtype=t,this.shape=n.slice(),this.size=j(n),null!=r){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||On(t,this.size),this.strides=Oe(n)}set(n,...t){0===t.length&&(t=[0]),S(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=n}get(...n){0===n.length&&(n=[0]);let t=0;for(const s of n){if(s<0||s>=this.shape[t])throw new Error(`Requested out of range element at ${n}.   Buffer shape=${this.shape}`);t++}let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=this.strides[s]*n[s];return this.values[r]}locToIndex(n){if(0===this.rank)return 0;if(1===this.rank)return n[0];let t=n[n.length-1];for(let r=0;r<n.length-1;++r)t+=this.strides[r]*n[r];return t}indexToLoc(n){if(0===this.rank)return[];if(1===this.rank)return[n];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(n/this.strides[r]),n-=t[r]*this.strides[r];return t[t.length-1]=n,t}get rank(){return this.shape.length}toTensor(){return fi().makeTensor(this.values,this.shape,this.dtype)}}let fi=null,Of=null,tH=null;class St{constructor(n,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=t||"float32",this.size=j(n),this.strides=Oe(n),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var n=this;return F(function*(){const t=yield n.data();return Of.buffer(n.shape,n.dtype,t)})()}bufferSync(){return Of.buffer(this.shape,this.dtype,this.dataSync())}array(){var n=this;return F(function*(){const t=yield n.data();return go(n.shape,t,"complex64"===n.dtype)})()}arraySync(){return go(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var n=this;return F(function*(){n.throwIfDisposed();const t=fi().read(n.dataId);if("string"===n.dtype){const r=yield t;try{return r.map(s=>Pa(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataToGPU(n){return this.throwIfDisposed(),fi().readToGPU(this.dataId,n)}dataSync(){this.throwIfDisposed();const n=fi().readSync(this.dataId);if("string"===this.dtype)try{return n.map(t=>Pa(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}bytes(){var n=this;return F(function*(){n.throwIfDisposed();const t=yield fi().read(n.dataId);return"string"===n.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),fi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return Of.print(this,n)}clone(){return this.throwIfDisposed(),Of.clone(this)}toString(n=!1){return ame(this.dataSync(),this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),Of.cast(this,n)}variable(n=!0,t,r){return this.throwIfDisposed(),fi().makeVariable(this,n,t,r)}}function X(){return $1("Tensor",()=>St)}Object.defineProperty(St,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),X();class Hy extends St{constructor(n,t,r,s){super(n.shape,n.dtype,n.dataId,s),this.trainable=t,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!wt(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);fi().disposeTensor(this),this.dataId=n.dataId,fi().incRef(this,null)}dispose(){fi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Hy,Symbol.hasInstance,{value:e=>e instanceof St&&null!=e.assign&&e.assign instanceof Function});var nH=function(e){return e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6",e}(nH||{}),rH=function(e){return e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64",e}(rH||{}),sH=function(e){return e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64",e}(sH||{}),oH=function(e){return e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64",e}(oH||{}),iH=function(e){return e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64",e}(iH||{});const hme={float32:oH,int32:rH,bool:sH,complex64:iH};function Ts(e,n){if("string"===e||"string"===n){if("string"===e&&"string"===n)return"string";throw new Error(`Can not upcast ${e} with ${n}`)}return hme[e][n]}function IC(e){return Ts(e,"int32")}function aH(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function lH(e){return typeof GPUBuffer<"u"&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function _n(e,n){if(e.dtype===n.dtype)return[e,n];const t=Ts(e.dtype,n.dtype);return[e.cast(t),n.cast(t)]}function uH(e,n){S(e.dtype===n.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${n.dtype}) input must match`)}function SC(e,n){return n.some(t=>t.id===e.id)}function La(e){const n=[];return cH(e,n,new Set),n}function cH(e,n,t){if(null==e)return;if(e instanceof St)return void n.push(e);if(!function fme(e){return Array.isArray(e)||"object"==typeof e}(e))return;const r=e;for(const s in r){const o=r[s];t.has(o)||(t.add(o),cH(o,n,t))}}function z1(e){return null!=e.kernelName}class dH{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(const n in this.registeredVariables)this.registeredVariables[n].dispose()}}let pme=(()=>{class e{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new dH}ready(){var t=this;return F(function*(){if(null!=t.pendingBackendInit)return t.pendingBackendInit.then(()=>{});if(null!=t.backendInstance)return;const r=t.getSortedBackends();for(let s=0;s<r.length;s++){const o=r[s];if(yield t.initializeBackend(o).success)return void(yield t.setBackend(o))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(t);if(r)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,r,s=1){return t in this.registryFactory?(yo(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:r,priority:s},!0)}setBackend(t){var r=this;return F(function*(){if(null==r.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(r.backendName=t,null==r.registry[t]){r.backendInstance=null;const{success:s,asyncInit:o}=r.initializeBackend(t);if(!(o?yield s:s))return!1}return r.backendInstance=r.registry[t],r.setupRegisteredKernels(),r.profiler=new nme(r.backendInstance),!0})()}setupRegisteredKernels(){bC(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){bC(t).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const r=this.registryFactory[t];if(null==r)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=r.factory();if(!s||s instanceof s0||"function"!=typeof s.then)return this.registry[t]=s,{success:!0,asyncInit:!1};{const o=++this.pendingBackendInitId,i=s.then(a=>!(o<this.pendingBackendInitId||(this.registry[t]=a,this.pendingBackendInit=null,0))).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,yo(`Initialization of backend ${t} failed`),yo(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}}catch(s){return yo(`Initialization of backend ${t} failed`),yo(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,r)=>this.registryFactory[r].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let r=0;r<t.length;r++){const s=t[r],{success:o,asyncInit:i}=this.initializeBackend(s);if(i||o)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,r){const s=this.state.tensorInfo.get(r),o=s.backend,i=this.readSync(r),a=o.refCount(r);o.disposeData(r,!0),s.backend=t,t.move(r,i,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,r){let o,s=null;if(null==r){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");r=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=r(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,r,s){t();try{const o=s();return r(),o}catch(o){throw r(),o}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(t){const r=k.runKernel(nf,{x:t});return this.addTapeNode(this.state.activeScope.name,{x:t},[r],a=>({x:()=>k.runKernel(Uh,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(t,r,s){if(null==Vy(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,r,s){const o=this.backend.numDataIds();let i=0;s.forEach(u=>{i+="complex64"===u.dtype?3:1});const l=o-r-i-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${t}'`)}runKernelFunc(t){let r,s=[];const o=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=z1(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(z1(t)){const{kernelName:m,inputs:g,attrs:y}=t,v=Vy(m,this.backendName);S(null!=v,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const b=this.backend.numDataIds();u=v.kernelFunc({inputs:g,attrs:y,backend:this.backend});const w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,b,w);const x=w.map(I=>null!=I.rank?I:this.makeTensorFromTensorInfo(I));if(o){const I=this.getTensorsForGradient(m,g,x);s=this.saveTensorsForBackwardMode(I)}return x}}else{const{forwardFunc:m}=t,g=y=>{o&&(s=y.map(v=>this.keep(this.clone(v))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,g));const v=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,v),v}}const{inputs:d,attrs:h}=t,f=z1(t)?null:t.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),o&&this.addTapeNode(c,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(u)?r:r[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,r,s){const o=P1(t);if(null!=o){const i=o.inputsToSave||[],a=o.outputsToSave||[];let l;o.saveAllInputs?(S(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(c=>r[c])):l=i.map(c=>r[c]);const u=s.filter((c,d)=>a[d]);return l.concat(u)}return[]}makeTensor(t,r,s,o){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");o=o||this.backend;let i=t;"string"===(s=s||"float32")&&Gi(t[0])&&(i=t.map(u=>qi(u)));const a=o.write(i,r,s),l=new St(r,s,a,this.nextTensorId());if(this.trackTensor(l,o),"string"===s){const u=this.state.tensorInfo.get(a),c=$4(i);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(t,r,s,o){return this.makeTensorFromTensorInfo({dataId:t,shape:r,dtype:s=s||"float32"},o)}makeTensorFromTensorInfo(t,r){const{dataId:s,shape:o,dtype:i}=t,a=new St(o,i,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(t,r=!0,s,o){s=s||this.nextVariableId().toString(),null!=o&&o!==t.dtype&&(t=t.cast(o));const i=new Hy(t,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[i.name])throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(t,r){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(s=t.size*Ag(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:r||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof Hy||this.track(t)}incRef(t,r){this.trackTensor(t,r),this.backend.incRef(t.dataId)}removeDataId(t,r){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===r&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const r=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const s=t.size*Ag(t.dtype);this.state.numBytes-=s}r.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,r.backend)}disposeVariables(){for(const t in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[t])}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}profile(t){var r=this;return F(function*(){r.state.profiling=!0;const s=r.state.numBytes,o=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield t(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-o;for(const i of r.state.activeProfile.kernels)i.kernelTimeMs=yield i.kernelTimeMs,i.extraInfo=yield i.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,r,s,o,i,a){const l={id:this.state.nextTapeNodeId++,kernelName:t,inputs:r,outputs:s,saved:i},u=P1(t);null!=u&&(o=u.gradFunc),null!=o&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const f=s[h],p=Lr(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),o(c.length>1?c:c[0],i,a))),this.state.activeTape.push(l)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(r.name=t),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(t){const r=La(t),s=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!s.has(a.id)&&a.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===o.id&&this.track(i)})}gradients(t,r,s,o=!1){if(S(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));S(i instanceof St,()=>"The result y returned by f() must be a tensor.");const a=function ome(e,n,t){const r={},s={};for(let l=0;l<n.length;l++)r[n[l].id]=!0;for(let l=0;l<e.length;l++){const u=e[l],c=u.inputs;for(const d in c){const h=c[d];let f=!1;for(let p=0;p<n.length;p++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),f=!0,s[u.id]=!0;break}if(f)break}}const o={};o[t.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const u=e[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(o[u.outputs[d].id]){for(const h in c)o[c[h].id]=!0,i[u.id]=!0;break}}const a=[];for(let l=0;l<e.length;l++){const u=e[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const f=u.inputs[h];r[f.id]&&(c[h]=f)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,a.push(d)}}return a}(this.state.activeTape,r,i);if(!o&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[i.id]=s??function mme(e){const n=c0(j(e),"float32");return k.makeTensor(n,e,"float32")}(i.shape),function ime(e,n,t,r){for(let s=n.length-1;s>=0;s--){const o=n[s],i=[];if(o.outputs.forEach(l=>{const u=e[l.id];i.push(null!=u?u:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const l in o.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=o.inputs[l];if(!wt(u.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==e[c.id])e[c.id]=u;else{const d=e[c.id];e[c.id]=r(d,u),d.dispose()}}}}(l,a,c=>this.tidy(c),gme);const u=r.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:i,grads:u}})}customGrad(t){return S(zl(t),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;S(r.every(l=>l instanceof St),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const o={};return r.forEach((l,u)=>{o[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(s=t(...r,u),S(s.value instanceof St,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(zl(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,u)=>{const c=s.gradFunc(l,u),d=Array.isArray(c)?c:[c];S(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof St),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,r){return this.state.tensorInfo.get(t).backend.readToGPU(t,r)}time(t){var r=this;return F(function*(){const s=Vr(),o=yield r.backend.time(t);return o.wallMs=Vr()-s,o})()}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new dH;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return e.nextTensorId=0,e.nextVariableId=0,e})();function hH(){const e=U4();if(null==e._tfengine){const n=new z4(e);e._tfengine=new pme(n)}return function Vpe(e){O1=e}(e._tfengine.ENV),function ume(e){fi=e}(()=>e._tfengine),e._tfengine}const k=hH();function gme(e,n){return k.runKernel(Ic,{a:e,b:n})}let U1;function vme(e){U1=e}function W1(e){if(void 0!==U1)return U1;if(e||function yme(){return typeof navigator<"u"&&null!=navigator}()){if(e||(e=navigator),"ReactNative"===e.product)return!0;const n=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");return n?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4)):e.userAgentData&&e.userAgentData.mobile}return!1}function H1(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const ks=V();function Xi(e,n){let t=e;if(lr(e))return"string"===n?[]:[e.length];if(aH(e))return[e.height,e.width*(e.channels||"RGBA").length];if(lH(e))return[e.buffer.size/(null==n?4:Ag(n))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(t)||lr(t)&&"string"!==n;)r.push(t.length),t=t[0];return Array.isArray(e)&&V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&fH(e,r,[]),r}function fH(e,n,t){if(t=t||[],!Array.isArray(e)&&!lr(e))return void S(0===n.length,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);S(n.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${e.length} elements`),S(e.length===n[0],()=>`Element arr[${t.join("][")}] should have ${n[0]} elements, but has ${e.length} elements`);const r=n.slice(1);for(let s=0;s<e.length;++s)fH(e[s],r,t.concat(s))}function pH(e,n,t,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==n||"numeric"===e&&"string"===n)throw new Error(`Argument '${t}' passed to '${r}' must be ${e} tensor, but got ${n} tensor`)}}function E(e,n,t,r="numeric"){if(e instanceof X())return pH(r,e.dtype,n,t),e;let s=xc(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),pH(r,s,n,t),null==e||!lr(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${n}' passed to '${t}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);const o=Xi(e,s);!lr(e)&&!Array.isArray(e)&&(e=[e]);const a="string"!==s?Wl(e,s):Ki(e,[],!0);return k.makeTensor(a,o,s)}function jy(e,n,t,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${n} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((o,i)=>E(o,`${n}[${i}]`,t,r))}ks.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ks.registerFlag("IS_BROWSER",()=>H1()),ks.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),ks.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ks.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),ks.registerFlag("PROD",()=>!1),ks.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ks.getBool("DEBUG")),ks.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ks.registerFlag("IS_TEST",()=>!1),ks.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ks.getBool("DEBUG")),ks.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),ks.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),ks.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const j1="__op";function R(e){const n=Object.keys(e);if(1!==n.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let t=n[0];const r=e[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t+=j1;const s=(...o)=>{k.startScope(t);try{const i=r(...o);return Fa(i)&&console.error("Cannot return a Promise inside of tidy."),k.endScope(i),i}catch(i){throw k.endScope(null),i}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}const Va=R({complex_:function bme(e,n){const t=E(e,"real","complex"),r=E(n,"imag","complex");return Pr(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`),k.runKernel(y0,{real:t,imag:r})}});function Hl(e,n,t,r){if(null==r)r=xc(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(lH(e)||aH(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return k.backend.createTensorFromGPUData(e,n||t,r)}if(!lr(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=n){Ks(n);const s=j(n),o=j(t);S(s===o,()=>`Based on the provided shape, [${n}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<t.length;++i){const l=i!==t.length-1||t[i]!==j(n.slice(i));S(t[i]===n[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${n}). `)}}return!lr(e)&&!Array.isArray(e)&&(e=[e]),n=n||t,e="string"!==r?Wl(e,r):Ki(e,[],!0),k.makeTensor(e,n,r)}function cs(e,n,t){return Hl(e,n,Xi(e,t),t)}const Dc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class pi{static join(n){return new pi(n).slice()}constructor(n){if(this.shards=[],this.previousShardIndex=0,null==n||(n instanceof Array||(n=[n]),0===(n=n.map(r=>lr(r)?r.buffer:r)).length))return;this.bufferUniformSize=n[0].byteLength;let t=0;for(let r=0;r<n.length;r++){const s=n[r];r!==n.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+s.byteLength;this.shards.push({buffer:s,start:t,end:o}),t=o}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(n=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(n=isNaN(Number(n))?0:n,t=isNaN(Number(t))?0:t,n=Math.max(0,n),(t=Math.min(this.byteLength,t))<=n)return new ArrayBuffer(0);const r=this.findShardForByte(n);if(-1===r)throw new Error(`Could not find start shard for byte ${n}`);const o=new ArrayBuffer(t-n),i=new Uint8Array(o);let a=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],d=n+a-u.start,h=a,p=Math.min(t,u.end)-u.start,m=new Uint8Array(u.buffer,d,p-d);if(i.set(m,h),a+=m.length,t<u.end)break}return o}findShardForByte(n){if(0===this.shards.length||n<0||n>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(n/this.bufferUniformSize),this.previousShardIndex;function t(s){return n<s.start?-1:n>=s.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const r=function wme(e,n){let t=0,r=e.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,o=n(e[s]);if(0===o)return s;o<0?r=s:t=s+1}return-1}(this.shards,t);return-1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function xme(){V().set("PROD",!0)}function Cme(){V().set("DEBUG",!0)}function Ime(){V().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function mH(e){V().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Sme(){k.disposeVariables()}function vo(){return k}function _C(){return k.memory()}function _me(e){return k.profile(e)}function L(e,n){return k.tidy(e,n)}function ot(e){La(e).forEach(t=>t.dispose())}function ur(e){return k.keep(e)}function Eme(e){return k.time(e)}function G1(e){return k.setBackend(e)}function gH(){return k.ready()}function Gy(){return k.backendName}function Dme(e){k.removeBackend(e)}function Nme(e){return k.findBackend(e)}function Tme(e){return k.findBackendFactory(e)}function q1(e,n,t=1){return k.registerBackend(e,n,t)}function EC(){return k.backend}function kme(e,n){V().setPlatform(e,n)}!function dme(e){tH=e}(mH);const jl=4;function K1(e,n){return X1.apply(this,arguments)}function X1(){return X1=F(function*(e,n){const t=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){const a=s[i],l=Array.isArray(e)?e[i].tensor:e[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=F(function*(h){const f=yield l.bytes(),p=f.reduce((y,v)=>y+v.length,0)+jl*f.length,m=new Uint8Array(p);let g=0;for(let y=0;y<f.length;y++){const v=f[y],b=new Uint8Array(new Uint32Array([v.length]).buffer);m.set(b,g),g+=jl,m.set(v,g),g+=v.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(c)}else r.push(l.data());null!=n&&(u.group=n),t.push(u)}return{data:Mme(yield Promise.all(r)),specs:t}}),X1.apply(this,arguments)}function yH(e,n){const t=new pi(e),r={};let s=0;for(const o of n){const i=Ame(o,(a,l)=>t.slice(s+a,s+l));r[o.name]=vH(o,t.slice(s,s+i)),s+=i}return r}function Ame(e,n){const t=j(e.shape);let r;if("quantization"in e)r=Dc[e.quantization.dtype];else{if("string"===e.dtype){let s=0;for(let o=0;o<t;o++)s+=jl+new Uint32Array(n(s,s+jl))[0];return s}r=Dc[e.dtype]}return t*r}function Rme(e,n){return Y1.apply(this,arguments)}function Y1(){return(Y1=F(function*(e,n){const t=j(e.shape);let r;if("quantization"in e)r=Dc[e.quantization.dtype];else{if("string"===e.dtype){let s=0;for(let o=0;o<t;o++)s+=jl+new Uint32Array(yield n(s,s+jl))[0];return s}r=Dc[e.dtype]}return t*r})).apply(this,arguments)}function vH(e,n){const t=e.name,r=e.dtype,s=e.shape,o=j(s);let i,a=0;if("quantization"in e){const l=e.quantization;if("uint8"===l.dtype||"uint16"===l.dtype){if(!("min"in l)||!("scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==l.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}const u=Dc[l.dtype],c="uint8"===l.dtype?new Uint8Array(n):new Uint16Array(n);if("float32"===r)if("uint8"===l.dtype||"uint16"===l.dtype){i=new Float32Array(c.length);for(let d=0;d<c.length;d++)i[d]=c[d]*l.scale+l.min}else{if("float16"!==l.dtype)throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);i=function Vme(){const e=function $me(){const e=t=>{let r=t<<13,s=0;for(;!(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},n=new Uint32Array(2048);n[0]=0;for(let t=1;t<1024;t++)n[t]=e(t);for(let t=1024;t<2048;t++)n[t]=939524096+(t-1024<<13);return n}(),n=function Pme(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let n=1;n<31;n++)e[n]=n<<23;for(let n=33;n<63;n++)e[n]=2147483648+(n-32<<23);return e}(),t=function Lme(){const e=new Uint32Array(64);for(let n=0;n<64;n++)e[n]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i];o[i]=e[t[a>>10]+(1023&a)]+n[a>>10]}return new Float32Array(s)}}()(c)}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${t}': ${r}`);if("uint8"!==l.dtype&&"uint16"!==l.dtype)throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let d=0;d<c.length;d++)i[d]=Math.round(c[d]*l.scale+l.min)}a+=o*u}else if("string"===r){const l=j(e.shape);i=[];for(let u=0;u<l;u++){const c=new Uint32Array(n.slice(a,a+jl))[0];a+=jl;const d=new Uint8Array(n.slice(a,a+c));i.push(d),a+=c}}else{const l=Dc[r];if("float32"===r)i=new Float32Array(n);else if("int32"===r)i=new Int32Array(n);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(n);const u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let p=0;p<u.length;p++)u[p]=i[2*p],c[p]=i[2*p+1];const d=cs(u,s,"float32"),h=cs(c,s,"float32"),f=Va(d,h);return d.dispose(),h.dispose(),f}throw new Error(`Unsupported dtype in weight '${t}': ${r}`)}i=new Uint8Array(n)}a+=o*l}return cs(i,s,r)}function bH(e,n,t){return Z1.apply(this,arguments)}function Z1(){return(Z1=F(function*(e,n,t){let r=new Uint8Array(n);for(;r.byteLength<t;){const{done:s,value:o}=yield e.read();if(s&&null==o)throw new Error(`Reader is done but ${t-r.byteLength} bytes are still expected`);const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer})).apply(this,arguments)}function wH(e,n){return Q1.apply(this,arguments)}function Q1(){return Q1=F(function*(e,n){const t={},r=e.getReader();let s=new ArrayBuffer(0);for(const o of n){const i=yield Rme(o,function(){var u=F(function*(c,d){return s=yield bH(r,s,d),s.slice(c,d)});return function(c,d){return u.apply(this,arguments)}}());s=yield bH(r,s,i);const a=s.slice(0,i);s=s.slice(i);const l=vH(o,a);if(t[o.name]=l,"webgpu"===Gy()){const u=EC();"uploadToGPU"in u&&j(l.shape)>=V().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return t}),Q1.apply(this,arguments)}function Mme(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let n=0;const t=[];e.forEach(o=>{if(n+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(n);let s=0;return t.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const J1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function xH(e){return J1?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function CH(e){return pi.join(e)}function IH(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function SH(e,n){const t={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};return null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig),t}function _H(e,n,t){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!n)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=n,r.weightData=t}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}function ek(e,n){return tk.apply(this,arguments)}function tk(){return(tk=F(function*(e,n){let t,r;return null!=e.weightsManifest&&([t,r]=yield n(e.weightsManifest)),_H(e,t,r)})).apply(this,arguments)}function qy(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:xH(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:xH(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new pi(e.weightData).byteLength}}function nk(e){const n=[];for(const t of e)n.push(...t.weights);return n}class En{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==En.instance&&(En.instance=new En),En.instance}static registerSaveRouter(n){En.getInstance().saveRouters.push(n)}static registerLoadRouter(n){En.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return En.getHandlers(n,"save")}static getLoadHandlers(n,t){return En.getHandlers(n,"load",t)}static getHandlers(n,t,r){const s=[];return("load"===t?En.getInstance().loadRouters:En.getInstance().saveRouters).forEach(i=>{const a=i(n,r);null!==a&&s.push(a)}),s}}const Bme=e=>En.registerSaveRouter(e),zme=e=>En.registerLoadRouter(e),EH=e=>En.getSaveHandlers(e),Ume=(e,n)=>En.getLoadHandlers(e,n),DC="tensorflowjs",Nc="models_store",Gl="model_info_store";function ok(){if(!V().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,n=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==n)throw new Error("The current browser does not appear to support IndexedDB.");return n}function ik(e){const n=e.result;n.createObjectStore(Nc,{keyPath:"modelPath"}),n.createObjectStore(Gl,{keyPath:"modelPath"})}let Ff=(()=>{class e{constructor(t){if(this.indexedDB=ok(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}save(t){var r=this;return F(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,t)})()}load(){var t=this;return F(function*(){return t.databaseAction(t.modelPath)})()}databaseAction(t,r){return new Promise((s,o)=>{const i=this.indexedDB.open(DC,1);i.onupgradeneeded=()=>ik(i),i.onsuccess=()=>{const a=i.result;if(null==r){const l=a.transaction(Nc,"readonly"),c=l.objectStore(Nc).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=d=>(a.close(),o(c.error)),l.oncomplete=()=>a.close()}else{r.weightData=pi.join(r.weightData);const l=qy(r),u=a.transaction(Gl,"readwrite");let d,h,c=u.objectStore(Gl);try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(f){return o(f)}d.onsuccess=()=>{h=a.transaction(Nc,"readwrite");const f=h.objectStore(Nc);let p;try{p=f.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(m){return o(m)}p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=m=>{c=u.objectStore(Gl);const g=c.delete(this.modelPath);g.onsuccess=()=>(a.close(),o(p.error)),g.onerror=y=>(a.close(),o(p.error))}},d.onerror=f=>(a.close(),o(d.error)),u.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>o(i.error)})}}return e.URL_SCHEME="indexeddb://",e})();const DH=e=>V().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ff.URL_SCHEME)?function Wme(e){return new Ff(e)}(e.slice(Ff.URL_SCHEME.length)):null;En.registerSaveRouter(DH),En.registerLoadRouter(DH);class jme{constructor(){this.indexedDB=ok()}listModels(){var n=this;return F(function*(){return new Promise((t,r)=>{const s=n.indexedDB.open(DC,1);s.onupgradeneeded=()=>ik(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(Gl,"readonly"),l=i.objectStore(Gl).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;t(u)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()},s.onerror=o=>r(s.error)})})()}removeModel(n){var t=this;return F(function*(){return n=function Hme(e){return e.startsWith(Ff.URL_SCHEME)?e.slice(Ff.URL_SCHEME.length):e}(n),new Promise((r,s)=>{const o=t.indexedDB.open(DC,1);o.onupgradeneeded=()=>ik(o),o.onsuccess=()=>{const i=o.result,a=i.transaction(Gl,"readwrite"),l=a.objectStore(Gl),u=l.get(n);let c;u.onsuccess=()=>{if(null==u.result)return i.close(),s(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{const d=l.delete(n),h=()=>{c=i.transaction(Nc,"readwrite");const p=c.objectStore(Nc).delete(n);p.onsuccess=()=>r(u.result.modelArtifactsInfo),p.onerror=m=>s(u.error)};d.onsuccess=h,d.onerror=f=>(h(),i.close(),s(u.error))}},u.onerror=d=>(i.close(),s(u.error)),a.oncomplete=()=>{null==c?i.close():c.oncomplete=()=>i.close()}},o.onerror=i=>s(o.error)})})()}}const Yi="/",Tc="tensorflowjs_models",NH="info",Gme="model_topology",qme="weight_specs",Kme="weight_data",Xme="model_metadata";function TH(e){return{info:[Tc,e,NH].join(Yi),topology:[Tc,e,Gme].join(Yi),weightSpecs:[Tc,e,qme].join(Yi),weightData:[Tc,e,Kme].join(Yi),modelMetadata:[Tc,e,Xme].join(Yi)}}function kH(e){for(const n of Object.values(e))window.localStorage.removeItem(n)}function AH(e){const n=e.split(Yi);if(n.length<3)throw new Error(`Invalid key format: ${e}`);return n.slice(1,n.length-1).join(Yi)}let $f=(()=>{class e{constructor(t){if(!V().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=TH(this.modelPath)}save(t){var r=this;return F(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(t.modelTopology),o=JSON.stringify(t.weightSpecs),i=qy(t),a=pi.join(t.weightData);try{return r.LS.setItem(r.keys.info,JSON.stringify(i)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,o),r.LS.setItem(r.keys.weightData,function Ome(e){if(J1)return Buffer.from(e).toString("base64");const n=new Uint8Array(e);let t="";for(let r=0,s=n.length;r<s;r++)t+=String.fromCharCode(n[r]);return btoa(t)}(a)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,initializerSignature:null!=t.initializerSignature?t.initializerSignature:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0})),{modelArtifactsInfo:i}}catch{throw kH(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}})()}load(){var t=this;return F(function*(){const r=JSON.parse(t.LS.getItem(t.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${t.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},o=JSON.parse(t.LS.getItem(t.keys.topology));if(null==o)throw new Error(`In local storage, the topology of model '${t.modelPath}' is missing.`);s.modelTopology=o;const i=JSON.parse(t.LS.getItem(t.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${t.modelPath}' are missing.`);s.weightSpecs=i;const a=t.LS.getItem(t.keys.modelMetadata);if(null!=a){const u=JSON.parse(a);s.format=u.format,s.generatedBy=u.generatedBy,s.convertedBy=u.convertedBy,null!=u.signature&&(s.signature=u.signature),null!=u.userDefinedMetadata&&(s.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(s.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(s.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(s.trainingConfig=u.trainingConfig)}const l=t.LS.getItem(t.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${t.modelPath}' are missing.`);return s.weightData=function Fme(e){if(J1){const r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const n=atob(e),t=new Uint8Array(n.length);for(let r=0;r<n.length;++r)t.set([n.charCodeAt(r)],r);return t.buffer}(l),s})()}}return e.URL_SCHEME="localstorage://",e})();const RH=e=>V().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith($f.URL_SCHEME)?function Zme(e){return new $f(e)}(e.slice($f.URL_SCHEME.length)):null;En.registerSaveRouter(RH),En.registerLoadRouter(RH);class Qme{constructor(){S(V().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var n=this;return F(function*(){const t={},r=Tc+Yi,s=Yi+NH;for(let o=0;o<n.LS.length;++o){const i=n.LS.key(o);i.startsWith(r)&&i.endsWith(s)&&(t[AH(i)]=JSON.parse(n.LS.getItem(i)))}return t})()}removeModel(n){var t=this;return F(function*(){const r=TH(n=function Yme(e){return e.startsWith($f.URL_SCHEME)?e.slice($f.URL_SCHEME.length):e}(n));if(null==t.LS.getItem(r.info))throw new Error(`Cannot find model at path '${n}'`);const s=JSON.parse(t.LS.getItem(r.info));return kH(r),s})()}}const Pf="://";class ds{constructor(){this.managers={}}static getInstance(){return null==ds.instance&&(ds.instance=new ds),ds.instance}static registerManager(n,t){S(null!=n,()=>"scheme must not be undefined or null."),n.endsWith(Pf)&&(n=n.slice(0,n.indexOf(Pf))),S(n.length>0,()=>"scheme must not be an empty string.");const r=ds.getInstance();S(null==r.managers[n],()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=t}static getManager(n){const t=ds.getInstance().managers[n];if(null==t)throw new Error(`Cannot find model manager for scheme '${n}'`);return t}static getSchemes(){return Object.keys(ds.getInstance().managers)}}function NC(e){if(-1===e.indexOf(Pf))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ds.getSchemes().join(",")}`);return{scheme:e.split(Pf)[0],path:e.split(Pf)[1]}}function MH(e,n){return ak.apply(this,arguments)}function ak(){return(ak=F(function*(e,n,t=!1){S(e!==n,()=>`Old path and new path are the same: '${e}'`);const r=En.getLoadHandlers(e);S(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),S(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);const s=r[0],o=En.getSaveHandlers(n);S(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${n}.`),S(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${n}.`);const i=o[0],a=NC(e).scheme,l=NC(e).path,u=a===NC(e).scheme,c=yield s.load();t&&u&&(yield ds.getManager(a).removeModel(l));const d=yield i.save(c);return t&&!u&&(yield ds.getManager(a).removeModel(l)),d.modelArtifactsInfo})).apply(this,arguments)}function Jme(){return lk.apply(this,arguments)}function lk(){return(lk=F(function*(){const e=ds.getSchemes(),n={};for(const t of e){const r=yield ds.getManager(t).listModels();for(const s in r)n[t+Pf+s]=r[s]}return n})).apply(this,arguments)}function ege(e){return uk.apply(this,arguments)}function uk(){return(uk=F(function*(e){const n=NC(e);return ds.getManager(n.scheme).removeModel(n.path)})).apply(this,arguments)}function tge(e,n){return ck.apply(this,arguments)}function ck(){return(ck=F(function*(e,n){return MH(e,n,!1)})).apply(this,arguments)}function nge(e,n){return dk.apply(this,arguments)}function dk(){return(dk=F(function*(e,n){return MH(e,n,!0)})).apply(this,arguments)}class rge{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(n,t){return fetch(n,t)}now(){return performance.now()}encode(n,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,t){return new TextDecoder(t).decode(n)}setTimeoutCustom(n,t){typeof window>"u"||!V().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(n,t):(this.functionRefs.push(n),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(n){return G4(n)}}if(V().get("IS_BROWSER")){V().setPlatform("browser",new rge);try{ds.registerManager($f.URL_SCHEME,new Qme)}catch{}try{ds.registerManager(Ff.URL_SCHEME,new jme)}catch{}}let Lf;function it(e,n="float32",t){return n=n||"float32",Ks(e),new Qn(e,n,t)}V().get("IS_NODE")&&!V().get("IS_BROWSER")&&V().setPlatform("node",new class oge{constructor(){this.util=U(590),this.textEncoder=new this.util.TextEncoder}fetch(n,t){return null!=V().global.fetch?V().global.fetch(n,t):(null==Lf&&(Lf=U(817)),Lf(n,t))}now(){const n=process.hrtime();return 1e3*n[0]+n[1]/1e6}encode(n,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(n)}decode(n,t){return 0===n.length?"":new this.util.TextDecoder(t).decode(n)}isTypedArray(n){return this.util.types.isFloat32Array(n)||this.util.types.isInt32Array(n)||this.util.types.isUint8Array(n)||this.util.types.isUint8ClampedArray(n)}});const pe=R({cast_:function ige(e,n){const t=E(e,"x","cast");if(!F4(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if("string"===n&&"string"!==t.dtype||"string"!==n&&"string"===t.dtype)throw new Error("Only strings can be casted to strings");return k.runKernel(Uh,{x:t},{dtype:n})}}),Zi=R({clone_:function age(e){const t={x:E(e,"x","clone","string_or_numeric")};return k.runKernel(nf,t)}});function hk(e,n=!1){console.log(e.toString(n))}hH(),function cme(e){Of=e}({buffer:it,cast:pe,clone:Zi,print:hk});const ne=R({add_:function lge(e,n){let t=E(e,"a","add"),r=E(n,"b","add");return[t,r]=_n(t,r),k.runKernel(Ic,{a:t,b:r})}}),TC=R({floorDiv_:function uge(e,n){let t=E(e,"a","floorDiv"),r=E(n,"b","floorDiv");return[t,r]=_n(t,r),k.runKernel(Jh,{a:t,b:r})}}),ke=R({div_:function cge(e,n){let t=E(e,"a","div"),r=E(n,"b","div");return[t,r]=_n(t,r),"int32"===t.dtype&&"int32"===r.dtype?TC(t,r):k.runKernel(qh,{a:t,b:r},{})}}),M=R({mul_:function dge(e,n){let t=E(e,"a","mul"),r=E(n,"b","mul");return[t,r]=_n(t,r),k.runKernel(ff,{a:t,b:r})}}),Nr=R({sqrt_:function hge(e){const t={x:E(e,"x","sqrt","float32")};return k.runKernel(Ef,t)}}),Kt=R({square_:function fge(e){const n=E(e,"x","square");return k.runKernel("Square",{x:n},{})}}),_t=R({zerosLike_:function pge(e){const t={x:E(e,"x","zerosLike")};return k.runKernel(Oy,t)}});function mge(e){return S(zl(e),()=>"The f passed in grad(f) must be a function"),(n,t)=>{const r=E(n,"x","tf.grad","string_or_numeric"),s=null!=t?E(t,"dy","tf.grad"):null;return k.tidy(()=>{const{value:o,grads:i}=k.gradients(()=>e(r),[r],s);return null!=s&&Pr(o.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),kC(i),i[0]})}}function gge(e){return S(zl(e),()=>"The f passed in grads(f) must be a function"),(n,t)=>{S(Array.isArray(n),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=jy(n,"args","tf.grads","string_or_numeric"),s=null!=t?E(t,"dy","tf.grads"):null;return k.tidy(()=>{const{value:o,grads:i}=k.gradients(()=>e(...r),r,s);return null!=s&&Pr(o.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),kC(i),i})}}function yge(e){return S(zl(e),()=>"The f passed in valueAndGrad(f) must be a function"),(n,t)=>{S(n instanceof St,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),S(null==t||t instanceof St,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=k.gradients(()=>e(n),[n],t);return kC(r),{grad:r[0],value:s}}}function vge(e){return S(zl(e),()=>"The f passed in valueAndGrads(f) must be a function"),(n,t)=>{S(Array.isArray(n)&&n.every(s=>s instanceof St),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),S(null==t||t instanceof St,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=k.gradients(()=>e(...n),n,t);return null!=t&&Pr(r.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),kC(r.grads),r}}function OH(e,n){S(zl(e),()=>"The f passed in variableGrads(f) must be a function"),S(null==n||Array.isArray(n)&&n.every(u=>u instanceof Hy),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=null!=n;if(!t){n=[];for(const u in k.registeredVariables)n.push(k.registeredVariables[u])}const r=t?n.filter(u=>!u.trainable):null,s=n.length;S((n=n.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:i,grads:a}=k.gradients(e,n,null,!0);S(a.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return n.forEach((u,c)=>{null!=a[c]&&(l[u.name]=a[c])}),r?.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Qi(e){return k.customGrad(e)}function kC(e){if(e.filter(t=>null==t).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function Re(e,n){if((lr(e)&&"string"!==n||Array.isArray(e))&&"complex64"!==n)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===n&&lr(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Hl(e,[],[],n)}const bge=new Map,fk=new Map;class kc{getClassName(){return this.constructor.className}static fromConfig(n,t){return new n(t)}}class bo{constructor(){this.classNameMap={}}static getMap(){return null==bo.instance&&(bo.instance=new bo),bo.instance}static register(n){bo.getMap().classNameMap[n.className]=[n,n.fromConfig]}}function oe(e,n,t){S(null!=e.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),S(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof n>"u"&&(n="Custom"),typeof t>"u"&&(t=e.className);const s=n+">"+t;return bo.register(e),bge.set(s,e),fk.set(e,s),e}function wge(e){return fk.has(e)?fk.get(e):e.className}class Ba extends kc{minimize(n,t=!1,r){const{value:s,grads:o}=this.computeGradients(n,r);if(null!=r){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return ot(o),t?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,t){return OH(n,t)}dispose(){null!=this.iterations_&&ot(this.iterations_)}saveIterations(){var n=this;return F(function*(){return null==n.iterations_&&(n.iterations_=0),{name:"iter",tensor:Re(n.iterations_,"int32")}})()}getWeights(){return F(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(n){var t=this;return F(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${t.getClassName()}`)})()}extractIterations(n){var t=this;return F(function*(){return t.iterations_=(yield n[0].tensor.data())[0],n.slice(1)})()}}Object.defineProperty(Ba,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class pk extends Ba{static get className(){return"Adadelta"}constructor(n,t,r=null){super(),this.learningRate=n,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=k.backend.epsilon())}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=k.registeredVariables[r],i=!1;null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:L(()=>_t(o).variable(i))}),null==this.accumulatedUpdates[s]&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:L(()=>_t(o).variable(i))});const a=Array.isArray(n)?n[s].tensor:n[r];if(null==a)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;L(()=>{const c=ne(M(l,this.rho),M(Kt(a),1-this.rho)),d=M(ke(Nr(ne(u,this.epsilon)),Nr(ne(l,this.epsilon))),a),h=ne(M(u,this.rho),M(Kt(d),1-this.rho));l.assign(c),u.assign(h);const f=ne(M(d,-this.learningRate),o);o.assign(f)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ot(this.accumulatedGrads.map(n=>n.variable)),ot(this.accumulatedUpdates.map(n=>n.variable)))}getWeights(){var n=this;return F(function*(){const t=[...n.accumulatedGrads,...n.accumulatedUpdates];return[yield n.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var t=this;return F(function*(){const r=(n=yield t.extractIterations(n)).length/2,s=!1;t.accumulatedGrads=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),t.accumulatedUpdates=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(n,t){return new n(t.learningRate,t.rho,t.epsilon)}}function Ac(e,n,t){return Ks(e),t=t||xc(n),k.runKernel(O0,{},{shape:e,value:n,dtype:t})}class mk extends Ba{static get className(){return"Adagrad"}constructor(n,t=.1){super(),this.learningRate=n,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=k.registeredVariables[r];null==this.accumulatedGrads[s]&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:L(()=>Ac(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(n)?n[s].tensor:n[r];if(null==i)return;const a=this.accumulatedGrads[s].variable;L(()=>{const l=ne(a,Kt(i));a.assign(l);const u=ne(M(ke(i,Nr(ne(l,k.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ot(this.accumulatedGrads.map(n=>n.variable))}getWeights(){var n=this;return F(function*(){return[yield n.saveIterations()].concat(n.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(n){var t=this;return F(function*(){n=yield t.extractIterations(n),t.accumulatedGrads=n.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(n,t){return new n(t.learningRate,t.initialAccumulatorValue)}}const Ji=R({pow_:function xge(e,n){let t=E(e,"base","pow"),r=E(n,"exp","pow");return[t,r]=_n(t,r),k.runKernel(pf,{a:t,b:r})}}),Ce=R({sub_:function Cge(e,n){let t=E(e,"a","sub"),r=E(n,"b","sub");return[t,r]=_n(t,r),k.runKernel(Nf,{a:t,b:r})}});class gk extends Ba{static get className(){return"Adam"}constructor(n,t,r,s=null){super(),this.learningRate=n,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],L(()=>{this.accBeta1=Re(t).variable(),this.accBeta2=Re(r).variable()}),null==s&&(this.epsilon=k.backend.epsilon())}applyGradients(n){const t=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);L(()=>{const r=Ce(1,this.accBeta1),s=Ce(1,this.accBeta2);t.forEach((o,i)=>{const a=k.registeredVariables[o],l=!1;null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:L(()=>_t(a).variable(l))}),null==this.accumulatedSecondMoment[i]&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:L(()=>_t(a).variable(l))});const u=Array.isArray(n)?n[i].tensor:n[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=ne(M(c,this.beta1),M(u,1-this.beta1)),f=ne(M(d,this.beta2),M(Kt(u),1-this.beta2)),p=ke(h,r),m=ke(f,s);c.assign(h),d.assign(f);const g=ne(M(ke(p,ne(Nr(m),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(M(this.accBeta1,this.beta1)),this.accBeta2.assign(M(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ot(this.accumulatedFirstMoment.map(n=>n.variable)),null!=this.accumulatedSecondMoment&&ot(this.accumulatedSecondMoment.map(n=>n.variable))}getWeights(){var n=this;return F(function*(){const t=[...n.accumulatedFirstMoment,...n.accumulatedSecondMoment];return[yield n.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var t=this;return F(function*(){n=yield t.extractIterations(n),L(()=>{t.accBeta1.assign(Ji(t.beta1,t.iterations_+1)),t.accBeta2.assign(Ji(t.beta2,t.iterations_+1))});const r=n.length/2,s=!1;t.accumulatedFirstMoment=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),t.accumulatedSecondMoment=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(n,t){return new n(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Jn=R({abs_:function Ige(e){const n=E(e,"x","abs");return k.runKernel("complex64"===n.dtype?zg:Rg,{x:n})}});function Rc(e,n){const t=e.length,r=[];for(let s=0;s<t;s++){const o=t-1-s;(n[n.length-1-s]||1)>1&&1===(e[o]||1)&&r.unshift(o)}return r}function er(e,n){const t=[];for(let r=0;r<n.length;r++){const s=e[e.length-r-1],o=n.length-r-1;(null==s||1===s&&n[o]>1)&&t.unshift(o)}return t}function et(e,n){const t=Math.max(e.length,n.length),r=new Array(t);for(let s=0;s<t;s++){let o=e[e.length-s-1];null==o&&(o=1);let i=n[n.length-s-1];if(null==i&&(i=1),1===o)r[t-s-1]=i;else if(1===i)r[t-s-1]=o;else{if(o!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${n}.`);r[t-s-1]=o}}return r}const ea=R({maximum_:function Sge(e,n){let t=E(e,"a","maximum"),r=E(n,"b","maximum");return[t,r]=_n(t,r),"bool"===t.dtype&&(t=pe(t,"int32"),r=pe(r,"int32")),et(t.shape,r.shape),k.runKernel(cf,{a:t,b:r})}});class yk extends Ba{static get className(){return"Adamax"}constructor(n,t,r,s=null,o=0){super(),this.learningRate=n,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],L(()=>{this.iteration=Re(0).variable(),this.accBeta1=Re(t).variable()}),null==s&&(this.epsilon=k.backend.epsilon())}applyGradients(n){const t=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);L(()=>{const r=Ce(1,this.accBeta1),s=ke(-this.learningRate,ne(M(this.iteration,this.decay),1));t.forEach((o,i)=>{const a=k.registeredVariables[o],l=!1;null==this.accumulatedFirstMoment[i]&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:_t(a).variable(l)}),null==this.accumulatedWeightedInfNorm[i]&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:_t(a).variable(l)});const u=Array.isArray(n)?n[i].tensor:n[o];if(null==u)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=ne(M(c,this.beta1),M(u,1-this.beta1)),f=M(d,this.beta2),p=Jn(u),m=ea(f,p);c.assign(h),d.assign(m);const g=ne(M(ke(s,r),ke(h,ne(m,this.epsilon))),a);a.assign(g)}),this.iteration.assign(ne(this.iteration,1)),this.accBeta1.assign(M(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ot(this.accumulatedFirstMoment.map(n=>n.variable)),null!=this.accumulatedWeightedInfNorm&&ot(this.accumulatedWeightedInfNorm.map(n=>n.variable))}getWeights(){return F(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(n){return F(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(n,t){return new n(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class AC extends Ba{static get className(){return"SGD"}constructor(n){super(),this.learningRate=n,this.setLearningRate(n)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=Array.isArray(n)?n[s].tensor:n[r];if(null==o)return;const i=k.registeredVariables[r];L(()=>{const a=ne(M(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(n){this.learningRate=n,null!=this.c&&this.c.dispose(),this.c=ur(Re(-n))}dispose(){this.c.dispose()}getWeights(){var n=this;return F(function*(){return[yield n.saveIterations()]})()}setWeights(n){var t=this;return F(function*(){if(0!==(n=yield t.extractIterations(n)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(n,t){return new n(t.learningRate)}}class vk extends AC{static get className(){return"Momentum"}constructor(n,t,r=!1){super(n),this.learningRate=n,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=Re(this.momentum)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=k.registeredVariables[r];null==this.accumulations[s]&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:L(()=>_t(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(n)?n[s].tensor:n[r];null!=a&&L(()=>{let l;const u=ne(M(this.m,i),a);l=ne(M(this.c,this.useNesterov?ne(a,M(u,this.m)):u),o),i.assign(u),o.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ot(this.accumulations.map(n=>n.variable))}setMomentum(n){this.momentum=n}getWeights(){var n=this;return F(function*(){return[yield n.saveIterations()].concat(n.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))})()}setWeights(n){var t=this;return F(function*(){n=yield t.extractIterations(n),t.accumulations=n.map(s=>({originalName:s.name,variable:s.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(n,t){return new n(t.learningRate,t.momentum,t.useNesterov)}}class bk extends Ba{static get className(){return"RMSProp"}constructor(n,t=.9,r=0,s=null,o=!1){if(super(),this.learningRate=n,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==s&&(this.epsilon=k.backend.epsilon()),null==n)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,s)=>{const o=k.registeredVariables[r],i=!1;null==this.accumulatedMeanSquares[s]&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:L(()=>_t(o).variable(i))}),null==this.accumulatedMoments[s]&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:L(()=>_t(o).variable(i))}),null==this.accumulatedMeanGrads[s]&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:L(()=>_t(o).variable(i))});const a=Array.isArray(n)?n[s].tensor:n[r];if(null==a)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;L(()=>{const c=ne(M(l,this.decay),M(Kt(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=ne(M(d,this.decay),M(a,1-this.decay)),f=ke(M(a,this.learningRate),Nr(Ce(c,ne(Kt(h),this.epsilon)))),p=ne(M(u,this.momentum),f);l.assign(c),d.assign(h),u.assign(p);const m=Ce(o,p);o.assign(m)}else{const d=ne(M(l,this.decay),M(Kt(a),1-this.decay)),h=ne(M(u,this.momentum),ke(M(a,this.learningRate),Nr(ne(d,this.epsilon))));l.assign(d),u.assign(h);const f=Ce(o,h);o.assign(f)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ot(this.accumulatedMeanSquares.map(n=>n.variable)),null!=this.accumulatedMeanGrads&&this.centered&&ot(this.accumulatedMeanGrads.map(n=>n.variable)),null!=this.accumulatedMoments&&ot(this.accumulatedMoments.map(n=>n.variable))}getWeights(){var n=this;return F(function*(){const t=[...n.accumulatedMeanSquares,...n.accumulatedMoments];return n.centered&&t.push(...n.accumulatedMeanGrads),[yield n.saveIterations()].concat(t.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(n){var t=this;return F(function*(){n=yield t.extractIterations(n);const r=t.centered?n.length/3:n.length/2,s=!1;t.accumulatedMeanSquares=n.slice(0,r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),t.accumulatedMoments=n.slice(r,2*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),t.centered&&(t.accumulatedMeanGrads=n.slice(2*r,3*r).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(n,t){return new n(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const _ge=[pk,mk,gk,yk,vk,bk,AC];function FH(e){return new Promise(n=>setTimeout(n)).then(e)}let wk=(()=>{class e{constructor(t){if(!V().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),(null==t||0===t.length)&&(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}save(t){var r=this;return F(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=pi.join(t.weightData),o=window.URL.createObjectURL(new Blob([s],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const a=SH(t,[{paths:["./"+r.weightDataFileName],weights:t.weightSpecs}]),l=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),u=null==r.modelJsonAnchor?document.createElement("a"):r.modelJsonAnchor;if(u.download=r.modelJsonFileName,u.href=l,yield FH(()=>u.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const c=null==r.weightDataAnchor?document.createElement("a"):r.weightDataAnchor;c.download=r.weightDataFileName,c.href=o,yield FH(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:qy(t)}}})()}}return e.URL_SCHEME="downloads://",e})();class kge{constructor(n){if(null==n||n.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${n}`);this.jsonFile=n[0],this.weightsFiles=n.slice(1)}load(){var n=this;return F(function*(){return new Promise((t,r)=>{const s=new FileReader;s.onload=o=>{const i=JSON.parse(o.target.result),a=i.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${n.jsonFile.name}`));if(null==i.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${n.jsonFile.name}`));if(0===n.weightsFiles.length)return void t({modelTopology:a});const u=ek(i,c=>n.loadWeights(c));t(u)},s.onerror=o=>r(`Failed to read model topology and weights manifest JSON from file '${n.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(n.jsonFile)})})()}loadWeights(n){const t=[],r=[];for(const i of n)t.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(n),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[t,i])}loadWeightsFile(n,t){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{r(i.target.result)},o.onerror=i=>s(`Failed to weights data from file of path '${n}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(n){const t=[],r=this.weightsFiles.map(o=>IH(o.name)),s={};for(const o of n)o.paths.forEach(i=>{const a=IH(i);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function Mge(e){return new kge(e)}function $H(e,n,t,r){(function i(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(e),function a(l,u){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),S(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(t=t??0,r=r??1);let s=0;return Promise.all(e.map(l=>(l.then(u=>{const c=t+ ++s/e.length*(r-t);return n(c),u}),l)))}function PH(e,n){return xk.apply(this,arguments)}function xk(){return(xk=F(function*(e,n){null==n&&(n={});const t=null==n.fetchFunc?V().platform.fetch:n.fetchFunc,r=e.map(d=>t(d,n.requestInit,{isBinary:!0})),a=(null==n.onProgress?yield Promise.all(r):yield $H(r,n.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==n.onProgress?yield Promise.all(a):yield $H(a,n.onProgress,.5,1)})).apply(this,arguments)}function Fge(e){return Ck.apply(this,arguments)}function Ck(){return(Ck=F(function*(e,n="",t,r){return LH(i=>PH(i,{requestInit:r}))(e,n,t)})).apply(this,arguments)}function LH(e){return function(){var n=F(function*(t,r="",s){const o=t.map(()=>!1),i={},a=null!=s?s.map(()=>!1):[],l=[];if(t.forEach((p,m)=>{let g=0;p.weights.forEach(y=>{const b=Dc["quantization"in y?y.quantization.dtype:y.dtype]*j(y.shape),w=()=>{o[m]=!0,null==i[m]&&(i[m]=[]),i[m].push({manifestEntry:y,groupOffset:g,sizeBytes:b})};null!=s?s.forEach((x,I)=>{x===y.name&&(w(),a[I]=!0)}):w(),l.push(y.name),g+=b})}),!a.every(p=>p)){const p=s.filter((m,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const u=o.reduce((p,m,g)=>(m&&p.push(g),p),[]),c=[];u.forEach(p=>{t[p].paths.forEach(m=>{const g=r+(r.endsWith("/")?"":"/")+m;c.push(g)})});const d=yield e(c),h={};let f=0;return u.forEach(p=>{const m=t[p].paths.length,g=new pi(d.slice(f,f+m));i[p].forEach(v=>{const w=yH(g.slice(v.groupOffset,v.groupOffset+v.sizeBytes),[v.manifestEntry]);for(const x in w)h[x]=w[x]}),f+=m}),h});return function(t){return n.apply(this,arguments)}}()}En.registerSaveRouter(e=>V().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(wk.URL_SCHEME)?function Rge(e="model"){return new wk(e)}(e.slice(wk.URL_SCHEME.length)):null);let VH=(()=>{class e{constructor(t,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(S("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=V().platform.fetch,S(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&S(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}save(t){var r=this;return F(function*(){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const i=SH(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);if(s.body.append("model.json",new Blob([JSON.stringify(i)],{type:"application/json"}),"model.json"),null!=t.weightData){const l=pi.join(t.weightData);s.body.append("model.weights.bin",new Blob([l],{type:"application/octet-stream"}),"model.weights.bin")}const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:qy(t),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}loadModelJSON(){var t=this;return F(function*(){const r=yield t.fetch(t.path,t.requestInit);if(!r.ok)throw new Error(`Request to ${t.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${t.path}.`;throw t.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${t.path} contains neither model topology or manifest for weights.`);return s})()}load(){var t=this;return F(function*(){return t.loadOptions.streamWeights?t.loadStream():ek(yield t.loadModelJSON(),s=>t.loadWeights(s))})()}loadStream(){var t=this;return F(function*(){const r=yield t.loadModelJSON(),s=yield t.getWeightUrls(r.weightsManifest),o=nk(r.weightsManifest);return Object.assign(Object.assign({},r),{weightSpecs:o,getWeightStream:()=>function Oge(e,n){var t;const r=null==n.fetchFunc?V().platform.fetch:n.fetchFunc;let o,s=0;return null===(t=n.onProgress)||void 0===t||t.call(n,0),new ReadableStream({pull:(i=F(function*(a){for(var l;s<e.length;){o||(o=(yield r(e[s],n.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:c}=yield o.read();if(!u)return void a.enqueue(c);s++,o=void 0,null===(l=n.onProgress)||void 0===l||l.call(n,s/e.length)}a.close()}),function(l){return i.apply(this,arguments)})});var i}(s,t.loadOptions)})})()}getWeightUrls(t){var r=this;return F(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[o,i]=function Lge(e){const n=e.lastIndexOf("/"),t=e.lastIndexOf("?");return[e.substring(0,n)+"/",t>n?e.substring(t):""]}(s),a=r.weightPathPrefix||o,l=[],u=[];for(const c of t)for(const d of c.paths)null!=r.weightUrlConverter?u.push(r.weightUrlConverter(d)):l.push(a+d+i);return r.weightUrlConverter&&l.push(...yield Promise.all(u)),l})()}loadWeights(t){var r=this;return F(function*(){const s=yield r.getWeightUrls(t);return[nk(t),yield PH(s,r.loadOptions)]})()}}return e.URL_SCHEME_REGEX=/^https?:\/\//,e})();function Ik(e){return null!=e.match(VH.URL_SCHEME_REGEX)}const BH=(e,n)=>{if(typeof fetch>"u"&&(null==n||null==n.fetchFunc))return null;{let t=!0;if(t=Array.isArray(e)?e.every(r=>Ik(r)):Ik(e),t)return Sk(e,n)}return null};function Sk(e,n){return new VH(e,n)}function Vge(e,n){return Sk(e,n)}En.registerSaveRouter(BH),En.registerLoadRouter(BH);class _k{constructor(n){this.modelArtifacts=n}load(){return this.modelArtifacts}}class zH{constructor(n){this.saveHandler=n}save(n){return this.saveHandler(n)}}class Bge{constructor(n){n.load&&(this.load=()=>Promise.resolve(n.load())),n.save&&(this.save=t=>Promise.resolve(n.save(t)))}}function zge(e,n,t,r){return new Bge(UH(...arguments))}function UH(e,n,t,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new _k(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _k({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new _k({modelTopology:e,weightSpecs:n,weightData:t,trainingConfig:r}))}function Uge(e){return new zH(e)}function Wge(e){return new zH(e)}const at=R({matMul_:function Hge(e,n,t=!1,r=!1){let s=E(e,"a","matMul"),o=E(n,"b","matMul");return[s,o]=_n(s,o),k.runKernel(Lg,{a:s,b:o},{transposeA:t,transposeB:r})}}),Mc=R({oneHot_:function jge(e,n,t=1,r=0,s="int32"){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);const i={indices:E(e,"indices","oneHot","int32")};return k.runKernel(gy,i,{dtype:s,depth:n,onValue:t,offValue:r})}}),Ky=R({imag_:function Gge(e){const t={input:E(e,"input","imag")};return k.runKernel(L0,t)}}),on=R({neg_:function qge(e){const t={x:E(e,"x","neg")};return k.runKernel(fy,t)}}),Vf=R({real_:function Kge(e){const t={input:E(e,"input","real")};return k.runKernel(Q0,t)}}),Ct=R({transpose_:function Xge(e,n,t){const r=E(e,"x","transpose");if(null==n&&(n=r.shape.map((i,a)=>a).reverse()),S(r.rank===n.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${n}.`),n.forEach(i=>{S(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${n}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:n};return"complex64"===r.dtype?L(()=>{let i=Vf(r),a=Ky(r);return i=k.runKernel(Sc,{x:i},o),a=k.runKernel(Sc,{x:a},o),t&&(a=on(a)),Va(i,a)}):k.runKernel(Sc,s,o)}}),Zge=R({confusionMatrix_:function Yge(e,n,t){const r=E(e,"labels","confusionMatrix"),s=E(n,"predictions","confusionMatrix");S(null==t||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),S(1===r.rank,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),S(1===s.rank,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),S(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),S(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const o=Mc(pe(r,"int32"),t),i=Mc(pe(s,"int32"),t),a=Ct(o),l=at(a,i);return pe(l,"int32")}});function Ek(e,n,t){if(vc(e),null!=n&&3!==n.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Xi(e,t);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Hl(e,n,r,t)}let Oc,WH=!1;function HH(e,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(e.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)o=!0;else if(null!=e.getContext)i=!0;else{if(!(typeof ImageBitmap<"u"&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);a=!0}if(null!=Vy(yC,k.backendName))return k.runKernel(yC,{pixels:e},{numChannels:n});const[u,c]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let d,h;if(i)d=e.getContext("2d").getImageData(0,0,u,c).data;else if(r||t)d=e.data;else if(o||s||a){if(null==Oc)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Oc=new OffscreenCanvas(1,1).getContext("2d")}else Oc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Oc.canvas.width=u,Oc.canvas.height=c,Oc.drawImage(e,0,0,u,c),d=Oc.getImageData(0,0,u,c).data}if(4===n)h=new Int32Array(d);else{const p=u*c;h=new Int32Array(p*n);for(let m=0;m<p;m++)for(let g=0;g<n;++g)h[m*n+g]=d[4*m+g]}return Ek(h,[c,u,n],"int32")}function nye(e){return Dk.apply(this,arguments)}function Dk(){return(Dk=F(function*(e,n=3){let t=null;if(V().getBool("WRAP_TO_IMAGEBITMAP")&&function tye(e){return function Jge(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(e instanceof ImageBitmap)&&function eye(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function Qge(e){return null!=e&&e.data instanceof Uint8Array}(e)}(e)){let r;try{r=yield createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}t=null!=r&&r.width===e.width&&r.height===e.height?r:e}else t=e;return HH(t,n)})).apply(this,arguments)}function jH(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const n=2===e.rank?1:e.shape[2];if(n>4||2===n)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${n}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function sye(e,n){return Nk.apply(this,arguments)}function Nk(){return(Nk=F(function*(e,n){let t=E(e,"img","toPixels");if(!(e instanceof St)){const u=t;t=pe(u,"int32"),u.dispose()}jH(t);const[r,s]=t.shape.slice(0,2),o=2===t.rank?1:t.shape[2],i=yield t.data(),a="float32"===t.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){const c=[0,0,0,255];for(let h=0;h<o;h++){const f=i[u*o+h];if("float32"===t.dtype){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if("int32"===t.dtype&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);1===o?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[h]=f*a}const d=4*u;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(null!=n){WH||null!=Vy(k0,k.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),WH=!0),n.width=s,n.height=r;const u=n.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return t!==e&&t.dispose(),l})).apply(this,arguments)}function oye(e,n,t){let r=E(e,"img","draw");if(!(e instanceof St)){const i=r;r=pe(i,"int32"),i.dispose()}jH(r),function rye(e){const n=e?.alpha||1;if(n>1||n<0)throw new Error(`Alpha value ${n} is suppoed to be in range [0 - 1].`)}(t?.imageOptions),k.runKernel(k0,{image:r},{canvas:n,options:t})}const Tk=R({fromPixels_:HH});function RC(e,n){const t=e.shape.length,r=n.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==n.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${t}`);if(0===j(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=n.shape,o=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const a=e.shape,l=s.slice();l.pop();let u=1;for(let d=o;d<t;++d)u*=a[d],l.push(a[d]);const c=[...Oe(e.shape).map(d=>d/u),1].slice(0,o);return[l,i,u,c]}function kk(e,n,t){const r=n.rank>1?n.shape[n.rank-1]:1,s=n.rank>1?n.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${n.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(o+` update.rank < ${s}. `);if(e.length<r+(t.rank-s))throw new Error(o+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+e.length-r)throw new Error(o+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(t.shape[i]!==n.shape[i])throw new Error(o+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<t.rank-s;++i)if(t.shape[i+s]!==e[i+r])throw new Error(o+` updates.shape[${i+s}] (${t.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function MC(e,n,t){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==n.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(0===t.length){if(0===n.size)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}kk(t,n,e)}function ql(e,n,t){const r=n.shape.length,s=r>1?n.shape[r-1]:1,o=t.length;let i=1;for(let d=s;d<o;++d)i*=t[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:j(n.shape)/a,sliceSize:i,strides:[...Oe(t.slice(0,s)),1],outputSize:j(t)}}const Ak=-2,iye=-1;function Rk(e,n,t){const r=e.shape.length;S(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),S(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(n[s]+t[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${n[s]+t[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function aye(e){const n=[];let t=0;for(;e>0;)1&e&&n.push(t),e/=2,t++;return n}function Mk(e,n,t){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((n[s]-e[s])/t[s]);return r}function GH(e,n,t,r){const s=[...e];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<t;o++)0===o?s[n]=1:(s.splice(n,0,1),s.pop());return s}function qH(e,n,t){return t<=e?t:t-(n-1)}function KH(e,n){const t=[];for(let r=0;r<e;r++)t.push(n+r);return t}function lye(e,n,t,r,s,o,i,a,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(n.length&&t>0){const f=n[0],p=t+1;c=XH(i,f,p,r,e),d=YH(a,f,p,s,e),h=GH(o,f,p,e)}else for(let f=0;f<u;f++)c[f]=QH(i,r,o,e,f,l),d[f]=JH(a,s,o,e,f,l),h[f]=ZH(o,f,l);return{begin:c,end:d,strides:h}}function XH(e,n,t,r,s){const o=[...s],i=KH(t,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const l=qH(n,t,a);let u=r[l];e&1<<l&&(u=0),o[a]=u}return o}function YH(e,n,t,r,s){const o=[...s],i=KH(t,n);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const l=qH(n,t,a);let u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),o[a]=u}for(let a=0;a<o.length;a++)o[a]<0&&(o[a]+=s[a]),o[a]=Bl(0,o[a],s[a]);return o}function ZH(e,n,t){let r=e[n];return(t&1<<n||null==r)&&(r=1),r}function QH(e,n,t,r,s,o){let i=n[s];(e&1<<s||o&1<<s||null==i)&&(i=(t[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Bl(0,i,l-1),i}function JH(e,n,t,r,s,o){let i=n[s];const a=t[s]||1;(e&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=a>0?Bl(0,i,l):Bl(-1,i,l-1),i}function Ok(e,n,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(n[s]>0||t[s]!==e[s])return!1;return!0}function Fk(e,n){let t=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)t+=e[r]*n[r];return t}function OC(e,n,t){let r;const s=e.shape.length;let o;return r="number"==typeof n?[n,...new Array(s-1).fill(0)]:n.length<s?n.concat(new Array(s-n.length).fill(0)):n.slice(),r.forEach(i=>{S(-1!==i,()=>"slice() does not support negative begin indexing.")}),o=null==t?new Array(s).fill(-1):"number"==typeof t?[t,...new Array(s-1).fill(-1)]:t.length<s?t.concat(new Array(s-t.length).fill(-1)):t,o=o.map((i,a)=>i>=0?i:(S(-1===i,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),e.shape[a]-r[a])),[r,o]}function $k(e,n,t,r,s,o,i,a,l){let u;if(null==r?(u=new Array(n.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:t.slice(),strides:u.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&a&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function uye(e,n){n.beginMask=0,n.endMask=0,n.shrinkAxisMask=0;let t=0;n.beginValid=null!=e.begin,n.endValid=null!=e.end,n.begin=new Array(n.dims),n.end=new Array(n.dims),n.strides=new Array(n.dims),n.finalShapeGatherIndices=[],n.finalShapeGatherIndicesSparse=[],n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(n.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,n.dims);for(;t<s;t++)n.begin[t]=0,n.end[t]=0,n.strides[t]=1,n.beginMask|=1<<t,n.endMask|=1<<t,n.finalShapeGatherIndices.push(t),n.finalShapeGatherIndicesSparse.push(-1),n.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&e.newAxisMask)n.finalShapeGatherIndices.push(Ak),n.finalShapeGatherIndicesSparse.push(-1);else{if(t===n.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${n.dims} dims, ${n.begin.length}.`);null!=e.begin&&(n.begin[t]=e.begin[r]),null!=e.end&&(n.end[t]=e.end[r]),n.strides[t]=e.strides[r],e.beginMask&1<<r&&(n.beginMask|=1<<t),e.endMask&1<<r&&(n.endMask|=1<<t),e.shrinkAxisMask&1<<r?(n.finalShapeGatherIndices.push(iye),n.finalShapeGatherIndicesSparse.push(-1),n.shrinkAxisMask|=1<<t):(n.finalShapeGatherIndices.push(t),n.finalShapeGatherIndicesSparse.push(r)),n.inputShapeGatherIndicesSparse[t]=r,t++}}(d,h);let f=!0,p=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);const w=!!(h.shrinkAxisMask&1<<b),x=e[b];if(-1===x){g.push(w?1:-1);continue}const I=[h.beginMask&1<<b,h.endMask&1<<b],_=[h.strides[b]>0?0:-1,h.strides[b]>0?x:x-1];if(w&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[b];const D=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(w){const B=h.begin[b]<0?x+h.begin[b]:h.begin[b];if(h.begin[b]=B,h.end[b]=h.begin[b]+1,B<0||B>=x)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=ej(h.begin[b],0,h.strides[b],x,I,_),h.end[b]=ej(h.end[b],1,h.strides[b],x,I,_);const P=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===x;f=f&&P,p=p&&(0===b&&1===h.strides[b]||P)}else f=f&&1===h.strides[b]&&D,p=p&&(0===b&&1===h.strides[b]||D);let N,T=!1;if(h.beginValid&&h.endValid?(N=h.end[b]-h.begin[b],T=!0):w?(N=1,T=!0):D&&x>=0&&(N=h.strides[b]<0?-x:x,T=!0),T){let P;P=0===N||N<0!=h.strides[b]<0?0:Math.trunc(N/h.strides[b])+(N%h.strides[b]!=0?1:0),g.push(P)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){const w=h.finalShapeGatherIndices[b];w>=0?y.push(g[w]):w===Ak&&y.push(1)}return{finalShapeSparse:y.filter((b,w)=>h.finalShapeGatherIndices[w]!==Ak),finalShape:y,isIdentity:f,sliceDim0:p,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function ej(e,n,t,r,s,o){if(s[n])return t>0?o[n]:o[n+1&1];{const i=e<0?r+e:e;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const cye=.001,tj=.1;function dye(e,n,t){return null==t&&(t=Pk()),Lk(e,n,(r,s)=>Vk(r,s,t))}function Pk(){return 32===k.backend.floatPrecision()?cye:tj}function Lk(e,n,t){let r=!0;if((lr(e)||lr(n))&&(r=!1),lr(e)&&lr(n)&&(r=!0),r){const i=e.constructor.name,a=n.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(e)&&Array.isArray(n)){const i=Xi(e),a=Xi(n);if(!wt(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}const s=lr(e)?e:Ki(e),o=lr(n)?n:Ki(n);if(s.length!==o.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${o.length}.\nActual:   ${s}.\nExpected: ${o}.`);for(let i=0;i<o.length;++i){const a=s[i],l=o[i];if(!t(a,l))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${l}.\nActual:   ${s}.\nExpected: ${o}.`)}typeof expect<"u"&&expect().nothing()}function hye(e,n){e().then(()=>n.fail(),()=>n()),typeof expect<"u"&&expect().nothing()}function fye(e,n){const t="string"==typeof n||"number"==typeof n||"boolean"==typeof n?[n]:n;return Gi(e)||Gi(e[0])||Gi(n)||Gi(n[0])?Lk(e,t,(r,s)=>r==s):Lk(e,n,(r,s)=>Vk(r,s,0))}function pye(e,n,t){if(null==t&&(t=Pk()),!Vk(e,n,t))throw new Error(`Numbers differ: actual === ${e}, expected === ${n}`);typeof expect<"u"&&expect().nothing()}function Vk(e,n,t){return!isFinite(e)&&!isFinite(n)||!(isNaN(e)||isNaN(n)||Math.abs(e-n)>t)}function mye(e,n,t){for(let r=0;r<e.length;r++)if(e[r]<n||e[r]>t)throw new Error(`Value out of range:${e[r]} low: ${n}, high: ${t}`)}function gye(e,n){const t=new Float32Array(e),r=new Float32Array(n);if(t.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${t.length}`);for(let s=0;s<r.length;s++)if(t[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${t[s]} instead`)}function nj(e){for(let n=0;n<e.length;n++){const t=e[n];Array.isArray(t)?nj(t):e[n]=qi(t)}return e}function yye(e){const n=document.createElement("video");return"playsInline"in n&&(n.playsInline=!0),n.muted=!0,n.loop=!0,n.style.position="fixed",n.style.left="0px",n.style.top="0px",n.preload="auto",n.appendChild(e),new Promise(t=>{n.addEventListener("loadeddata",r=>t(n)),n.load()})}function vye(e){return Bk.apply(this,arguments)}function Bk(){return(Bk=F(function*(e){yield e.play(),"requestVideoFrameCallback"in e&&(yield new Promise(n=>{e.requestVideoFrameCallback(n)}))})).apply(this,arguments)}const rj="4.22.0";class sj{static sgd(n){return new AC(n)}static momentum(n,t,r=!1){return new vk(n,t,r)}static rmsprop(n,t=.9,r=0,s=null,o=!1){return new bk(n,t,r,s,o)}static adam(n=.001,t=.9,r=.999,s=null){return new gk(n,t,r,s)}static adadelta(n=.001,t=.95,r=null){return new pk(n,t,r)}static adamax(n=.002,t=.9,r=.999,s=null,o=0){return new yk(n,t,r,s,o)}static adagrad(n,t=.1){return new mk(n,t)}}const zk=R({acos_:function bye(e){const t={x:E(e,"x","acos")};return k.runKernel(Fh,t)}}),Uk=R({acosh_:function wye(e){const t={x:E(e,"x","acosh")};return k.runKernel($h,t)}}),oj=R({addN_:function xye(e){S(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),S(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const n=e.map((s,o)=>E(s,`tensors${o}`,"addN")),t=n[0];return n.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(s=>{if(!wt(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),k.runKernel(Mg,n)}}),FC=R({all_:function Cye(e,n=null,t=!1){const s={x:E(e,"x","all","bool")};return k.runKernel(d0,s,{axis:n,keepDims:t})}}),Xy=R({any_:function Iye(e,n=null,t=!1){const s={x:E(e,"x","any","bool")};return k.runKernel(h0,s,{axis:n,keepDims:t})}}),Kl=R({argMax_:function Sye(e,n=0){const r={x:E(e,"x","argMax")};return k.runKernel(Og,r,{axis:n})}}),Wk=R({argMin_:function _ye(e,n=0){const r={x:E(e,"x","argMin")};return k.runKernel(Fg,r,{axis:n})}}),Hk=R({asin_:function Eye(e){const t={x:E(e,"x","asin")};return k.runKernel(Ph,t)}}),jk=R({asinh_:function Dye(e){const t={x:E(e,"x","asinh")};return k.runKernel(Lh,t)}}),Gk=R({atan_:function Nye(e){const t={x:E(e,"x","atan")};return k.runKernel(Vh,t)}}),qk=R({atan2_:function Tye(e,n){let t=E(e,"a","atan2"),r=E(n,"b","atan2");return[t,r]=_n(t,r),k.runKernel(zh,{a:t,b:r})}}),Kk=R({atanh_:function kye(e){const t={x:E(e,"x","atanh")};return k.runKernel(Bh,t)}});function Yy(e,n,t,r,s="NHWC",o){return Tr(e,[...n,e[3]],t,o,r,null,null,Ua(s))}function Wo(e,n,t,r,s,o,i="channelsLast"){const[a,l]=Zy(n);let u;if("channelsLast"===i)u=[a,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[a,l,e[1],e[1]]}return Tr(e,u,t,r,s,o,!1,i)}function za(e,n,t,r,s,o,i="NDHWC"){const[a,l,u]=Yk(n);let c,d;if("NDHWC"===i)d="channelsLast",c=[a,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[a,l,u,e[1],e[1]]}return Xl(e,c,t,r,s,!1,d,o)}function Tr(e,n,t,r,s,o,i=!1,a="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,d]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c]=e}const[h,f,,p]=n,[m,g]=Zy(t),[y,v]=Zy(r),b=Bf(h,y),w=Bf(f,v),{padInfo:x,outHeight:I,outWidth:_}=function Mye(e,n,t,r,s,o,i,a,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const f=function Aye(e,n,t,r,s){null==r&&(r=Xk(e,n,t));const i=e[1];return[Qy((e[0]-n+2*r)/t+1,s),Qy((i-n+2*r)/t+1,s)]}([n,t],o,r,e,a);c=f[0],d=f[1]}else if("same"===e){c=Math.ceil(n/r),d=Math.ceil(t/s);const h=Math.max(0,(c-1)*r+o-n),f=Math.max(0,(d-1)*s+i-t),p=Math.floor(h/2),m=h-p,g=Math.floor(f/2);u={top:p,bottom:m,left:g,right:f-g,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((n-o+1)/r),d=Math.ceil((t-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],f="channelsLast"===l?e[1][1]:e[2][1],p="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},c=Qy((n-o+h+f)/r+1,a),d=Qy((t-i+p+m)/s+1,a)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,b,w,o,a),D=i?p*d:p;let N;return"channelsFirst"===a?N=[l,D,I,_]:"channelsLast"===a&&(N=[l,I,_,D]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:d,outHeight:I,outWidth:_,outChannels:D,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:b,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:v,inShape:e,outShape:N,filterShape:n}}function Xl(e,n,t,r,s,o=!1,i="channelsLast",a){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}const[f,p,m,,g]=n,[y,v,b]=Yk(t),[w,x,I]=Yk(r),_=Bf(f,w),D=Bf(p,x),N=Bf(m,I),{padInfo:T,outDepth:P,outHeight:B,outWidth:W}=function Oye(e,n,t,r,s,o,i,a,l,u,c){let d,h,f,p;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const g=function Rye(e,n,t,r,s,o){null==s&&(s=Xk(e,n[0],r[0]));const i=[0,0,0,t];for(let a=0;a<3;a++)e[a]+2*s>=n[a]&&(i[a]=Qy((e[a]-n[a]+2*s)/r[a]+1,o));return i}([n,t,r,1],[a,l,u],1,[s,o,i],e,c);h=g[0],f=g[1],p=g[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(n/s),f=Math.ceil(t/o),p=Math.ceil(r/i);const m=(h-1)*s+a-n,g=(f-1)*o+l-t,y=(p-1)*i+u-r,v=Math.floor(m/2),b=m-v,w=Math.floor(g/2),x=g-w,I=Math.floor(y/2);d={top:w,bottom:x,left:I,right:y-I,front:v,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,u,c,d,y,v,b,_,D,N,a),H=o?g*h:g;let G;return"channelsFirst"===i?G=[l,H,P,B,W]:"channelsLast"===i&&(G=[l,P,B,W,H]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:P,outHeight:B,outWidth:W,outChannels:H,padInfo:T,strideDepth:y,strideHeight:v,strideWidth:b,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:D,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:x,dilationWidth:I,inShape:e,outShape:G,filterShape:n}}function Xk(e,n,t,r=1){const s=Bf(n,r);return Math.floor((e[0]*(t-1)-t+s)/2)}function Zy(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Yk(e){return"number"==typeof e?[e,e,e]:e}function Bf(e,n){return n<=1?e:e+(e-1)*(n-1)}function Qy(e,n){if(!n)return Math.trunc(e);switch(n){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${n}`)}}function Yl(e){const[n,t,r]=Zy(e);return 1===n&&1===t&&1===r}function Br(e,n){return Yl(e)||Yl(n)}function Fc(e){return Zy(e).every(n=>n>0)}function Ua(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function hs(e,n,t){if(null!=t){if("string"==typeof n)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${t} but got pad ${n}.`);if("number"==typeof n)S(bc(n),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${t} but got pad ${n}.`);else{if("object"!=typeof n)throw Error(`Error in ${e}: Unknown padding parameter: ${n}`);n.forEach(r=>{r.forEach(s=>{S(bc(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})})}}}const O=R({reshape_:function Fye(e,n){const r={x:E(e,"x","reshape","string_or_numeric")};return k.runKernel(xy,r,{shape:n})}}),Jy=R({avgPool_:function $ye(e,n,t,r,s){const o=E(e,"x","avgPool","float32");S(Br(t,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`);let a=o,l=!1;3===o.rank&&(l=!0,a=O(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),hs("avgPool",r,s);let d=k.runKernel($g,{x:a},{filterSize:n,strides:t,pad:r,dimRoundingMode:s});return d=pe(d,o.dtype),l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Zk=R({avgPool3d_:function Pye(e,n,t,r,s,o="NDHWC"){const i=E(e,"x","avgPool3d","float32");let a=i,l=!1;4===i.rank&&(l=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),S("number"==typeof t&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),hs("avgPool3d",r,s);let d=k.runKernel(Pg,{x:a},{filterSize:n,strides:t,pad:r,dimRoundingMode:s,dataFormat:o});return d=pe(d,a.dtype),l?O(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Un=R({concat_:function Lye(e,n=0){S(e.length>=1,()=>"Pass at least one tensor to concat");const t=jy(e,"tensors","concat","string_or_numeric");return"complex64"===t[0].dtype&&t.forEach(o=>{if("complex64"!==o.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${o.dtype}. `)}),1===t.length?Zi(t[0]):k.runKernel(Ug,t,{axis:n})}}),wo=R({sigmoid_:function Vye(e){const t={x:E(e,"x","sigmoid","float32")};return k.runKernel(Sf,t)}}),Et=R({slice_:function Bye(e,n,t){const r=E(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return k.runKernel(Ey,{x:r},{begin:n,size:t})}}),Zl=R({tanh_:function zye(e){const t={x:E(e,"x","tanh","float32")};return k.runKernel(kf,t)}}),ij=R({basicLSTMCell_:function Uye(e,n,t,r,s,o){const i=E(e,"forgetBias","basicLSTMCell"),a=E(n,"lstmKernel","basicLSTMCell"),l=E(t,"lstmBias","basicLSTMCell"),u=E(r,"data","basicLSTMCell"),c=E(s,"c","basicLSTMCell"),d=E(o,"h","basicLSTMCell"),h=Un([u,d],1),f=at(h,a),p=ne(f,l),g=p.shape[1]/4,y=[p.shape[0],g],v=Et(p,[0,0],y),b=Et(p,[0,g],y),w=Et(p,[0,2*g],y),x=Et(p,[0,3*g],y),I=ne(M(wo(v),Zl(b)),M(c,wo(ne(i,w))));return[I,M(Zl(I),wo(x))]}}),ev=R({batchToSpaceND_:function Wye(e,n,t){const r=E(e,"x","batchToSpaceND"),s=n.reduce((a,l)=>a*l);return S(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),S(t.length===n.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${n.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${s}`),k.runKernel(Vg,{x:r},{blockShape:n,crops:t})}});function Hye(e){let n;return n=0===e.rank||1===e.rank?O(e,[1,1,1,e.size]):2===e.rank?O(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?O(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,n}const zf=R({batchNorm_:function jye(e,n,t,r,s,o){null==o&&(o=.001);const i=E(e,"x","batchNorm"),a=E(n,"mean","batchNorm"),l=E(t,"variance","batchNorm");let u,c;null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:Hye(i),scale:u,offset:c,mean:a,variance:l},p=k.runKernel(Zg,h,{varianceEpsilon:o});return O(p,i.shape)}}),Qk=R({batchNorm2d_:function Gye(e,n,t,r,s,o){const i=E(e,"x","batchNorm"),a=E(n,"mean","batchNorm"),l=E(t,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),S(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),zf(i,a,l,c,u,o)}}),Jk=R({batchNorm3d_:function qye(e,n,t,r,s,o){const i=E(e,"x","batchNorm"),a=E(n,"mean","batchNorm"),l=E(t,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),S(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),zf(i,a,l,c,u,o)}}),eA=R({batchNorm4d_:function Kye(e,n,t,r,s,o){const i=E(e,"x","batchNorm"),a=E(n,"mean","batchNorm"),l=E(t,"variance","batchNorm");let u,c;return null!=s&&(u=E(s,"scale","batchNorm")),null!=r&&(c=E(r,"offset","batchNorm")),S(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),zf(i,a,l,c,u,o)}}),tA=R({bincount_:function Xye(e,n,t){const r=E(e,"x","bincount"),s=E(n,"weights","bincount");return S("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(t>=0,()=>`size must be non-negative, but got ${t}.`),S(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),k.runKernel(m0,{x:r,weights:s},{size:t})}}),aj=R({bitwiseAnd_:function Yye(e,n){const t=E(e,"x","bitwiseAnd"),r=E(n,"y","bitwiseAnd");if(!wt(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if("int32"!==t.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);return k.runKernel(Bg,{a:t,b:r})}}),lj=R({broadcastArgs_:function Zye(e,n){const t=E(e,"s0","broadcastArgs","int32"),r=E(n,"s1","broadcastArgs","int32");if(1!==t.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return k.runKernel(g0,{s0:t,s1:r})}}),$c=R({broadcastTo_:function Qye(e,n){let t=E(e,"broadcastTo","x");const r=t.shape;if(Ks(n),n.length<t.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${t.rank}.`);if(n.length>t.rank){const u=t.shape.slice();for(;u.length<n.length;)u.unshift(1);t=O(t,u)}const s=t.shape,o=Array.from(n);for(let u=n.length-1;u>=0;u--)if(s[u]===n[u])o[u]=1;else if(1!==t.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);return 0===o.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?Zi(t):k.runKernel(Af,{x:t},{reps:o})}}),nA=R({ceil_:function Jye(e){const t={x:E(e,"x","ceil","float32")};return k.runKernel(Wh,t)}}),As=R({clipByValue_:function eve(e,n,t){const r=E(e,"x","clipByValue");return S(n<=t,()=>`Error in clip: min (${n}) must be less than or equal to max (${t}).`),n===t?Ac(r.shape,n,r.dtype):k.runKernel(Hh,{x:r},{clipValueMin:n,clipValueMax:t})}}),rA=R({concat1d_:function tve(e){return Un(e,0)}}),sA=R({concat2d_:function nve(e,n){return Un(e,n)}}),oA=R({concat3d_:function rve(e,n){return Un(e,n)}}),iA=R({concat4d_:function sve(e,n){return Un(e,n)}}),Wa=R({conv2d_:function ove(e,n,t,r,s="NHWC",o=[1,1],i){const a=E(e,"x","conv2d","float32"),l=E(n,"filter","conv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),hs("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(Br(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),S(Fc(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),S(Fc(t),()=>"Error in conv2D: Strides should be larger than 0.");const p=k.runKernel(Wg,{x:u,filter:l},{strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),$C=R({conv1d_:function ive(e,n,t,r,s="NWC",o=1,i){const a=E(e,"x","conv1d"),l=E(n,"filter","conv1d");let u=a,c=!1;2===a.rank&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1]])),S(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),hs("conv1d",r,i),S(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(Br(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),S(Fc(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),S(Fc(t),()=>"Error in conv1D: Stride should be larger than 0."),S("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=O(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=O(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Wa(h,d,[1,t],r,"NHWC",[1,o],i);return O(g,c?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),aA=R({conv2DBackpropInput_:function ave(e,n,t,r,s,o="NHWC",i){S(e.length===n.rank,()=>`Length of inShape (${e.length}) and rank of dy (${n.rank}) must match`);let a=e,l=n,u=!1;3===n.rank&&(u=!0,l=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,e[0],e[1],e[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===t.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c="NHWC"===o?a[3]:a[1],d="NHWC"===o?l.shape[3]:l.shape[1];S(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),S(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),hs("conv2dDerInput",s,i);const p=k.runKernel(Hg,{dy:l,filter:t},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return u?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),PC=R({conv2dTranspose_:function lve(e,n,t,r,s,o){const i=E(e,"x","conv2dTranspose"),a=E(n,"filter","conv2dTranspose");return aA(t,i,a,r,s,"NHWC",o)}}),lA=R({conv3d_:function uve(e,n,t,r,s="NDHWC",o=[1,1,1]){const i=E(e,"x","conv3d"),a=E(n,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(Br(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),S("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),S(Fc(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),S(Fc(t),()=>"Error in conv3D: Strides should be larger than 0.");const h=k.runKernel(jg,{x:l,filter:a},{strides:t,pad:r,dataFormat:s,dilations:o});return u?O(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),uj=R({conv3DBackpropInput_:function cve(e,n,t,r,s){S(e.length===n.rank,()=>`Length of inShape (${e.length}) and rank of dy (${n.rank}) must match`);let o=e,i=n,a=!1;4===n.rank&&(a=!0,i=O(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),o=[1,e[0],e[1],e[2],e[3]]);const l=o[4],u=i.shape[4];S(5===o.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),S(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),S(5===t.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),S(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),S(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const h=k.runKernel(w0,{dy:i,filter:t},{pad:s,strides:r,inputShape:o});return a?O(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),uA=R({conv3dTranspose_:function dve(e,n,t,r,s){const o=E(e,"x","conv3dTranspose"),i=E(n,"filter","conv3dTranspose");return uj(t,o,i,r,s)}}),tv=R({cos_:function hve(e){const t={x:E(e,"x","cos","float32")};return k.runKernel(jh,t)}}),LC=R({cosh_:function fve(e){const t={x:E(e,"x","cosh","float32")};return k.runKernel(Gh,t)}}),nv=R({cumprod_:function pve(e,n=0,t=!1,r=!1){const o={x:E(e,"x","cumprod")};return k.runKernel(x0,o,{axis:n,exclusive:t,reverse:r})}}),VC=R({cumsum_:function mve(e,n=0,t=!1,r=!1){const o={x:E(e,"x","cumsum")};return k.runKernel(Gg,o,{axis:n,exclusive:t,reverse:r})}}),BC=R({denseBincount_:function gve(e,n,t,r=!1){const s=E(e,"x","denseBincount"),o=E(n,"weights","denseBincount");return S("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(t>=0,()=>`size must be non-negative, but got ${t}.`),S(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),k.runKernel(I0,{x:s,weights:o},{size:t,binaryOutput:r})}}),cA=R({depthToSpace_:function yve(e,n,t="NHWC"){const r=E(e,"x","depthToSpace","float32"),s="NHWC"===t?r.shape[1]:r.shape[2],o="NHWC"===t?r.shape[2]:r.shape[3],i="NHWC"===t?r.shape[3]:r.shape[1];return S(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`),S(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${n}  for depthToSpace with input shape\n    ${r.shape}`),S(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${n} for depthToSpace with input shape\n        ${r.shape}`),S(i%(n*n)==0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`),k.runKernel(S0,{x:r},{blockSize:n,dataFormat:t})}}),Uf=R({depthwiseConv2d_:function vve(e,n,t,r,s="NHWC",o=[1,1],i){const a=E(e,"x","depthwiseConv2d","float32"),l=E(n,"filter","depthwiseConv2d","float32");let u=a,c=!1;3===a.rank&&(c=!0,u=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];S(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),hs("depthwiseConv2d",r,i);const p=k.runKernel(qg,{x:u,filter:l},{strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?O(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),cj=R({diag_:function bve(e){const t={x:E(e,"x","diag")};return k.runKernel(D0,t)}}),dA=R({dilation2d_:function wve(e,n,t,r,s=[1,1],o="NHWC"){const i=E(e,"x","dilation2d"),a=E(n,"filter","dilation2d");S(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i,u=!1;3===i.rank&&(l=O(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),S(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const h=k.runKernel(Kg,{x:l,filter:a},{strides:t,pad:r,dilations:s});return u?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Xs=R({equal_:function xve(e,n){let t=E(e,"a","equal","string_or_numeric"),r=E(n,"b","equal","string_or_numeric");return[t,r]=_n(t,r),et(t.shape,r.shape),k.runKernel(Xg,{a:t,b:r})}}),zr=R({where_:function Cve(e,n,t){const r=E(n,"a","where"),s=E(t,"b","where"),o=E(e,"condition","where","bool"),i=et(et(o.shape,r.shape),s.shape),a=$c(o,i),l=$c(r,i),u=$c(s,i);return k.runKernel(_y,{condition:a,t:l,e:u})}}),hA=R({divNoNan_:function Ive(e,n){let t=E(e,"a","div"),r=E(n,"b","div");[t,r]=_n(t,r);const s=ke(t,r),o=_t(s),i=Xs(r,o);return zr(i,o,s)}}),fA=R({dot_:function Sve(e,n){const t=E(e,"t1","dot"),r=E(n,"t2","dot");S(!(1!==t.rank&&2!==t.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=1===t.rank?t.size:t.shape[1],o=1===r.rank?r.size:r.shape[0];if(S(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),1===t.rank&&1===r.rank){const i=O(t,[1,-1]),a=O(r,[-1,1]),l=at(i,a);return O(l,[])}if(1===t.rank&&2===r.rank){const i=O(t,[1,-1]),a=O(r,[r.shape[0],r.shape[1]]),l=at(i,a);return O(l,[l.size])}if(2===t.rank&&1===r.rank){const i=O(r,[-1,1]),a=at(t,i);return O(a,[a.size])}{const i=O(r,[r.shape[0],r.shape[1]]);return at(t,i)}}}),Pc=R({einsum_:function _ve(e,...n){const t=n.map((s,o)=>E(s,`tensors${o}`,"einsum"));return k.runKernel(A0,t,{equation:e})}}),Wf=R({elu_:function Eve(e){const t={x:E(e,"x","elu","float32")};return k.runKernel(Kh,t)}}),dj=R({ensureShape_:function Dve(e,n){const t=E(e,"x","ensureShape","string_or_numeric");if(!M4(t.shape,n))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${n}`);return e}}),zC=R({erf_:function Nve(e){let n=E(e,"x","erf");return S("int32"===n.dtype||"float32"===n.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===n.dtype&&(n=pe(n,"float32")),k.runKernel(Xh,{x:n})}});function pA(e,n){for(let t=0;t<e.length;++t)if(e[e.length-t-1]!==n-1-t)return!1;return!0}function hj(e,n,t){const r=e.length+n.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===t.indexOf(a)?s.push(e[o++]):s.push(n[i++]);return s}function kr(e,n){const t=[],r=e.length;for(let o=0;o<r;o++)-1===n.indexOf(o)&&t.push(e[o]);return[t,n.map(o=>e[o])]}function Wn(e,n){return hj(e,n.map(r=>1),n)}function Ur(e,n,t){S(pA(n,t),()=>`${e} supports only inner-most axes for now. Got axes ${n} and rank-${t} input.`)}function Dn(e,n){if(pA(e,n))return null;const t=[];for(let r=0;r<n;++r)-1===e.indexOf(r)&&t.push(r);return e.forEach(r=>t.push(r)),t}function Ql(e){return e.map((n,t)=>[t,n]).sort((n,t)=>n[1]-t[1]).map(n=>n[0])}function Hn(e,n){const t=[];for(let r=n-e;r<n;++r)t.push(r);return t}const xo=R({max_:function Tve(e,n=null,t=!1){const s={x:E(e,"x","max")};return k.runKernel(ay,s,{reductionIndices:n,keepDims:t})}}),Hf=R({min_:function kve(e,n=null,t=!1){const s={x:E(e,"x","min")};return k.runKernel(dy,s,{axis:n,keepDims:t})}}),De=R({sum_:function Ave(e,n=null,t=!1){let r=E(e,"x","sum");return"bool"===r.dtype&&(r=pe(r,"int32")),k.runKernel(Dy,{x:r},{axis:n,keepDims:t})}});function fj(e,n,t=null){if(0===e.rank)return Jn(e);if(1!==e.rank&&null===t)return fj(O(e,[-1]),n,t);if(1===e.rank||"number"==typeof t||Array.isArray(t)&&1===t.length){if(1===n)return De(Jn(e),t);if(n===1/0)return xo(Jn(e),t);if(n===-1/0)return Hf(Jn(e),t);if("euclidean"===n||2===n)return Nr(De(Ji(Jn(e),Re(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(t)&&2===t.length){if(1===n)return xo(De(Jn(e),t[0]),t[1]-1);if(n===1/0)return xo(De(Jn(e),t[1]),t[0]);if(n===-1/0)return Hf(De(Jn(e),t[1]),t[0]);if("fro"===n||"euclidean"===n)return Nr(De(Kt(e),t));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const jf=R({norm_:function Rve(e,n="euclidean",t=null,r=!1){const s=fj(e=E(e,"x","norm"),n,t);let o=s.shape;if(r){const i=pt(t,e.shape);o=Wn(s.shape,i)}return O(s,o)}}),mA=R({euclideanNorm_:function Mve(e,n=null,t=!1){return jf(e,"euclidean",n,t)}}),Rs=R({exp_:function Ove(e){const t={x:E(e,"x","exp")};return k.runKernel(Yh,t)}}),jn=R({expandDims_:function Fve(e,n=0){const t=E(e,"x","expandDims","string_or_numeric");return S(n<=t.rank,()=>"Axis must be <= rank of the tensor"),k.runKernel(Yg,{input:t},{dim:n})}}),gA=R({expm1_:function $ve(e){const t={x:E(e,"x","expm1")};return k.runKernel(Zh,t)}}),Co=R({tile_:function Pve(e,n){const t=E(e,"x","tile","string_or_numeric");return S(t.rank===n.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${n}.`),k.runKernel(Af,{x:t},{reps:n})}}),UC=R({eye_:function Lve(e,n,t,r="float32"){null==n&&(n=e);const s=it([e,n],r),o=e<=n?e:n;for(let a=0;a<o;++a)s.set(1,a,a);const i=O(s.toTensor(),[e,n]);if(null==t)return i;if(1===t.length)return Co(jn(i,0),[t[0],1,1]);if(2===t.length)return Co(jn(jn(i,0),0),[t[0],t[1],1,1]);if(3===t.length)return Co(jn(jn(jn(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}}),Gf=R({floor_:function Vve(e){const t={x:E(e,"x","floor","float32")};return k.runKernel(Qh,t)}}),qf=R({gather_:function Bve(e,n,t=0,r=0){const s=E(e,"x","gather"),o=E(n,"indices","gather","int32");return k.runKernel(Qg,{x:s,indices:o},{axis:t,batchDims:r})}}),fs=R({greater_:function zve(e,n){let t=E(e,"a","greater","string_or_numeric"),r=E(n,"b","greater","string_or_numeric");return[t,r]=_n(t,r),et(t.shape,r.shape),k.runKernel(Jg,{a:t,b:r})}}),Ha=R({greaterEqual_:function Uve(e,n){let t=E(e,"a","greaterEqual","string_or_numeric"),r=E(n,"b","greaterEqual","string_or_numeric");return[t,r]=_n(t,r),et(t.shape,r.shape),k.runKernel(ef,{a:t,b:r})}}),yA=R({isFinite_:function Wve(e){const t={x:E(e,"x","isFinite")};return k.runKernel(rf,t)}}),vA=R({isInf_:function Hve(e){const t={x:E(e,"x","isInf")};return k.runKernel(sf,t)}}),bA=R({isNaN_:function jve(e){const t={x:E(e,"x","isNaN")};return k.runKernel(af,t)}}),rv=R({leakyRelu_:function Gve(e,n=.2){const r={x:E(e,"x","leakyRelu")};return k.runKernel(ey,r,{alpha:n})}}),Kf=R({less_:function qve(e,n){let t=E(e,"a","less","string_or_numeric"),r=E(n,"b","less","string_or_numeric");return[t,r]=_n(t,r),et(t.shape,r.shape),k.runKernel(ty,{a:t,b:r})}}),Jl=R({lessEqual_:function Kve(e,n){let t=E(e,"a","lessEqual","string_or_numeric"),r=E(n,"b","lessEqual","string_or_numeric");return[t,r]=_n(t,r),et(t.shape,r.shape),k.runKernel(ny,{a:t,b:r})}});function pj(e,n,t){if(t<=0)throw new Error("The number of values should be positive.");return k.runKernel(V0,{},{start:e,stop:n,num:t})}const wA=R({localResponseNormalization_:function Xve(e,n=5,t=1,r=1,s=.5){const o=E(e,"x","localResponseNormalization");S(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),S(bc(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c=k.runKernel(iy,{x:i},{depthRadius:n,bias:t,alpha:r,beta:s});return a?O(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Ys=R({log_:function Yve(e){const t={x:E(e,"x","log","float32")};return k.runKernel(lf,t)}}),sv=R({log1p_:function Zve(e){const t={x:E(e,"x","log1p")};return k.runKernel(uf,t)}}),Lc=R({softplus_:function Qve(e){const t={x:E(e,"x","softplus")};return k.runKernel(_f,t)}}),xA=R({logSigmoid_:function Jve(e){const n=E(e,"x","logSigmoid");return Qi(r=>({value:on(Lc(on(r))),gradFunc:i=>M(i,wo(on(r)))}))(n)}}),WC=R({logSoftmax_:function ebe(e,n=-1){const t=E(e,"logits","logSoftmax");if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${n}`);return Qi((s,o)=>{const a=xo(s,n,!0),l=Ce(s,a),u=Ce(pe(l,"float32"),Ys(De(Rs(l),n,!0)));return o([u]),{value:u,gradFunc:(d,h)=>{const[f]=h,m=Rs(f);return Ce(d,M(De(d,n,!0),m))}}})(t)}}),ov=R({logSumExp_:function tbe(e,n=null,t=!1){const r=E(e,"x","logSumExp"),s=pt(n,r.shape),o=xo(r,s,!0),i=Ce(r,o),a=Rs(i),l=De(a,s),u=Ys(l),c=ne(O(o,u.shape),u);if(t){const d=Wn(c.shape,s);return O(c,d)}return c}}),mi=R({logicalAnd_:function nbe(e,n){const t=E(e,"a","logicalAnd","bool"),r=E(n,"b","logicalAnd","bool");return et(t.shape,r.shape),k.runKernel(ry,{a:t,b:r})}}),iv=R({logicalNot_:function rbe(e){const t={x:E(e,"x","logicalNot","bool")};return k.runKernel(sy,t)}}),HC=R({logicalOr_:function sbe(e,n){const t=E(e,"a","logicalOr","bool"),r=E(n,"b","logicalOr","bool");return et(t.shape,r.shape),k.runKernel(oy,{a:t,b:r})}}),CA=R({logicalXor_:function obe(e,n){const t=E(e,"a","logicalXor","bool"),r=E(n,"b","logicalXor","bool");return et(t.shape,r.shape),mi(HC(e,n),iv(mi(e,n)))}}),jC=2147483648,GC=R({searchSorted_:function ibe(e,n,t="left"){const r=E(e,"sortedSequence","searchSorted"),s=E(n,"values","searchSorted"),i=s.shape[s.shape.length-1],a=O(r,[-1,r.shape[r.shape.length-1]]),l=O(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(j(l.shape)>=jC)throw new Error(`values tensor size must less than ${jC}`);if(a.shape[1]>=jC)throw new Error(`trailing dim_size must less than ${jC} for int32 output type, was ${a.shape[1]}`);return k.runKernel(rC,{sortedSequence:a,values:l},{side:t})}});function mj(e,n){return GC(e,n,"left")}const av=R({maxPool_:function abe(e,n,t,r,s){const o=E(e,"x","maxPool");let a=o,l=!1;3===o.rank&&(l=!0,a=O(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(Br(t,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`),hs("maxPool",r,s);const d=k.runKernel(ly,{x:a},{filterSize:n,strides:t,pad:r,dimRoundingMode:s});return l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),IA=R({maxPool3d_:function lbe(e,n=[1,1,1],t,r,s,o="NDHWC"){const i=E(e,"x","maxPool3d");let a=i,l=!1;4===i.rank&&(l=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),hs("maxPool3d",r,s);const d=k.runKernel(uy,{x:a},{filterSize:n,strides:t,pad:r,dimRoundingMode:s,dataFormat:o});return l?O(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),gj=R({maxPoolWithArgmax_:function ube(e,n,t,r,s=!1){const i={x:E(e,"x","maxPoolWithArgmax")},l=k.runKernel(W0,i,{filterSize:n,strides:t,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}}),Nn=R({mean_:function cbe(e,n=null,t=!1){const s={x:E(e,"x","mean")};return k.runKernel(cy,s,{axis:n,keepDims:t})}});function tr(e,n="float32"){if(Ks(e),"complex64"===n){const r=tr(e,"float32"),s=tr(e,"float32");return Va(r,s)}const t=Lr(j(e),n);return k.makeTensor(t,e,n)}function Ms(e,n="float32"){if(Ks(e),"complex64"===n){const r=Ms(e,"float32"),s=tr(e,"float32");return Va(r,s)}const t=c0(j(e),n);return k.makeTensor(t,e,n)}function yj(e,n,{indexing:t="xy"}={}){if("xy"!==t&&"ij"!==t)throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=E(e,"x","meshgrid",e instanceof St?e.dtype:"float32");if(void 0===n)return[r];let s=E(n,"y","meshgrid",n instanceof St?n.dtype:"float32");const o=j(r.shape),i=j(s.shape);return"xy"===t?(r=O(r,[1,-1]),s=O(s,[-1,1]),[at(Ms([i,1],r.dtype),r),at(s,Ms([1,o],s.dtype))]):(r=O(r,[-1,1]),s=O(s,[1,-1]),[at(r,Ms([1,i],r.dtype)),at(Ms([o,1],s.dtype),s)])}const eu=R({minimum_:function dbe(e,n){let t=E(e,"a","minimum"),r=E(n,"b","minimum");return[t,r]=_n(t,r),"bool"===t.dtype&&(t=pe(t,"int32"),r=pe(r,"int32")),et(t.shape,r.shape),k.runKernel(df,{a:t,b:r})}}),SA=R({mirrorPad_:function hbe(e,n,t){S("reflect"===t||"symmetric"===t,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=E(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);const s="reflect"===t?1:0;for(let a=0;a<r.rank;a++)S(2===n[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(n[a][0]>=0&&n[a][0]<=r.shape[a]-s&&n[a][1]>=0&&n[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return k.runKernel(hy,{x:r},{paddings:n,mode:t})}}),_A=R({mod_:function fbe(e,n){let t=E(e,"a","mod"),r=E(n,"b","mod");return[t,r]=_n(t,r),k.runKernel(hf,{a:t,b:r})}}),lv=R({moments_:function pbe(e,n=null,t=!1){const r=pt(n,(e=E(e,"x","moments")).shape),s=Nn(e,r,t);let o=s.shape;t||(o=Wn(s.shape,r));const i=Kt(Ce(pe(e,"float32"),O(s,o)));return{mean:s,variance:Nn(i,r,t)}}}),vj=R({multiRNNCell_:function mbe(e,n,t,r){const s=E(n,"data","multiRNNCell"),o=jy(t,"c","multiRNNCell"),i=jy(r,"h","multiRNNCell");let a=s;const l=[];for(let d=0;d<e.length;d++){const h=e[d](a,o[d],i[d]);l.push(h[0]),l.push(h[1]),a=h[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}}),bj=R({multinomial_:function gbe(e,n,t,r=!1){const s=E(e,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const l={logits:1===i?O(s,[1,-1]):s},c=k.runKernel(H0,l,{numSamples:n,seed:t,normalized:r});return 1===i?O(c,[c.size]):c}}),Vc=R({notEqual_:function ybe(e,n){let t=E(e,"a","notEqual","string_or_numeric"),r=E(n,"b","notEqual","string_or_numeric");return[t,r]=_n(t,r),et(t.shape,r.shape),k.runKernel(py,{a:t,b:r})}}),Zs=R({onesLike_:function vbe(e){const t={x:E(e,"x","onesLike")};return k.runKernel(my,t)}}),wj=R({outerProduct_:function bbe(e,n){const t=E(e,"v1","outerProduct"),r=E(n,"v2","outerProduct");S(1===t.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=O(t,[-1,1]),o=O(r,[1,-1]);return at(s,o)}}),ja=R({pad_:function wbe(e,n,t=0){const r=E(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return k.runKernel(vy,{x:r},{paddings:n,constantValue:t})}}),xj=R({pad1d_:function xbe(e,n,t=0){return S(2===n.length,()=>"Invalid number of paddings. Must be length of 2."),ja(e,[n],t)}}),Cj=R({pad2d_:function Cbe(e,n,t=0){return S(2===n.length&&2===n[0].length&&2===n[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),ja(e,n,t)}}),EA=R({pad3d_:function Ibe(e,n,t=0){return S(3===n.length&&2===n[0].length&&2===n[1].length&&2===n[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),ja(e,n,t)}}),Ij=R({pad4d_:function Sbe(e,n,t=0){return S(4===n.length&&2===n[0].length&&2===n[1].length&&2===n[2].length&&2===n[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),ja(e,n,t)}}),uv=R({spaceToBatchND_:function _be(e,n,t){const r=E(e,"x","spaceToBatchND");return S(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),S(t.length===n.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${n.length}`),S(r.shape.reduce((i,a,l)=>l>0&&l<=n.length?i&&(a+t[l-1][0]+t[l-1][1])%n[l-1]==0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${n.toString()}`),k.runKernel(Ny,{x:r},{blockShape:n,paddings:t})}}),DA=R({pool_:function Ebe(e,n,t,r,s,o,i){null==s&&(s=[1,1]),null==o&&(o=1),0===r&&(r="valid");const a=E(e,"x","maxPool");let l=a,u=!1;3===a.rank&&(u=!0,l=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(Br(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const c=Wo(l.shape,n,o,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function Nbe(e,n){const r=e.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[p,m]=function Dbe(e,n,t){const r=t.map(c=>c[0]),s=t.map(c=>c[1]),o=e.concat(r,s),i=n.map((c,d)=>(c-o[d]%c)%c),a=s.map((c,d)=>c+i[d]),l=n.map((c,d)=>[r[d],a[d]]),u=n.map((c,d)=>[0,i[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),g=f?r:"valid",y=f?l:uv(l,d,p),b=("avg"===t?()=>Jy(y,n,o,g,i):()=>av(y,n,o,g,i))(),w=f?b:ev(b,d,m);return u?O(w,[w.shape[1],w.shape[2],w.shape[3]]):w}}),cv=R({prelu_:function Tbe(e,n){const t=E(e,"x","prelu"),r=E(n,"alpha","prelu");return k.runKernel(by,{x:t,alpha:r})}}),NA=R({prod_:function kbe(e,n=null,t=!1){let r=E(e,"x","prod");return"bool"===r.dtype&&(r=pe(r,"int32")),k.runKernel(wy,{x:r},{axis:n,keepDims:t})}}),Sj=R({raggedGather_:function Abe(e,n,t,r){const s=e.map((c,d)=>E(c,`tensors${d}`,"raggedGather","int32")),o=E(n,"paramsDenseValues","raggedGather"),i=E(t,"indices","raggedGather","int32"),u=k.runKernel(K0,{paramsNestedSplits:s,paramsDenseValues:o,indices:i},{outputRaggedRank:r});return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}}),_j=R({raggedRange_:function Rbe(e,n,t){const r=E(e,"starts","raggedRange"),s=E(n,"limits","raggedRange",r.dtype),o=E(t,"deltas","raggedRange",r.dtype),a=k.runKernel(X0,{starts:r,limits:s,deltas:o});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),Ej=R({raggedTensorToTensor_:function Mbe(e,n,t,r,s){const o=E(e,"shape","raggedTensorToTensor","int32"),i=E(n,"values","raggedTensorToTensor"),a=E(t,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,h)=>E(d,`tensors${h}`,"raggedTensorToTensor","int32"));return k.runKernel(Y0,{shape:o,values:i,defaultValue:a,rowPartitionTensors:l},{rowPartitionTypes:s})}}),Dj=R({rand_:function Obe(e,n,t){Ks(e);const r=j(e);let s=null;if(null==t||"float32"===t)s=new Float32Array(r);else if("int32"===t)s=new Int32Array(r);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);s=new Uint8Array(r)}for(let o=0;o<r;o++)s[o]=n();return k.makeTensor(s,e,t)}});var Xf=U(814);class TA{constructor(n,t,r,s,o){this.mean=n,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=o||Math.random();this.random=Xf.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let n,t,r=!1;for(;!r;){let s,o,i;do{s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(n)}convertValue(n){return null==this.dtype||"float32"===this.dtype?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}}class Fbe{constructor(n,t,r,s){this.alpha=n,this.beta=1/t,this.dtype=r;const o=s||Math.random();this.randu=Xf.alea(o.toString()),this.randn=new TA(0,1,r,!1,this.randu()),this.d=n<1?n+2/3:n-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let n,t,r,s,o,i;for(;;){do{s=this.randn.nextValue(),i=1+this.c*s}while(i<=0);if(i*=i*i,n=s*s,t=1-.331*n*n,r=.5*n+this.d*(1-i+Math.log(i)),o=this.randu(),o<t||Math.log(o)<r)break}return i*=1/this.beta*this.d,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(n){return"float32"===this.dtype?n:Math.round(n)}}class $be{constructor(n=0,t=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=n,this.range=t-n,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${t} <= 1 and dtype is not float`);this.random=Xf.alea(s)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Nj=R({randomGamma_:function Bbe(e,n,t=1,r="float32",s){if(Ks(e),null==t&&(t=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const o=new Fbe(n,t,r,s),i=it(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),qC=R({randomNormal_:function zbe(e,n=0,t=1,r,s){if(Ks(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new TA(n,t,r,!1,s),i=it(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),Tj=R({randomStandardNormal_:function Ube(e,n,t){if(null!=n&&"bool"===n)throw new Error(`Unsupported data type ${n}`);return qC(e,0,1,n,t)}}),tu=R({randomUniform_:function Wbe(e,n=0,t=1,r="float32",s){Ks(e);const o=it(e,r),i=new $be(n,t,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),kj=R({randomUniformInt_:function Hbe(e,n,t,r){return tu(e,n,t,"int32",r)}});function Ga(e,n,t=1,r="float32"){if(0===t)throw new Error("Cannot have a step of zero");return k.runKernel(Z0,{},{start:e,stop:n,step:t,dtype:r})}const AA=R({reciprocal_:function jbe(e){const t={x:E(e,"x","reciprocal")};return k.runKernel(mf,t)}}),gi=R({relu_:function Gbe(e){const t={x:E(e,"x","relu")};return k.runKernel(gf,t)}}),KC=R({relu6_:function qbe(e){const t={x:E(e,"x","relu6")};return k.runKernel(yf,t)}}),Io=R({reverse_:function Kbe(e,n){const r={x:E(e,"x","reverse")};return k.runKernel(Sy,r,{dims:n})}}),Aj=R({reverse1d_:function Xbe(e){const n=E(e,"x","reverse");return S(1===n.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${n.rank}.`),Io(n,0)}}),Rj=R({reverse2d_:function Ybe(e,n){const t=E(e,"x","reverse");return S(2===t.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Io(t,n)}}),Mj=R({reverse3d_:function Zbe(e,n){const t=E(e,"x","reverse");return S(3===t.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Io(t,n)}}),Oj=R({reverse4d_:function Qbe(e,n){const t=E(e,"x","reverse");return S(4===t.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Io(t,n)}}),XC=R({round_:function Jbe(e){const t={x:E(e,"x","round")};return k.runKernel(vf,t)}}),YC=R({rsqrt_:function ewe(e){const t={x:E(e,"x","rsqrt","float32")};return k.runKernel(bf,t)}}),ZC=R({selu_:function twe(e){const t={x:E(e,"x","selu")};return k.runKernel(wf,t)}}),QC=R({separableConv2d_:function nwe(e,n,t,r,s,o=[1,1],i="NHWC"){const a=E(e,"x","separableConv2d"),l=E(n,"depthwiseFilter","separableConv2d"),u=E(t,"pointwiseFilter","separableConv2d");let c=a,d=!1;if(3===a.rank&&(d=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),S(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(u.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${u.shape[2]}.`);const p=Uf(c,l,r,s,i,o),g=Wa(p,u,1,"valid",i);return d?O(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});function RA(){return(RA=F(function*(e,n){const t=E(e,"x","setdiff1d"),r=E(n,"y","setdiff1d");S(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),S(1===t.rank,()=>`x should be 1D tensor, but got x (${t.shape}).`),S(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield t.data(),o=yield r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const l=new Qn([a],t.dtype),u=new Qn([a],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]})).apply(this,arguments)}const Fj=function rwe(e,n){return RA.apply(this,arguments)},MA=R({sign_:function swe(e){const t={x:E(e,"x","sign")};return k.runKernel(If,t)}}),JC=R({sin_:function owe(e){const t={x:E(e,"x","sin","float32")};return k.runKernel(xf,t)}}),eI=R({sinh_:function iwe(e){const t={x:E(e,"x","sinh")};return k.runKernel(Cf,t)}}),dv=R({slice1d_:function awe(e,n,t){const r=E(e,"x","slice1d");return S(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Et(r,[n],[t])}}),tI=R({slice2d_:function lwe(e,n,t){const r=E(e,"x","slice2d");return S(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Et(r,n,t)}}),hv=R({slice3d_:function uwe(e,n,t){const r=E(e,"x","slice3d");return S(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Et(r,n,t)}}),Yf=R({slice4d_:function cwe(e,n,t){const r=E(e,"x","slice4d");return S(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Et(r,n,t)}}),fv=R({softmax_:function dwe(e,n=-1){const t=E(e,"logits","softmax","float32");if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${n}`);return k.runKernel(ky,{logits:t},{dim:n})}}),pv=R({fft_:function hwe(e){return S("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),k.runKernel(M0,{input:e})}}),Zf=R({ifft_:function fwe(e){return S("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),k.runKernel(P0,{input:e})}}),nI=R({irfft_:function pwe(e){const n=e.shape[e.shape.length-1],t=e.size/n;let r;if(n<=2){const s=O(e,[t,n]);r=Zf(s)}else{const s=[t,2*(n-1)],o=O(Vf(e),[t,n]),i=O(Ky(e),[t,n]),a=Io(Et(o,[0,1],[t,n-2]),1),l=M(Io(Et(i,[0,1],[t,n-2]),1),Re(-1)),u=Un([o,a],1),c=Un([i,l],1),d=O(Va(u,c),[s[0],s[1]]);r=Zf(d)}if(r=Vf(r),3===e.rank&&0!==e.shape[0]){const s=r,o=e.shape[0];r=O(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),Os=R({split_:function mwe(e,n,t=0){const s={x:E(e,"x","split")};return k.runKernel(Ty,s,{numOrSizeSplits:n,axis:t})}}),mv=R({rfft_:function gwe(e,n){S("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let t=e.shape[e.shape.length-1];const r=e.size/t;let s;if(null!=n&&n<t){const p=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=n,s=Et(e,p,m),t=n}else if(null!=n&&n>t){const p=e.shape.map(m=>m);p[e.shape.length-1]=n-t,s=Un([e,tr(p)],e.shape.length-1),t=n}else s=e;const o=_t(s),i=O(Va(s,o),[r,t]),a=pv(i),l=Math.floor(t/2)+1,u=Vf(a),c=Ky(a),d=Os(u,[l,t-l],u.shape.length-1),h=Os(c,[l,t-l],c.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,O(Va(d[0],h[0]),f)}}),rI=R({squaredDifference_:function ywe(e,n){let t=E(e,"a","squaredDifference"),r=E(n,"b","squaredDifference");return[t,r]=_n(t,r),et(t.shape,r.shape),k.runKernel(Df,{a:t,b:r},{})}}),Qs=R({squeeze_:function vwe(e,n){const t=E(e,"x","squeeze","string_or_numeric");return O(t,Oa(t.shape,n).newShape)}}),ps=R({stack_:function bwe(e,n=0){const t=jy(e,"tensors","stack","string_or_numeric");return S(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&S(n<=t[0].rank,()=>"Axis must be <= rank of the tensor"),k.runKernel(yy,t,{axis:n})}}),Bc=R({step_:function wwe(e,n=0){const r={x:E(e,"x","step")};return k.runKernel(Rf,r,{alpha:n})}}),OA=R({stridedSlice_:function xwe(e,n,t,r,s=0,o=0,i=0,a=0,l=0){const c={x:E(e,"x","stridedSlice","string_or_numeric")};return k.runKernel(cC,c,{begin:n,end:t,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l})}}),FA=R({tan_:function Cwe(e){const t={x:E(e,"x","tan","float32")};return k.runKernel(Tf,t)}});function Wr(e,n){vc(e);const t=Xi(e,n);if(1!==t.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Hl(e,null,t,n)}function nu(e,n,t){if(vc(e),null!=n&&2!==n.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Xi(e,t);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Hl(e,n,r,t)}function $j(e,n,t){if(vc(e),null!=n&&4!==n.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Xi(e,t);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Hl(e,n,r,t)}function Pj(e,n,t){if(vc(e),null!=n&&5!==n.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Xi(e,t);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Hl(e,n,r,t)}function Lj(e,n,t){if(vc(e),null!=n&&6!==n.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Xi(e,t);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==n)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Hl(e,n=n||r,r,t)}const Vj=R({tensorScatterUpdate_:function Iwe(e,n,t){const r=E(e,"tensor","tensorScatterupdate"),s=E(n,"indices","tensorScatterupdate","int32"),o=E(t,"updates","tensorScatterupdate");if(MC(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);return k.runKernel(nC,{tensor:r,indices:s,updates:o},{})}}),$A=R({topk_:function Swe(e,n=1,t=!0){const r=E(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${n}`);const o={x:r},i={k:n,sorted:t},[a,l]=k.runKernel(pC,o,i);return{values:a,indices:l}}}),sI=R({truncatedNormal_:function _we(e,n=0,t=1,r,s){if(Ks(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new TA(n,t,r,!0,s),i=it(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}}),PA=R({unique_:function Ewe(e,n=0){const t=E(e,"x","unique","string_or_numeric");S(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:n},[o,i]=k.runKernel(gC,r,s);return{values:o,indices:i}}}),oI=R({unsortedSegmentSum_:function Dwe(e,n,t){const r=E(e,"x","unsortedSegmentSum"),s=E(n,"segmentIds","unsortedSegmentSum","int32");return S(bc(t),()=>"numSegments must be of dtype int"),k.runKernel(My,{x:r,segmentIds:s},{numSegments:t})}}),So=R({unstack_:function Nwe(e,n=0){const t=E(e,"x","unstack","string_or_numeric");return S(n>=-t.shape.length&&n<t.shape.length,()=>`Axis = ${n} is not in [-${t.shape.length}, ${t.shape.length})`),k.runKernel(Ry,{value:t},{axis:n})}});function Bj(e,n){return GC(e,n,"right")}function LA(e,n=!0,t,r){return k.makeVariable(e,n,t,r)}function iI(e,n){const t=[];for(let o=0;o<n.length;o++)n[o]&&t.push(o);const r=it(e,"int32"),s=it([t.length,e.length],"int32");for(let o=0;o<t.length;o++){const i=r.indexToLoc(t[o]);s.values.set(i,o*e.length)}return s.toTensor()}function VA(){return(VA=F(function*(e){const n=E(e,"condition","whereAsync","bool"),t=yield n.data(),r=iI(n.shape,t);return e!==n&&n.dispose(),r})).apply(this,arguments)}const BA=function Twe(e){return VA.apply(this,arguments)};function zA(){return(zA=F(function*(e,n,t){const r=E(e,"tensor","boolMask"),s=E(n,"mask","boolMask","bool"),o=t??0,i=s.rank,a=r.shape;S(i>0,()=>"mask cannot be scalar"),Pr(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=o;m<o+i;m++)l*=a[m];const u=a.slice(0,o).concat([l],a.slice(o+i)),c=O(r,u),d=O(s,[-1]),h=yield BA(d),f=Qs(h,[1]),p=qf(c,f,o);return e!==r&&r.dispose(),n!==s&&s.dispose(),f.dispose(),c.dispose(),d.dispose(),h.dispose(),p})).apply(this,arguments)}const zj=function kwe(e,n,t){return zA.apply(this,arguments)},Uj=R({movingAverage_:function Awe(e,n,t,r,s=!0){const o=E(e,"v","movingAverage"),i=E(n,"x","movingAverage"),a=E(t,"decay","movingAverage");uH(o,i),S(wt(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=Re(1),u=Ce(l,a);let c=M(Ce(i,o),u);if(s){S(null!=r,()=>"When using zeroDebias: true, step is required.");const d=E(r,"step","movingAverage");c=ke(c,Ce(l,Ji(a,d)))}return ne(o,c)}}),Wj=R({scatterND_:function Rwe(e,n,t){Ks(t);const r=E(e,"indices","scatterND","int32"),s=E(n,"updates","scatterND");return MC(s,r,t),k.runKernel(tC,{indices:r,updates:s},{shape:t})}}),Hj=R({sparseToDense_:function Owe(e,n,t,r=0){Ks(t);const s=E(e,"sparseIndices","sparseToDense","int32"),o=E(n,"sparseValues","sparseToDense","string_or_numeric"),i=E(r,"defaultValue","sparseToDense",o.dtype);return function Mwe(e,n,t,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);if(0!==n.rank&&(1!==n.rank||n.size!==s))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${s}]`);if(n.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,t,i),k.runKernel(lC,{sparseIndices:s,sparseValues:o,defaultValue:i},{outputShape:t})}}),jj=R({gatherND_:function Fwe(e,n){const t=E(n,"indices","gatherND","int32"),s={params:E(e,"x","gatherND","string_or_numeric"),indices:t};return k.runKernel($0,s)}}),UA=R({dropout_:function Pwe(e,n,t,r){const s=E(e,"x","dropout");if(S("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),0===n)return e instanceof St?s.clone():s;const o=function $we(e,n){if(null==n)return e.shape.slice();if(wt(e.shape,n))return n;if(e.shape.length===n.length){const t=[];for(let r=0;r<e.shape.length;r++)t.push(null==n[r]&&null!=e.shape[r]?e.shape[r]:n[r]);return t}return n}(s,t),i=1-n,a=ke(Gf(ne(tu(o,0,1,"float32",r),i)),i);return M(s,a)}});function WA(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function aI(e,n,t){const r=1-e%2,s=new Float32Array(e);for(let o=0;o<e;++o){const i=2*Math.PI*o/(e+r-1);s[o]=n-t*Math.cos(i)}return Wr(s,"float32")}function HA(){return(HA=F(function*(e,n,t=1){const r=E(e,"predictions","inTopK"),s=E(n,"targets","inTopK");S(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),S(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Pr(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];S(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const i=yield r.data(),a=yield s.data(),[l,u]=[i.length/o,o],c=Er("bool",l);for(let d=0;d<l;d++){const h=d*u,f=i.subarray(h,h+u),p=[];for(let m=0;m<f.length;m++)p.push({value:f[m],index:m});p.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<t;m++)if(p[m].index===a[d]){c[d]=1;break}}return e!==r&&r.dispose(),n!==s&&s.dispose(),cs(c,s.shape,"bool")})).apply(this,arguments)}const Gj=function Lwe(e,n){return HA.apply(this,arguments)},jA=R({conv2DBackpropFilter_:function Vwe(e,n,t,r,s,o="NHWC",i){let a=e;3===e.rank&&(a=O(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=n;3===l.rank&&(l=O(n,[1,n.shape[0],n.shape[1],n.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===t.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?l.shape[3]:l.shape[1];return S(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),S(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),hs("conv2dDerFilter",s,i),k.runKernel(v0,{x:a,dy:l},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:t})}});function lI(e,n,t){if(null==t||"linear"===t)return e;if("relu"===t)return M(e,Bc(n));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function uI(e,n){let t=n;const r=er(e.shape,n.shape);return r.length>0&&(t=De(t,r)),O(t,e.shape)}function cI(e,n,t,r){if("linear"===n)return e;if("relu"===n)return gi(e);if("elu"===n)return Wf(e);if("relu6"===n)return KC(e);if("prelu"===n)return cv(e,t);if("leakyrelu"===n)return rv(e,r);if("sigmoid"===n)return wo(e);throw new Error(`Unknown fused activation ${n}.`)}const dI=(e,n)=>!(e>0)||"linear"===n,qj=R({fusedConv2d_:function Bwe({x:e,filter:n,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===dI(k.state.gradientDepth,l=l||"linear")){S("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=Wa(e,n,t,r,s,o,i);return null!=a&&(I=ne(I,a)),cI(I,l,u,c)}const d=E(e,"x","conv2d","float32"),h=E(n,"filter","conv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=O(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),hs("fused conv2d",r,i);const m="NHWC"===s?f.shape[3]:f.shape[1];S(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),S(Br(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const g=Tr(f.shape,h.shape,t,o,r,i);let y,v;if(null!=a&&(y=E(a,"bias","fused conv2d"),[y]=_n(y,d),"NHWC"===s?et(g.outShape,y.shape):(S(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),S(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=u){const I=u.shape;if(S(I.length<=1||3===I.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),1===I.length)S(1===I[0]||I[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===I.length)try{et(I,g.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}v=E(u,"prelu weights","fused conv2d")}const b=(I,_)=>{S("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[D,N,T,P]=_,B=lI(I,T,l);S(Yl(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const G=[aA(N.shape,B,D,t,r),jA(N,B,D.shape,t,r)];if(null!=P){const Y=uI(P,B);G.push(Y)}return G},w={x:f,filter:h,bias:y,preluActivationWeights:v},x={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?Qi((_,D,N)=>{let T=k.runKernel($y,w,x);return N([D,_,T]),p&&(T=O(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:b}})(f,h):Qi((_,D,N,T)=>{let P=k.runKernel($y,w,x);return T([D,_,P,N]),p&&(P=O(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(f,h,y)}}),Kj=R({depthwiseConv2dNativeBackpropFilter_:function zwe(e,n,t,r,s,o=[1,1],i){let a=e;3===e.rank&&(a=O(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=n;return 3===l.rank&&(l=O(n,[1,n.shape[0],n.shape[1],n.shape[2]])),k.runKernel(_0,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:t})}}),Xj=R({depthwiseConv2dNativeBackpropInput_:function Uwe(e,n,t,r,s,o=[1,1],i){let a=n,l=!1;3===n.rank&&(l=!0,a=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const d=k.runKernel(E0,{dy:a,filter:t},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:e});return l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Hwe=R({fusedDepthwiseConv2d_:function Wwe({x:e,filter:n,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===dI(k.state.gradientDepth,l)){let x=Uf(e,n,t,r,s,o,i);return null!=a&&(x=ne(x,a)),cI(x,l,u,c)}const d=E(e,"x","depthwiseConv2d","float32"),h=E(n,"filter","depthwiseConv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=O(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==o&&(o=[1,1]),S(Br(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),hs("fused depthwiseConv2d",r,i);const m=Tr(f.shape,h.shape,t,o,r,i,!0);let g,y;null!=a&&(g=E(a,"bias","fused conv2d"),[g]=_n(g,d),et(m.outShape,g.shape)),null!=u&&(y=E(u,"prelu weights","fused depthwiseConv2d"));const v=(x,I)=>{S(Yl(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[_,D,N,T]=I,P=lI(x,N,l),B=Xj(D.shape,P,_,t,r,o,i),W=Kj(D,P,_.shape,t,r,o,i);return null!=T?[B,W,uI(g,P)]:[B,W]},b={x:f,filter:h,bias:g,preluActivationWeights:y},w={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==a?Qi((I,_,D)=>{let N=k.runKernel(Py,b,w);return D([_,I,N]),p&&(N=O(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:v}})(f,h):Qi((I,_,D,N)=>{let T=k.runKernel(Py,b,w);return N([_,I,T,D]),p&&(T=O(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:v}})(f,h,g)}}),GA=R({fusedMatMul_:function jwe({a:e,b:n,transposeA:t=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(!1===dI(k.state.gradientDepth,o)){let P=at(e,n,t,r);return null!=s&&(P=ne(P,s)),cI(P,o,i,a)}let l=E(e,"a","fused matMul"),u=E(n,"b","fused matMul");[l,u]=_n(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=t?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],p=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=j(p),y=j(m);S(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${r} must match.`);const b=et(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,f]),w=O(l,t?[g,c,h]:[g,h,c]),x=O(u,r?[y,f,d]:[y,d,f]);let I,_;null!=s&&(I=E(s,"bias","fused matMul"),[I]=_n(I,l),et(b,I.shape)),null!=i&&(_=E(i,"prelu weights","fused matMul"));const D=(P,B)=>{const[W,H,G,Y]=B,Q=lI(O(P,G.shape),G,o);let q,J;return t||r?!t&&r?(q=at(Q,H,!1,!1),J=at(Q,W,!0,!1)):t&&!r?(q=at(H,Q,!1,!0),J=at(W,Q,!1,!1)):(q=at(H,Q,!0,!0),J=at(Q,W,!0,!0)):(q=at(Q,H,!1,!0),J=at(W,Q,!0,!1)),null!=s?[q,J,uI(Y,Q)]:[q,J]},N={a:w,b:x,bias:I,preluActivationWeights:_},T={transposeA:t,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?Qi((B,W,H)=>{const G=k.runKernel(Fy,N,T);return H([B,W,G]),{value:O(G,b),gradFunc:D}})(w,x):Qi((B,W,H,G)=>{const Y=k.runKernel(Fy,N,T);return G([B,W,Y,H]),{value:O(Y,b),gradFunc:D}})(w,x,I)}}),qwe=R({hammingWindow_:function Gwe(e){return aI(e,.54,.46)}}),Yj=R({hannWindow_:function Kwe(e){return aI(e,.5,.5)}}),Zj=R({frame_:function Xwe(e,n,t,r=!1,s=0){let o=0;const i=[];for(;o+n<=e.size;)i.push(Et(e,o,n)),o+=t;if(r)for(;o<e.size;){const a=o+n-e.size,l=Un([Et(e,o,n-a),Ac([a],s)]);i.push(l),o+=t}return 0===i.length?nu([],[0,n]):O(Un(i),[i.length,n])}}),Zwe=R({stft_:function Ywe(e,n,t,r,s=Yj){null==r&&(r=WA(n));const o=Zj(e,n,t),i=M(o,s(n));return mv(i,r)}}),Jwe=R({cropAndResize_:function Qwe(e,n,t,r,s="bilinear",o=0){const i=E(e,"image","cropAndResize"),a=E(n,"boxes","cropAndResize","float32"),l=E(t,"boxInd","cropAndResize","int32"),u=a.shape[0];return S(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),S(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),k.runKernel(C0,{image:i,boxes:a,boxInd:l},{method:s,extrapolationValue:o,cropSize:r})}}),txe=R({flipLeftRight_:function exe(e){const n=E(e,"image","flipLeftRight","float32");return S(4===n.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`),k.runKernel(F0,{image:n},{})}}),rxe=R({grayscaleToRGB_:function nxe(e){const n=E(e,"image","grayscaleToRGB"),t=n.rank-1,r=n.shape[t];S(n.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${n.rank}.`),S(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(n.rank);return s.fill(1,0,t),s[t]=3,Co(n,s)}}),oxe=R({rgbToGrayscale_:function sxe(e){const n=E(e,"image","RGBToGrayscale"),r=n.shape[n.rank-1];S(n.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${n.rank}.`),S(3===r,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=n.dtype,o=pe(n,"float32"),i=Wr([.2989,.587,.114]);let a;switch(n.rank){case 2:a=Pc("ij,j->i",o,i);break;case 3:a=Pc("ijk,k->ij",o,i);break;case 4:a=Pc("ijkl,l->ijk",o,i);break;case 5:a=Pc("ijklm,m->ijkl",o,i);break;case 6:a=Pc("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=jn(a,-1),pe(a,s)}}),axe=R({rotateWithOffset_:function ixe(e,n,t=0,r=.5){const s=E(e,"image","rotateWithOffset","float32");return S(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),k.runKernel(vC,{image:s},{radians:n,fillValue:t,center:r})}});function Qf(e,n,t,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=e.shape[0];return t=Math.min(t,i),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),S(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),S(1===n.rank,()=>"scores must be a 1D tensor"),S(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),S(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const uxe=R({nonMaxSuppression_:function lxe(e,n,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=E(e,"boxes","nonMaxSuppression","float32"),i=E(n,"scores","nonMaxSuppression","float32"),a=Qf(o,i,t,r,s);return k.runKernel(j0,{boxes:o,scores:i},{maxOutputSize:t=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function cxe(e,n,t){const r=function dxe(e,n,t){return function fxe(e,n,t){let r=0,s=e.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=t(n,e[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(e,n,t||hxe)}(e,n,t);e.splice(r<0?-(r+1):r,0,n)}function hxe(e,n){return e>n?1:e<n?-1:0}function hI(e,n,t,r,s){return qA(e,n,t,r,s,0)}function fI(e,n,t,r,s,o){return qA(e,n,t,r,s,0,!1,o,!0)}function pI(e,n,t,r,s,o){return qA(e,n,t,r,s,o,!0)}function qA(e,n,t,r,s,o,i=!1,a=!1,l=!1){const u=[];for(let g=0;g<n.length;g++)n[g]>s&&u.push({score:n[g],boxIndex:g,suppressBeginIndex:0});u.sort(Qj);const c=o>0?-.5/o:0,d=[],h=[];for(;d.length<t&&u.length>0;){const g=u.pop(),{score:y,boxIndex:v,suppressBeginIndex:b}=g;if(y<s)break;let w=!1;for(let x=d.length-1;x>=b;--x){const I=pxe(e,v,d[x]);if(I>=r){w=!0;break}if(g.score=g.score*mxe(r,c,I),g.score<=s)break}g.suppressBeginIndex=d.length,w||(g.score===y?(d.push(v),h.push(g.score)):g.score>s&&cxe(u,g,Qj))}const f=d.length,p=t-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=f),m}function pxe(e,n,t){const r=e.subarray(4*n,4*n+4),s=e.subarray(4*t,4*t+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-o)*(l-i),p=(d-u)*(h-c);if(f<=0||p<=0)return 0;const m=Math.max(o,u),g=Math.max(i,c),y=Math.min(a,d),v=Math.min(l,h),b=Math.max(y-m,0)*Math.max(v-g,0);return b/(f+p-b)}function mxe(e,n,t){const r=Math.exp(n*t*t);return t<=e?r:0}function Qj(e,n){return e.score-n.score||e.score===n.score&&n.boxIndex-e.boxIndex}function KA(){return(KA=F(function*(e,n,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=E(e,"boxes","nonMaxSuppressionAsync"),i=E(n,"scores","nonMaxSuppressionAsync"),a=Qf(o,i,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([o.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=hI(u,c,t,r,s);return o!==e&&o.dispose(),i!==n&&i.dispose(),Wr(d,"int32")})).apply(this,arguments)}const bxe=R({nonMaxSuppressionWithScore_:function vxe(e,n,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=E(e,"boxes","nonMaxSuppression"),a=E(n,"scores","nonMaxSuppression"),l=Qf(i,a,t,r,s,o),d=k.runKernel(q0,{boxes:i,scores:a},{maxOutputSize:t=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function XA(){return(XA=F(function*(e,n,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=E(e,"boxes","nonMaxSuppressionAsync"),a=E(n,"scores","nonMaxSuppressionAsync"),l=Qf(i,a,t,r,s,o);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=yield Promise.all([i.data(),a.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:f}=pI(c,d,t,r,s,o);return i!==e&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Wr(h,"int32"),selectedScores:Wr(f)}})).apply(this,arguments)}const Ixe=R({nonMaxSuppressionPadded_:function Cxe(e,n,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=E(e,"boxes","nonMaxSuppression"),a=E(n,"scores","nonMaxSuppression"),l=Qf(i,a,t,r,s,null),p=k.runKernel(G0,{boxes:i,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:p[0],validOutputs:p[1]}}});function YA(){return(YA=F(function*(e,n,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=E(e,"boxes","nonMaxSuppressionAsync"),a=E(n,"scores","nonMaxSuppressionAsync"),l=Qf(i,a,t,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([i.data(),a.data()]),{selectedIndices:p,validOutputs:m}=fI(h,f,u,c,d,o);return i!==e&&i.dispose(),a!==n&&a.dispose(),{selectedIndices:Wr(p,"int32"),validOutputs:Re(m,"int32")}})).apply(this,arguments)}const Jj=R({resizeBilinear_:function Exe(e,n,t=!1,r=!1){const s=E(e,"images","resizeBilinear");S(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===n.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),S(!1===r||!1===t,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=O(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=k.runKernel(Iy,{images:o},{alignCorners:t,halfPixelCenters:r,size:n});return i?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),eG=R({resizeNearestNeighbor_:function Dxe(e,n,t=!1,r=!1){const s=E(e,"images","resizeNearestNeighbor");S(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===n.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),S("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===r||!1===t,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=O(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=n,u=k.runKernel(Cy,{images:o},{alignCorners:t,halfPixelCenters:r,size:n});return i?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),kxe=R({threshold_:function Nxe(e,n="binary",t=!1,r=.5){const s=E(e,"image","threshold"),l=s.shape[0]*s.shape[1];let c,d,h,f,u=M(Wr([r]),255);if(S(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S("otsu"===n||"binary"===n,()=>`Method must be binary or otsu, but was ${n}`),3===s.shape[2]){[c,d,h]=Os(s,[1,1,1],-1);const g=M(c,.2989),y=M(d,.587),v=M(h,.114);f=ne(ne(g,y),v)}else f=e;"otsu"===n&&(u=function Txe(e,n){let o,i,a,l,u,c,t=Wr([-1]),r=Wr([0]),s=Wr([0]);for(let d=0;d<e.size-1;d++){o=Et(e,0,d+1),i=Et(e,d+1),u=ke(De(o),n),c=ke(De(i),n);const h=De(M(o,Ga(0,o.size)));a=ke(h,De(o));const f=Ac(i.shape,o.size),p=ne(Ga(0,i.size),f),m=M(i,p);l=ke(De(m),De(i));const g=Ce(a,l),y=Ce(a,l),v=M(u,c);s=M(M(v,g),y);const b=fs(s,r);r=zr(b,s,r),t=zr(b,Wr([d]),t)}return t}(tA(pe(XC(f),"int32"),cs([]),256),l));const p=t?Jl(f,u):fs(f,u);return pe(M(p,255),"int32")}}),Rxe=R({transform_:function Axe(e,n,t="nearest",r="constant",s=0,o){const i=E(e,"image","transform","float32"),a=E(n,"transforms","transform","float32");return S(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),S(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),k.runKernel(mC,{image:i,transforms:a},{interpolation:t,fillMode:r,fillValue:s,outputShape:o})}}),Oxe=R({bandPart_:function Mxe(e,n,t){const r=E(e,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,l;"number"==typeof n?(S(n%1==0,()=>`bandPart(): numLower must be an integer, got ${n}.`),S(n<=o,()=>`bandPart(): numLower (${n}) must not be greater than the number of rows (${o}).`),a=E(n<0?o:n,"numLower","bandPart")):(S("int32"===n.dtype,()=>"bandPart(): numLower's dtype must be an int32."),a=zr(Kf(n,0),o,eu(n,o))),"number"==typeof t?(S(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),S(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),l=E(t<0?i:t,"numUpper","bandPart")):(S("int32"===t.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=zr(Kf(t,0),i,eu(t,i)));const u=O(Ga(0,o,1,"int32"),[-1,1]),c=Ga(0,i,1,"int32"),d=Ce(u,c),h=mi(Jl(d,a),Ha(d,on(l))),f=tr([o,i],r.dtype);return O(ps(So(O(r,[-1,o,i])).map(p=>zr(h,p,f))),s)}}),$xe=R({gramSchmidt_:function Fxe(e){let n;if(Array.isArray(e)){n=!1,S(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=e[0].shape[0];for(let o=1;o<e.length;++o)S(e[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[o].shape[0]} vs. ${s})`)}else n=!0,e=Os(e,e.shape[0],0).map(s=>Qs(s,[0]));S(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const t=[],r=e;for(let s=0;s<e.length;++s)t.push(k.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=M(De(M(t[i],o)),t[i]);o=Ce(o,a)}return ke(o,jf(o,"euclidean"))}));return n?ps(t,0):t}});function tG(e,n=!1){return k.tidy(()=>{S(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const t=e.shape[0],r=e.shape[1];let s=UC(t),o=Zi(e);const i=nu([[1]],[1,1]);let a=Zi(i);const l=t>=r?r:t;for(let u=0;u<l;++u){const c=o,d=a,h=s;[a,o,s]=k.tidy(()=>{const f=Et(o,[u,u],[t-u,1]),p=jf(f),m=Et(o,[u,u],[1,1]),g=zr(fs(m,0),nu([[-1]]),nu([[1]])),y=Ce(m,M(g,p)),v=ke(f,y);a=1===v.shape[0]?Zi(i):Un([i,Et(v,[1,0],[v.shape[0]-1,v.shape[1]])],0);const b=on(ke(at(g,y),p)),w=Et(o,[u,0],[t-u,r]),x=M(b,a),I=Ct(a);if(0===u)o=Ce(w,at(x,at(I,w)));else{const N=Ce(w,at(x,at(I,w)));o=Un([Et(o,[0,0],[u,r]),N],0)}const _=Ct(x),D=Et(s,[0,u],[t,s.shape[1]-u]);if(0===u)s=Ce(D,at(at(D,a),_));else{const N=Ce(D,at(at(D,a),_));s=Un([Et(s,[0,0],[t,u]),N],1)}return[a,o,s]}),ot([c,d,h])}return!n&&t>r&&(s=Et(s,[0,0],[t,r]),o=Et(o,[0,0],[r,r])),[s,o]})}const Lxe=R({qr_:function Pxe(e,n=!1){if(S(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return tG(e,n);{const t=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=So(O(e,[t,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],o=[];return r.forEach(l=>{const[u,c]=tG(l,n);s.push(u),o.push(c)}),[O(ps(s,0),e.shape),O(ps(o,0),e.shape)]}}});var Fs=function(e){return e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",e}(Fs||{});const qa=R({computeWeightedLoss_:function Vxe(e,n,t=Fs.SUM_BY_NONZERO_WEIGHTS){const r=E(e,"losses","computeWeightedLoss");let s=null;null!=n&&(s=E(n,"weights","computeWeightedLoss"));const o=null==s?r:M(r,s);if(t===Fs.NONE)return o;if(t===Fs.SUM)return De(o);if(t===Fs.MEAN){if(null==s)return Nn(o);{const i=r.size/s.size,a=ke(De(o),De(s));return i>1?ke(a,Re(i)):a}}if(t===Fs.SUM_BY_NONZERO_WEIGHTS){if(null==s)return ke(De(o),Re(r.size));{const i=M(s,Ms(r.shape)),a=pe(De(Vc(i,Re(0))),"float32");return ke(De(o),a)}}throw Error(`Unknown reduction: ${t}`)}}),zxe=R({absoluteDifference_:function Bxe(e,n,t,r=Fs.SUM_BY_NONZERO_WEIGHTS){const s=E(e,"labels","absoluteDifference"),o=E(n,"predictions","absoluteDifference");let i=null;null!=t&&(i=E(t,"weights","absoluteDifference")),Pr(s.shape,o.shape,"Error in absoluteDifference: ");const a=Jn(Ce(s,o));return qa(a,i,r)}}),Wxe=R({cosineDistance_:function Uxe(e,n,t,r,s=Fs.SUM_BY_NONZERO_WEIGHTS){const o=E(e,"labels","cosineDistance"),i=E(n,"predictions","cosineDistance");let a=null;null!=r&&(a=E(r,"weights","cosineDistance")),Pr(o.shape,i.shape,"Error in cosineDistance: ");const l=Re(1),u=Ce(l,De(M(o,i),t,!0));return qa(u,a,s)}}),jxe=R({hingeLoss_:function Hxe(e,n,t,r=Fs.SUM_BY_NONZERO_WEIGHTS){let s=E(e,"labels","hingeLoss");const o=E(n,"predictions","hingeLoss");let i=null;null!=t&&(i=E(t,"weights","hingeLoss")),Pr(s.shape,o.shape,"Error in hingeLoss: ");const a=Re(1);s=Ce(M(Re(2),s),a);const l=gi(Ce(a,M(s,o)));return qa(l,i,r)}}),qxe=R({huberLoss_:function Gxe(e,n,t,r=1,s=Fs.SUM_BY_NONZERO_WEIGHTS){const o=E(e,"labels","huberLoss"),i=E(n,"predictions","huberLoss");let a=null;null!=t&&(a=E(t,"weights","huberLoss")),Pr(o.shape,i.shape,"Error in huberLoss: ");const l=Re(r),u=Jn(Ce(i,o)),c=eu(u,l),d=Ce(u,c),h=ne(M(Re(.5),Kt(c)),M(l,d));return qa(h,a,s)}}),Xxe=R({logLoss_:function Kxe(e,n,t,r=1e-7,s=Fs.SUM_BY_NONZERO_WEIGHTS){const o=E(e,"labels","logLoss"),i=E(n,"predictions","logLoss");let a=null;null!=t&&(a=E(t,"weights","logLoss")),Pr(o.shape,i.shape,"Error in logLoss: ");const l=Re(1),u=Re(r),c=on(M(o,Ys(ne(i,u)))),d=M(Ce(l,o),Ys(ne(Ce(l,i),u))),h=Ce(c,d);return qa(h,a,s)}}),Zxe=R({meanSquaredError_:function Yxe(e,n,t,r=Fs.SUM_BY_NONZERO_WEIGHTS){const s=E(e,"labels","meanSquaredError"),o=E(n,"predictions","meanSquaredError");let i=null;null!=t&&(i=E(t,"weights","meanSquaredError")),Pr(s.shape,o.shape,"Error in meanSquaredError: ");const a=rI(s,o);return qa(a,i,r)}}),e0e=R({sigmoidCrossEntropy_:function Jxe(e,n,t,r=0,s=Fs.SUM_BY_NONZERO_WEIGHTS){let o=E(e,"multiClassLabels","sigmoidCrossEntropy");const i=E(n,"logits","sigmoidCrossEntropy");let a=null;if(null!=t&&(a=E(t,"weights","sigmoidCrossEntropy")),Pr(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=Re(r),c=Re(1),d=Re(.5);o=ne(M(o,Ce(c,u)),M(d,u))}const l=function Qxe(e,n){const t=E(e,"labels","sigmoidCrossEntropyWithLogits"),r=E(n,"logits","sigmoidCrossEntropyWithLogits");Pr(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=gi(r),o=M(r,t),i=sv(Rs(on(Jn(r))));return ne(Ce(s,o),i)}(o,i);return qa(l,a,s)}}),r0e=R({softmaxCrossEntropy_:function n0e(e,n,t,r=0,s=Fs.SUM_BY_NONZERO_WEIGHTS){let o=E(e,"onehotLabels","softmaxCrossEntropy");const i=E(n,"logits","softmaxCrossEntropy");let a=null;if(null!=t&&(a=E(t,"weights","softmaxCrossEntropy")),Pr(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const u=Re(r),c=Re(1),d=Re(o.shape[1]);o=ne(M(o,Ce(c,u)),ke(u,d))}const l=function t0e(e,n,t=-1){if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${n.rank} and dim was ${t}`);return Qi((s,o,i)=>{const l=ov(o,[t],!0),u=Ce(pe(o,"float32"),l);i([s,u]);const c=on(M(u,s));return{value:De(c,[t]),gradFunc:(f,p)=>{const[m,g]=p,y=Wn(f.shape,[t]);return[M(O(f,y),Ce(pe(m,"float32"),Rs(g))),M(O(f,y),Ce(Rs(g),pe(m,"float32")))]}}})(e,n)}(o,i);return qa(l,a,s)}}),nG={fft:pv,ifft:Zf,rfft:mv,irfft:nI},rG={hammingWindow:qwe,hannWindow:Yj,frame:Zj,stft:Zwe},ms={flipLeftRight:txe,grayscaleToRGB:rxe,resizeNearestNeighbor:eG,resizeBilinear:Jj,rgbToGrayscale:oxe,rotateWithOffset:axe,cropAndResize:Jwe,nonMaxSuppression:uxe,nonMaxSuppressionAsync:function gxe(e,n,t){return KA.apply(this,arguments)},nonMaxSuppressionWithScore:bxe,nonMaxSuppressionWithScoreAsync:function wxe(e,n,t){return XA.apply(this,arguments)},nonMaxSuppressionPadded:Ixe,nonMaxSuppressionPaddedAsync:function Sxe(e,n,t){return YA.apply(this,arguments)},threshold:kxe,transform:Rxe},ZA={bandPart:Oxe,gramSchmidt:$xe,qr:Lxe},sG={absoluteDifference:zxe,computeWeightedLoss:qa,cosineDistance:Wxe,hingeLoss:jxe,huberLoss:qxe,logLoss:Xxe,meanSquaredError:Zxe,sigmoidCrossEntropy:e0e,softmaxCrossEntropy:r0e},oG={sparseFillEmptyRows:R({sparseFillEmptyRows_:function s0e(e,n,t,r){const s=E(e,"indices","sparseFillEmptyRows","int32"),o=E(n,"values","sparseFillEmptyRows"),i=E(t,"denseShape","sparseFillEmptyRows","int32"),a=E(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u=k.runKernel(sC,{indices:s,values:o,denseShape:i,defaultValue:a});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),sparseReshape:R({sparseReshape_:function i0e(e,n,t){const r=E(e,"inputIndices","sparseReshape","int32"),s=E(n,"inputShape","sparseReshape","int32"),o=E(t,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a=k.runKernel(oC,{inputIndices:r,inputShape:s,newShape:o});return{outputIndices:a[0],outputShape:a[1]}}}),sparseSegmentMean:R({sparseSegmentMean_:function l0e(e,n,t){const r=E(e,"data","sparseSegmentMean"),s=E(n,"indices","sparseSegmentMean","int32"),o=E(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return k.runKernel(iC,{data:r,indices:s,segmentIds:o})}}),sparseSegmentSum:R({sparseSegmentSum_:function c0e(e,n,t){const r=E(e,"data","sparseSegmentSum"),s=E(n,"indices","sparseSegmentSum","int32"),o=E(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return k.runKernel(aC,{data:r,indices:s,segmentIds:o})}})},iG={stringNGrams:R({stringNGrams_:function h0e(e,n,t,r,s,o,i,a){const l=E(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=E(n,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const h=k.runKernel(dC,{data:l,dataSplits:u},{separator:t,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),stringSplit:R({stringSplit_:function p0e(e,n,t=!0){const r=E(e,"input","stringSplit","string"),s=E(n,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=k.runKernel(hC,{input:r,delimiter:s},{skipEmpty:t});return{indices:a[0],values:a[1],shape:a[2]}}}),stringToHashBucketFast:R({stringToHashBucketFast_:function g0e(e,n){const t=E(e,"input","stringToHashBucketFast","string"),r={numBuckets:n};if(n<=0)throw new Error("Number of buckets must be at least 1");return k.runKernel(fC,{input:t},r)}}),staticRegexReplace:R({staticRegexReplace_:function v0e(e,n,t,r=!0){const s=E(e,"input","staticRegexReplace","string");return k.runKernel(Ay,{x:s},{pattern:n,rewrite:t,replaceGlobal:r})}})},zc=sj,w0e=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function QA(){return new Promise(e=>w0e(()=>e()))}function JA(e,n){const t=e[0].length;e.forEach((s,o)=>{S(s.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),S(n>=0&&n<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=e[0];e.forEach((s,o)=>{for(let i=0;i<t;i++)S(i===n||s[i]===r[i],()=>`Error in concat${t}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function ta(e,n){const t=e[0].slice();for(let r=1;r<e.length;r++)t[n]+=e[r][n];return t}var na=function(e){return e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS",e}(na||{});function aG(e,n,t){let r=new Array;if(null==t&&null==n)return r;if(null==n)for(;r.length<e+t.length;)r.push(-1);else r=n.slice();if(null==t)return r;if(e+t.length!==r.length)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${e+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const o=t[s],i=r[r.length-t.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${s+e}] = ${o} but shape[${s+e}] = ${a}`)}else r[i]=o}return r}function lG(e){const n={FIRST_DIM_SIZE:na.FIRST_DIM_SIZE,VALUE_ROWIDS:na.VALUE_ROWIDS,ROW_LENGTHS:na.ROW_LENGTHS,ROW_SPLITS:na.ROW_SPLITS,ROW_LIMITS:na.ROW_LIMITS,ROW_STARTS:na.ROW_STARTS},t=[];for(const r of e){if(!(r in n))break;t.push(n[r])}return t}function uG(e){return 0===e.length?0:e[0]===na.FIRST_DIM_SIZE?e.length-1:e.length}function cG(e,n){if(null==e||null==n)return;const t=e.length,r=n.length;if(t>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const o=e[s],i=n[s+1];if(o>=0&&i>=0&&1!==o&&o!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${s-e.length}] = ${o} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}const eR=30;function mI(e){return e<=eR?e:u0(e,Math.floor(Math.sqrt(e)))}function tR(e,n,t){return[t*("number"==typeof e?e:e[0]),n*("number"==typeof e?e:e[1])]}function gv(e,n,t,r=!0){let s=[];if(r)s=s.concat(n.slice(0)),s.push(e[0]/t),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const o=n.length;for(let i=0;i<o;++i)s=s.concat([e[i+1]/n[i],n[i]]);s=s.concat(e.slice(o+1))}return s}function yv(e,n,t=!0){const r=[];if(t){r.push(n);for(let s=n+1;s<e;++s)s<=2*n?(r.push(s),r.push(s-(n+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<e;++i)i>=2*n+1||i%2==1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function vv(e,n,t,r=!0){const s=[];s.push(r?e[0]/t:e[0]*t);for(let o=1;o<e.length;++o)s.push(o<=n.length?r?n[o-1]*e[o]:e[o]/n[o-1]:e[o]);return s}function nR(e,n){const t=[0];for(let r=0;r<n;++r)t.push(e[r][0]);return t}function rR(e,n,t){const r=e.slice(0,1);for(let s=0;s<t;++s)r.push(e[s+1]-n[s][0]-n[s][1]);return r}const gI=1.7580993408473768,yI=1.0507009873554805,sR=.3275911,oR=.254829592,iR=-.284496736,aR=1.421413741,lR=-1.453152027,uR=1.061405429;function Ka(e,n){if(e.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${n.length}.`);const t=new Float32Array(2*e.length);for(let r=0;r<t.length;r+=2)t[r]=e[r/2],t[r+1]=n[r/2];return t}function dG(e){const n=new Float32Array(e.length/2),t=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)n[r/2]=e[r],t[r/2]=e[r+1];return{real:n,imag:t}}function hG(e){const n=Math.ceil(e.length/4),t=new Float32Array(n),r=new Float32Array(n);for(let s=0;s<e.length;s+=4)t[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:t,imag:r}}function fG(e){const n=Math.floor(e.length/4),t=new Float32Array(n),r=new Float32Array(n);for(let s=2;s<e.length;s+=4)t[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:t,imag:r}}function cR(e,n){return{real:e[2*n],imag:e[2*n+1]}}function pG(e,n,t,r){e[2*r]=n,e[2*r+1]=t}function mG(e,n){const t=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const o=(n?2:-2)*Math.PI*(s/e);t[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:t,imag:r}}function gG(e,n,t){const r=(t?2:-2)*Math.PI*(e/n);return{real:Math.cos(r),imag:Math.sin(r)}}const dR="->",x0e=/->/g,yG=",",vG="...";function hR(e,n){const t=((e=e.replace(/\s/g,"")).length-e.replace(x0e,"").length)/dR.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${dR}").`);const[r,s]=e.split(dR);S(-1===r.indexOf(vG),()=>`The ellipsis notation ("${vG}") is not supported yet.`);const o=r.split(yG),i=o.length;if(n!==i)throw new Error(`Expected ${i} input tensors, received ${n}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const f=s[h];if(!o.some(p=>-1!==p.indexOf(f)))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);-1===a.indexOf(f)&&a.push(f)}for(let h=0;h<r.length;++h){const f=r[h];-1===a.indexOf(f)&&f!==yG&&a.push(f)}const l=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let f=0;f<o[h].length;++f)l[h].push(a.indexOf(o[h][f]))}const u=a.length,d=[];for(let h=s.length;h<u;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function fR(e,n){let t=new Array(e);t.fill(-1);for(let s=0;s<n.length;++s)t[n[s]]=s;const r=[];for(let s=0;s<e;++s)-1===t[s]&&r.push(s);return t=t.filter(s=>-1!==s),{permutationIndices:t,expandDims:r}}function pR(e,n,t){const r=new Array(e);for(let s=0;s<t.length;++s){const o=t[s].shape;for(let i=0;i<n[s].length;++i)void 0===r[n[s][i]]?r[n[s][i]]=o[i]:S(r[n[s][i]]===o[i],()=>`Expected dimension ${r[n[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function mR(e,n){const t=e,r=[];let s=0;0===e.length&&t.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<t.length;++i){const l=C0e(n,t[i]);for(const u of l)-1===o.indexOf(u)&&(r[i].push(u),o.push(u))}return{path:t,steps:r}}function gR(e){return e.every((n,t)=>n===t)}function C0e(e,n){const t=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(n)||-1===n)&&t.push(r);return t}function yR(e,n,t=0){let r=[];if("number"==typeof n)S(e.shape[t]%n==0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(e.shape[t]/n);else{S(n.reduce((i,a)=>(-1===a&&(i+=1),i),0)<=1,()=>"There should be only one negative value in split array.");const o=n.indexOf(-1);if(-1!==o){const i=n.reduce((a,l)=>l>0?a+l:a);n[o]=e.shape[t]-i}S(e.shape[t]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}function bG(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function wG(e,n){return`indices(${e}, 0) is invalid: ${n} < 0`}function xG(e,n,t){return`indices(${e}, 0) is invalid: ${n} >= ${t}`}function CG(e,n){return`only one output dimension may be -1, not both ${e} and ${n}`}function IG(e,n){return`size ${e} must be non-negative, not ${n}`}function SG(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function _G(e,n){return`Input to reshape is a SparseTensor with ${j(e)}\n  dense values, but the requested shape requires a multiple of ${j(n)}. inputShape=${e} outputShape= ${n}`}function EG(e,n){return`Input to reshape is a tensor with ${j(e)} dense values, but the requested shape has ${j(n)}. inputShape=${e} outputShape=${n}`}function vR(){return"segment ids must be >= 0"}function DG(){return"segment ids are not increasing"}function NG(e,n){return`Segment id ${e} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function TG(e,n,t){return`Bad: indices[${e}] == ${n} out of range [0, ${t})`}function kG(e,n){let r,t=!1;for(e<=eR?(r=e,t=!0):r=u0(e,Math.floor(Math.sqrt(e)));!t;)r>n||r===e?t=!0:r=u0(e,r+1);return r}function AG(e,n,t){const r=[],s=e.length;for(let o=0;o<s;o++)r.push(o!==n?e[o]:t);return r}function bR(e,n,t,r){const s=n.shape.length,o=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let d=0;d<r;++d)if(e.shape[d]!==n.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${n.shape[d]}.`);const i=e.shape[t],a=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)a.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<t;d++)a.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)a.push(n.shape[d]);for(let d=t+1;d<o;d++)a.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:a}}function Xa(e){try{return e.map(n=>Pa(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function RG(e){return e.map(n=>qi(n))}!function Ege(){for(const e of _ge)oe(e)}();const MG={kernelName:Rg,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(e,Bc(pe(t,"float32"),-1))}}},I0e={kernelName:Fh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>{const r=Kt(pe(t,"float32")),s=Nr(Ce(Re(1),r));return on(ke(e,s))}}}},S0e={kernelName:$h,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>{const r=Nr(Ce(Kt(pe(t,"float32")),1));return ke(e,r)}}}},_0e={kernelName:Ic,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=et(t.shape,r.shape);return{a:()=>{let a=e;const l=er(t.shape,s);return l.length>0&&(a=De(a,l)),O(a,t.shape)},b:()=>{let a=e;const l=er(r.shape,s);return l.length>0&&(a=De(a,l)),O(a,r.shape)}}}},E0e={kernelName:Mg,saveAllInputs:!0,gradFunc:(e,n)=>{const t={};return n.forEach((r,s)=>{t[s]=()=>e.clone()}),t}},D0e={kernelName:Og,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>_t(t)}}},N0e={kernelName:Fg,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>_t(t)}}},T0e={kernelName:Ph,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,Nr(Ce(Re(1),Kt(pe(t,"float32")))))}}},k0e={kernelName:Lh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>{const r=Nr(ne(Re(1),Kt(pe(t,"float32"))));return ke(e,r)}}}},A0e={kernelName:zh,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=et(t.shape,r.shape);return{a:()=>{const a=ne(Kt(t),Kt(r));let l=M(e,ke(r,a));const u=er(t.shape,s);return u.length>0&&(l=De(l,u)),O(l,t.shape)},b:()=>{const a=ne(Kt(t),Kt(r));let l=on(M(e,ke(t,a)));const u=er(r.shape,s);return u.length>0&&(l=De(l,u)),O(l,r.shape)}}}},R0e={kernelName:Vh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,ne(Kt(pe(t,"float32")),1))}}},M0e={kernelName:Bh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,Ce(Re(1),Kt(pe(t,"float32"))))}}},F0e=R({avgPool3dGrad_:function O0e(e,n,t,r,s,o){const i=E(e,"dy","avgPool3dGrad"),a=E(n,"input","avgPool3dGrad");let l=i,u=a,c=!1;4===a.rank&&(c=!0,l=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),hs("avgPool3dGrad",s,o);const f=k.runKernel(p0,{dy:l,input:u},{filterSize:t,strides:r,pad:s,dimRoundingMode:o});return c?O(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),$0e={kernelName:Pg,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{filterSize:s,strides:o,pad:i,dimRoundingMode:a}=t;return{x:()=>F0e(e,r,s,o,i,a)}}},L0e=R({avgPoolGrad_:function P0e(e,n,t,r,s){const o=E(e,"dy","avgPoolGrad"),i=E(n,"input","avgPoolGrad");S(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,l=o,u=!1;3===i.rank&&(u=!0,a=O(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=O(o,[1,o.shape[0],o.shape[1],o.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=k.runKernel(f0,{dy:l,input:a},{filterSize:t,strides:r,pad:s});return u?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),V0e={kernelName:$g,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{filterSize:s,strides:o,pad:i}=t;return{x:()=>L0e(e,r,s,o,i)}}},B0e={kernelName:Lg,inputsToSave:["a","b"],gradFunc:(e,n,t)=>{const[r,s]=n,{transposeA:o,transposeB:i}=t;return o||i?!o&&i?{a:()=>at(e,s,!1,!1),b:()=>at(e,r,!0,!1)}:o&&!i?{a:()=>at(s,e,!1,!0),b:()=>at(r,e,!1,!1)}:{a:()=>at(s,e,!0,!0),b:()=>at(e,r,!0,!0)}:{a:()=>at(e,s,!1,!0),b:()=>at(r,e,!0,!1)}}},z0e={kernelName:Vg,gradFunc:(e,n,t)=>{const{blockShape:r,crops:s}=t;return{x:()=>uv(e,r,s)}}},U0e={kernelName:W4,gradFunc:(e,n,t)=>{const s=t.inputShape,o=t.shape,i=Array.from(o);for(let l=s.length-1;l>=0;l--)if(s[l]===o[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>De(e,a,!0)}}},W0e={kernelName:Uh,gradFunc:e=>({x:()=>e.clone()})},H0e={kernelName:Wh,gradFunc:e=>({x:()=>_t(e)})},j0e={kernelName:Hh,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{clipValueMin:s,clipValueMax:o}=t;return{x:()=>zr(mi(Ha(r,s),Jl(r,o)),e,_t(e))}}},G0e={kernelName:zg,inputsToSave:["x"],gradFunc:MG.gradFunc},q0e={kernelName:Ug,saveAllInputs:!0,gradFunc:(e,n,t)=>{const r=n.map(l=>l.shape),{axis:s}=t,o=pt(s,n[0].shape)[0],i=r.map(l=>l[o]);return Os(e,i,o).map(l=>()=>l)}},K0e={kernelName:Wg,inputsToSave:["x","filter"],gradFunc:(e,n,t)=>{const[r,s]=n,{dilations:o,strides:i,pad:a,dataFormat:l}=t;return S(Yl(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>aA(r.shape,e,s,i,a,l),filter:()=>jA(r,e,s.shape,i,a,l)}}},X0e={kernelName:Hg,inputsToSave:["dy","filter"],gradFunc:(e,n,t)=>{const[r,s]=n,{strides:o,pad:i,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>Wa(e,s,o,i,a,1,l),filter:()=>jA(e,r,s.shape,o,i,a,l)}}},Z0e=R({conv3DBackpropFilter_:function Y0e(e,n,t,r,s){let o=e;4===e.rank&&(o=O(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=n;return 4===i.rank&&(i=O(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),S(5===o.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),S(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),S(5===t.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),S(o.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${t[3]}.`),S(i.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${t[4]}).`),k.runKernel(b0,{x:o,dy:i},{strides:r,pad:s,filterShape:t})}}),Q0e={kernelName:jg,inputsToSave:["x","filter"],gradFunc:(e,n,t)=>{const{dilations:r,strides:s,pad:o}=t;S(Yl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,a]=n;return{x:()=>uj(i.shape,e,a,s,o),filter:()=>Z0e(i,e,a.shape,s,o)}}},J0e={kernelName:jh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(on(JC(pe(t,"float32"))),e)}}},eCe={kernelName:Gh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(eI(pe(t,"float32")),e)}}},tCe={kernelName:Gg,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{axis:s,exclusive:o,reverse:i}=t;return{x:()=>{const a=Dn([s],r.rank);let l=VC(e,s,o,!i);return null!=a&&(l=Ct(l,a)),l}}}},nCe={kernelName:qg,inputsToSave:["x","filter"],gradFunc:(e,n,t)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:i}=t,a=r??[1,1];S(Yl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=n;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),S(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),S(Br(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),hs("depthwiseConv2d",o,i),{x:()=>Xj(l.shape,e,u,s,o,a,i),filter:()=>Kj(l,e,u.shape,s,o,a,i)}}},rCe={kernelName:Kg,inputsToSave:["x","filter"],gradFunc:(e,n,t)=>{const[r,s]=n,o={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>k.runKernel(N0,o,t),filter:()=>k.runKernel(T0,i,t)}}},sCe={kernelName:Kh,outputsToSave:[!0],gradFunc:(e,n)=>{const[t]=n,r={dy:e,y:t};return{x:()=>k.runKernel(R0,r)}}},oCe={kernelName:Xh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n,r=M(Rs(on(Kt(t))),2/Math.sqrt(Math.PI));return{x:()=>M(e,r)}}},iCe={kernelName:Yh,outputsToSave:[!0],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(e,t)}}},aCe={kernelName:Yg,inputsToSave:["input"],gradFunc:(e,n)=>{const[t]=n;return{input:()=>O(e,t.shape)}}},lCe={kernelName:Zh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(e,Rs(t))}}},uCe={kernelName:Qh,gradFunc:e=>({x:()=>_t(e)})},cCe={kernelName:Jh,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=et(t.shape,r.shape);return{a:()=>{const a=ke(e,pe(r,"float32")),l=er(t.shape,s);return l.length>0?O(De(a,l),t.shape):a},b:()=>{let a=M(e,pe(t,"float32"));const l=er(r.shape,s);l.length>0&&(a=O(De(a,l),r.shape));const u=Kt(r);return on(ke(a,pe(u,"float32")))}}}},dCe={kernelName:Zg,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,n,t)=>{const{varianceEpsilon:r}=t,[s,o,i,a]=n,l=a??Re(1),u=er(o.shape,s.shape),c=[];if(1===o.rank){for(let w=0;w<s.shape.length-1;++w)c.push(s.shape[w]);c.push(1)}const d=Ce(s,o),h=M(e,l),f=YC(ne(i,Re(r))),p=M(M(M(f,f),f),Re(-.5));return{x:()=>O(M(M(e,1===o.rank?Co(O(f,[1,1,1,o.shape[0]]),c):f),l),s.shape),mean:()=>{let w=M(M(f,Re(-1)),h);return 1===o.rank&&(w=De(w,u)),O(w,o.shape)},variance:()=>{let w=M(M(p,d),h);return 1===o.rank&&(w=De(w,u)),O(w,o.shape)},scale:()=>{const w=M(d,f);let x=M(e,w);return 1===o.rank&&(x=De(x,u)),O(x,o.shape)},offset:()=>{let w=e;return 1===o.rank&&(w=De(w,u)),O(w,o.shape)}}}},hCe={kernelName:Qg,inputsToSave:["x","indices"],gradFunc:(e,n,t)=>{const[r,s]=n,{axis:o,batchDims:i}=t,a=pt(o,r.shape)[0],l=(u,c,d)=>()=>{const h=u.shape,f=c.size,p=h.slice(0,a),m=p.length,g=h.slice(o,h.length).slice(1),y=g.length,v=OG(0,m),b=OG(m+1,m+1+y),w=FG([p,[f],g]),x=O(d,w),I=O(c,[f]),_=FG([[m],v,b]),D=Ct(x,_);let N=oI(D,I,u.shape[a]);const T=Ql(_);return N=Ct(N,T),N};if(1===i){const c=r.split(r.shape[0],0);return{x:()=>ps(c.map((f,p)=>l(f,s.slice(p,1),e.slice(p,1))())).reshape(r.shape),indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function OG(e,n){const t=[];for(let r=e;r<n;++r)t.push(r);return t}function FG(e){const n=[];for(let t=0;t<e.length;++t)for(let r=0;r<e[t].length;++r)n.push(e[t][r]);return n}const fCe={kernelName:ef,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n;return{a:()=>_t(t),b:()=>_t(r)}}},pCe={kernelName:nf,gradFunc:e=>({x:()=>pe(e,"float32")})},mCe={kernelName:rf,gradFunc:e=>({x:()=>_t(e)})},gCe={kernelName:sf,gradFunc:e=>({x:()=>_t(e)})},yCe={kernelName:af,gradFunc:e=>({x:()=>_t(e)})},vCe={kernelName:ey,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{alpha:s}=t,o=fs(r,0);return{x:()=>zr(o,e,M(e,s))}}},bCe={kernelName:uf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,ne(t,1))}}},wCe={kernelName:lf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,pe(t,"float32"))}}},xCe={kernelName:H4,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,n,t)=>{const[r]=n,{axis:s}=t;return{logits:()=>{const i=Rs(r);return Ce(e,M(De(e,s,!0),i))}}}},ICe=R({localResponseNormalizationBackprop_:function CCe(e,n,t,r=5,s=1,o=1,i=.5){return k.runKernel(B0,{x:e,y:n,dy:t},{depthRadius:r,bias:s,alpha:o,beta:i})}}),SCe={kernelName:iy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,n,t)=>{const[r,s]=n,{depthRadius:o,bias:i,alpha:a,beta:l}=t;return{x:()=>ICe(r,s,e,o,i,a,l)}}};function $G(e,n,t,r){return n.rank<t.rank&&(n=O(n,Wn(n.shape,r))),e.rank<t.rank&&(e=O(e,Wn(e.shape,r))),{x:()=>M(e,pe(Xs(t,n),e.dtype))}}const PG={kernelName:ay,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,n,t)=>{const r=t,{reductionIndices:s}=r,o=n[0],l=$G(e,n[1],o,pt(s,o.shape));return{x:()=>l.x()}}},_Ce={kernelName:cf,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n;return{a:()=>M(e,pe(Ha(t,r),"float32")),b:()=>M(e,pe(Kf(t,r),"float32"))}}},DCe=R({maxPool3dGrad_:function ECe(e,n,t,r,s,o,i){const a=E(e,"dy","maxPool3dGrad"),l=E(n,"input","maxPool3dGrad"),u=E(t,"output","maxPool3dGrad");let c=a,d=l,h=u,f=!1;4===l.rank&&(f=!0,c=O(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=O(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=O(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),S(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),hs("maxPool3dGrad",o,i);const g=k.runKernel(U0,{dy:c,input:d,output:h},{filterSize:r,strides:s,pad:o,dimRoundingMode:i});return f?O(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),NCe={kernelName:uy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,n,t)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=t;return{x:()=>DCe(e,r,s,o,i,a,l)}}},kCe=R({maxPoolGrad_:function TCe(e,n,t,r,s,o,i){const a=E(e,"dy","maxPoolGrad"),l=E(n,"input","maxPoolGrad"),u=E(t,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),hs("maxPoolGrad",o,i),k.runKernel(z0,{dy:a,input:l,output:u},{filterSize:r,strides:s,pad:o,dimRoundingMode:i})}}),LG={kernelName:vy,inputsToSave:["x"],gradFunc:(e,n,t)=>{const r=n[0],{paddings:s}=t,o=s.map(i=>i[0]);return{x:()=>Et(e,o,r.shape)}}};const VG={kernelName:Ny,gradFunc:(e,n,t)=>{const{blockShape:r,paddings:s}=t;return{x:()=>ev(e,r,s)}}},BG={kernelName:Ty,gradFunc:(e,n,t)=>{const{axis:r}=t;return{x:()=>Un(e,r)}}},EIe=[MG,I0e,S0e,_0e,E0e,D0e,N0e,T0e,k0e,A0e,R0e,M0e,$0e,V0e,B0e,z0e,U0e,W0e,H0e,j0e,G0e,q0e,X0e,K0e,Q0e,J0e,eCe,tCe,nCe,rCe,{kernelName:qh,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=et(t.shape,r.shape);return{a:()=>{const a=ke(e,pe(r,"float32")),l=er(t.shape,s);return l.length>0?O(De(a,l),t.shape):a},b:()=>{let a=M(e,pe(t,"float32"));const l=er(r.shape,s);l.length>0&&(a=O(De(a,l),r.shape));const u=Kt(r);return on(ke(a,pe(u,"float32")))}}}},sCe,oCe,iCe,aCe,lCe,cCe,uCe,dCe,hCe,fCe,pCe,mCe,gCe,yCe,vCe,bCe,wCe,xCe,SCe,PG,PG,_Ce,NCe,{kernelName:ly,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,n,t)=>{const[r,s]=n,{filterSize:o,strides:i,pad:a}=t;return{x:()=>kCe(e,r,s,o,i,a)}}},{kernelName:cy,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{axis:s}=t,o=pt(s,r.shape),l=j(kr(r.shape,o)[1]);return{x:()=>{const c=r.shape.slice();o.forEach(f=>{c[f]=1});const d=O(e,c);return ke(M(d,Ms(r.shape,"float32")),l)}}}},{kernelName:dy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,n,t)=>{const r=t,{axis:s}=r,[o,i]=n,l=$G(e,i,o,pt(s,o.shape));return{x:()=>l.x()}}},{kernelName:df,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n;return{a:()=>M(e,pe(Jl(t,r),"float32")),b:()=>M(e,pe(fs(t,r),"float32"))}}},{kernelName:hy,inputsToSave:["x"],gradFunc:(e,n,t)=>{const r=n[0],{paddings:s}=t,o=s.map(i=>i[0]);return{x:()=>Et(e,o,r.shape)}}},{kernelName:hf,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=et(t.shape,r.shape);return{a:()=>{const a=er(t.shape,s);return a.length>0?O(De(e,a),t.shape):e},b:()=>{const a=M(e,on(Gf(ke(t,r)))),l=er(r.shape,s);return l.length>0?O(De(a,l),r.shape):a}}}},{kernelName:ff,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=et(t.shape,r.shape);return{a:()=>{const a=M(e,pe(r,"float32")),l=er(t.shape,s);return l.length>0?O(De(a,l),t.shape):a},b:()=>{const a=M(e,pe(t,"float32")),l=er(r.shape,s);return l.length>0?O(De(a,l),r.shape):a}}}},{kernelName:fy,gradFunc:e=>({x:()=>on(e)})},{kernelName:gy,inputsToSave:["indices"],gradFunc:(e,n)=>{const t=n[0];return{indices:()=>tr(t.shape,"float32")}}},{kernelName:my,gradFunc:e=>({x:()=>_t(e)})},{kernelName:yy,saveAllInputs:!0,gradFunc:(e,n,t)=>{const{axis:r}=t;return So(e,r).map(o=>()=>o)}},LG,LG,{kernelName:pf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,n)=>{const[t,r,s]=n,o=t,i=r,a=et(o.shape,i.shape);return{a:()=>{const c=pe(i,"float32");let d=M(e,M(c,Ji(o,Ce(c,Re(1)))));const h=er(o.shape,a);return h.length>0&&(d=De(d,h)),O(d,o.shape)},b:()=>{const c=fs(o,0),d=zr(c,Ys(o),_t(o));let h=M(e,M(s,d));const f=er(i.shape,a);return f.length>0&&(h=De(h,f)),O(h,i.shape)}}}},{kernelName:by,inputsToSave:["x","alpha"],gradFunc:(e,n)=>{const[t,r]=n,s=fs(t,0);return{x:()=>zr(s,e,M(e,r)),alpha:()=>{let o=zr(s,_t(e),M(e,t));const i=er(r.shape,e.shape);return i.length>0&&(o=De(o,i)),O(o,r.shape)}}}},{kernelName:wy,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{axis:s}=t;let o=[];return o=null==s?r.shape.map((i,a)=>a):"number"==typeof s?[s]:s,{x:()=>function jCe(e,n,t){const r=e.shape.length,s=r-t.length,o=Dn(t,r);let i=e;null!=o&&(i=Ct(e,o));const a=i.shape.slice(),u=a.splice(r-t.length,t.length).reduce((h,f)=>h*f,1);a.push(u);let d=function HCe(e,n,t){const r=e.shape.slice();r[t]=1;const s=O(n,r),o=nv(e,t,!0,!1),i=nv(e,t,!0,!0),a=M(o,i);return M(s,a)}(i.reshape(a),n,s);if(d=d.reshape(i.shape),null!=o){const h=Ql(o);d=Ct(d,h)}return d}(r,e,o)}}},{kernelName:mf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,on(Kt(t)))}}},{kernelName:yf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n,r=M(Jl(t,6),Bc(t));return{x:()=>M(e,pe(r,"float32"))}}},{kernelName:gf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(e,pe(Bc(t),"float32"))}}},{kernelName:xy,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>O(e,t.shape)}}},{kernelName:Iy,inputsToSave:["images"],gradFunc:(e,n,t)=>{const[r]=n,s={dy:e,images:r};return{images:()=>k.runKernel(eC,s,t)}}},{kernelName:Cy,inputsToSave:["images"],gradFunc:(e,n,t)=>{const[r]=n,s={dy:e,images:r};return{images:()=>k.runKernel(J0,s,t)}}},{kernelName:Sy,gradFunc:(e,n,t)=>{const{dims:r}=t,s=pt(r,e.shape);return{x:()=>Io(e,s)}}},{kernelName:vf,gradFunc:e=>({x:()=>_t(e)})},{kernelName:bf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>on(ke(e,M(Ji(t,1.5),2)))}}},{kernelName:_y,inputsToSave:["condition"],gradFunc:(e,n)=>{const[t]=n;return{condition:()=>pe(_t(t),"float32"),t:()=>M(e,pe(t,e.dtype)),e:()=>M(e,pe(iv(t),e.dtype))}}},{kernelName:wf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>{const r=fs(t,Re(0)),s=Re(gI),o=Re(yI),i=M(e,o),a=M(M(e,s),Rs(pe(t,"float32")));return zr(r,i,a)}}}},{kernelName:Sf,outputsToSave:[!0],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(e,M(t,Ce(Re(1),t)))}}},{kernelName:If,gradFunc:e=>({x:()=>_t(e)})},{kernelName:xf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(tv(pe(t,"float32")),e)}}},{kernelName:Cf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(LC(pe(t,"float32")),e)}}},{kernelName:Ey,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{begin:s,size:o}=t,i=r.shape,[a,l]=OC(r,s,o),u=[];for(let c=0;c<e.rank;c++)u.push([a[c],i[c]-a[c]-l[c]]);return{x:()=>ja(e,u)}}},{kernelName:ky,outputsToSave:[!0],gradFunc:(e,n,t)=>{const[r]=n,{dim:s}=t,i=M(e,r);return{logits:()=>Ce(i,M(De(i,[s],!0),r))}}},{kernelName:_f,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(e,wo(t))}}},VG,VG,BG,BG,{kernelName:Ef,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,M(Nr(pe(t,"float32")),2))}}},{kernelName:Df,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=Re(2);return{a:()=>M(e,M(s,Ce(t,r))),b:()=>M(e,M(s,Ce(r,t)))}}},{kernelName:uC,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(e,M(pe(t,"float32"),2))}}},{kernelName:Rf,gradFunc:e=>({x:()=>_t(e)})},{kernelName:Nf,inputsToSave:["a","b"],gradFunc:(e,n)=>{const[t,r]=n,s=et(t.shape,r.shape);return{a:()=>{let a=e;const l=er(t.shape,s);return l.length>0&&(a=De(a,l)),O(a,t.shape)},b:()=>{let a=e;const l=er(r.shape,s);return l.length>0&&(a=De(a,l)),O(on(a),r.shape)}}}},{kernelName:Dy,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,s=r.shape.slice(),{axis:o}=t;pt(o,r.shape).forEach(u=>{s[u]=1});const a=O(e,s),l=M(a,Ms(r.shape,"float32"));return{x:()=>l}}},{kernelName:Tf,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>ke(e,Kt(tv(t)))}}},{kernelName:kf,outputsToSave:[!0],gradFunc:(e,n)=>{const[t]=n;return{x:()=>M(Ce(Re(1),Kt(t)),e)}}},{kernelName:Af,inputsToSave:["x"],gradFunc:(e,n,t)=>{const[r]=n,{reps:s}=t;return{x:()=>{let i=_t(r);if(1===r.rank)for(let a=0;a<s[0];++a)i=ne(i,Et(e,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)i=ne(i,Et(e,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=ne(i,Et(e,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=ne(i,Et(e,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return i}}}},{kernelName:Sc,gradFunc:(e,n,t)=>{const r=t,{perm:s}=r,o=Ql(s);return{x:()=>Ct(e,o)}}},{kernelName:Ry,gradFunc:(e,n,t)=>{const r=t,{axis:s}=r;return{value:()=>ps(e,s)}}},{kernelName:My,inputsToSave:["segmentIds"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>function SIe(e,n){const t=ea(n,_t(n)),r=qf(e,t);let s=Ha(n,Re(0,"int32"));const o=r.rank-s.rank;for(let a=0;a<o;++a)s=jn(s,a+1);s=mi(s,Ms(r.shape,"bool"));const i=_t(r);return zr(s,r,i)}(e,t)}}},{kernelName:Oy,gradFunc:e=>({x:()=>_t(e)})}];for(const e of EIe)j4(e);X().prototype.abs=function(){return this.throwIfDisposed(),Jn(this)},X().prototype.acos=function(){return this.throwIfDisposed(),zk(this)},X().prototype.acosh=function(){return this.throwIfDisposed(),Uk(this)},X().prototype.add=function(e){return this.throwIfDisposed(),ne(this,e)},X().prototype.all=function(e,n){return this.throwIfDisposed(),FC(this,e,n)},X().prototype.any=function(e,n){return this.throwIfDisposed(),Xy(this,e,n)},X().prototype.argMax=function(e){return this.throwIfDisposed(),Kl(this,e)},X().prototype.argMin=function(e){return this.throwIfDisposed(),Wk(this,e)},X().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),O(this,[])},X().prototype.asType=function(e){return this.throwIfDisposed(),pe(this,e)},X().prototype.as1D=function(){return this.throwIfDisposed(),O(this,[this.size])},X().prototype.as2D=function(e,n){return this.throwIfDisposed(),O(this,[e,n])},X().prototype.as3D=function(e,n,t){return this.throwIfDisposed(),O(this,[e,n,t])},X().prototype.as4D=function(e,n,t,r){return this.throwIfDisposed(),O(this,[e,n,t,r])},X().prototype.as5D=function(e,n,t,r,s){return this.throwIfDisposed(),O(this,[e,n,t,r,s])},X().prototype.asin=function(){return this.throwIfDisposed(),Hk(this)},X().prototype.asinh=function(){return this.throwIfDisposed(),jk(this)},X().prototype.atan=function(){return this.throwIfDisposed(),Gk(this)},X().prototype.atan2=function(e){return this.throwIfDisposed(),qk(this,e)},X().prototype.atanh=function(){return this.throwIfDisposed(),Kk(this)},X().prototype.avgPool=function(e,n,t,r){return this.throwIfDisposed(),Jy(this,e,n,t,r)},X().prototype.batchToSpaceND=function(e,n){return this.throwIfDisposed(),ev(this,e,n)},X().prototype.batchNorm=function(e,n,t,r,s){return this.throwIfDisposed(),zf(this,e,n,t,r,s)},X().prototype.broadcastTo=function(e){return this.throwIfDisposed(),$c(this,e)},X().prototype.cast=function(e){return this.throwIfDisposed(),pe(this,e)},X().prototype.ceil=function(){return this.throwIfDisposed(),nA(this)},X().prototype.clipByValue=function(e,n){return this.throwIfDisposed(),As(this,e,n)},X().prototype.concat=function(e,n){return this.throwIfDisposed(),e instanceof St&&(e=[e]),Un([this,...e],n)},X().prototype.conv1d=function(e,n,t,r,s,o){return this.throwIfDisposed(),$C(this,e,n,t,r,s,o)},X().prototype.conv2dTranspose=function(e,n,t,r,s){return this.throwIfDisposed(),PC(this,e,n,t,r,s)},X().prototype.conv2d=function(e,n,t,r,s,o){return this.throwIfDisposed(),Wa(this,e,n,t,r,s,o)},X().prototype.cos=function(){return this.throwIfDisposed(),tv(this)},X().prototype.cosh=function(){return this.throwIfDisposed(),LC(this)},X().prototype.cumprod=function(e,n,t){return this.throwIfDisposed(),nv(this,e,n,t)},X().prototype.cumsum=function(e,n,t){return this.throwIfDisposed(),VC(this,e,n,t)},X().prototype.depthToSpace=function(e,n){return this.throwIfDisposed(),cA(this,e,n)},X().prototype.depthwiseConv2d=function(e,n,t,r,s,o){return this.throwIfDisposed(),Uf(this,e,n,t,r,s,o)},X().prototype.dilation2d=function(e,n,t,r,s){return this.throwIfDisposed(),dA(this,e,n,t,r,s)},X().prototype.divNoNan=function(e){return this.throwIfDisposed(),hA(this,e)},X().prototype.div=function(e){return this.throwIfDisposed(),ke(this,e)},X().prototype.dot=function(e){return this.throwIfDisposed(),fA(this,e)},X().prototype.elu=function(){return this.throwIfDisposed(),Wf(this)},X().prototype.equal=function(e){return this.throwIfDisposed(),Xs(this,e)},X().prototype.erf=function(){return this.throwIfDisposed(),zC(this)},X().prototype.euclideanNorm=function(e,n){return this.throwIfDisposed(),mA(this,e,n)},X().prototype.exp=function(){return this.throwIfDisposed(),Rs(this)},X().prototype.expandDims=function(e){return this.throwIfDisposed(),jn(this,e)},X().prototype.expm1=function(){return this.throwIfDisposed(),gA(this)},X().prototype.fft=function(){return this.throwIfDisposed(),pv(this)},X().prototype.flatten=function(){return this.throwIfDisposed(),O(this,[this.size])},X().prototype.floor=function(){return this.throwIfDisposed(),Gf(this)},X().prototype.floorDiv=function(e){return this.throwIfDisposed(),TC(this,e)},X().prototype.gather=function(e,n,t){return this.throwIfDisposed(),qf(this,e,n,t)},X().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ha(this,e)},X().prototype.greater=function(e){return this.throwIfDisposed(),fs(this,e)},X().prototype.ifft=function(){return this.throwIfDisposed(),Zf(this)},X().prototype.irfft=function(){return this.throwIfDisposed(),nI(this)},X().prototype.isFinite=function(){return this.throwIfDisposed(),yA(this)},X().prototype.isInf=function(){return this.throwIfDisposed(),vA(this)},X().prototype.isNaN=function(){return this.throwIfDisposed(),bA(this)},X().prototype.leakyRelu=function(e){return this.throwIfDisposed(),rv(this,e)},X().prototype.lessEqual=function(e){return this.throwIfDisposed(),Jl(this,e)},X().prototype.less=function(e){return this.throwIfDisposed(),Kf(this,e)},X().prototype.localResponseNormalization=function(e,n,t,r){return this.throwIfDisposed(),wA(this,e,n,t,r)},X().prototype.logSigmoid=function(){return this.throwIfDisposed(),xA(this)},X().prototype.logSoftmax=function(e){return this.throwIfDisposed(),WC(this,e)},X().prototype.logSumExp=function(e,n){return this.throwIfDisposed(),ov(this,e,n)},X().prototype.log=function(){return this.throwIfDisposed(),Ys(this)},X().prototype.log1p=function(){return this.throwIfDisposed(),sv(this)},X().prototype.logicalAnd=function(e){return this.throwIfDisposed(),mi(this,e)},X().prototype.logicalNot=function(){return this.throwIfDisposed(),iv(this)},X().prototype.logicalOr=function(e){return this.throwIfDisposed(),HC(this,e)},X().prototype.logicalXor=function(e){return this.throwIfDisposed(),CA(this,e)},X().prototype.matMul=function(e,n,t){return this.throwIfDisposed(),at(this,e,n,t)},X().prototype.maxPool=function(e,n,t,r){return this.throwIfDisposed(),av(this,e,n,t,r)},X().prototype.max=function(e,n){return this.throwIfDisposed(),xo(this,e,n)},X().prototype.maximum=function(e){return this.throwIfDisposed(),ea(this,e)},X().prototype.mean=function(e,n){return this.throwIfDisposed(),Nn(this,e,n)},X().prototype.min=function(e,n){return this.throwIfDisposed(),Hf(this,e,n)},X().prototype.minimum=function(e){return this.throwIfDisposed(),eu(this,e)},X().prototype.mirrorPad=function(e,n){return this.throwIfDisposed(),SA(this,e,n)},X().prototype.mod=function(e){return this.throwIfDisposed(),_A(this,e)},X().prototype.mul=function(e){return this.throwIfDisposed(),M(this,e)},X().prototype.neg=function(){return this.throwIfDisposed(),on(this)},X().prototype.norm=function(e,n,t){return this.throwIfDisposed(),jf(this,e,n,t)},X().prototype.notEqual=function(e){return this.throwIfDisposed(),Vc(this,e)},X().prototype.oneHot=function(e,n=1,t=0){return this.throwIfDisposed(),Mc(this,e,n,t)},X().prototype.onesLike=function(){return this.throwIfDisposed(),Zs(this)},X().prototype.pad=function(e,n){return this.throwIfDisposed(),ja(this,e,n)},X().prototype.pool=function(e,n,t,r,s,o){return this.throwIfDisposed(),DA(this,e,n,t,r,s,o)},X().prototype.pow=function(e){return this.throwIfDisposed(),Ji(this,e)},X().prototype.prelu=function(e){return this.throwIfDisposed(),cv(this,e)},X().prototype.prod=function(e,n){return this.throwIfDisposed(),NA(this,e,n)},X().prototype.reciprocal=function(){return this.throwIfDisposed(),AA(this)},X().prototype.relu=function(){return this.throwIfDisposed(),gi(this)},X().prototype.relu6=function(){return this.throwIfDisposed(),KC(this)},X().prototype.reshapeAs=function(e){return this.throwIfDisposed(),O(this,e.shape)},X().prototype.reshape=function(e){return this.throwIfDisposed(),O(this,e)},X().prototype.resizeBilinear=function(e,n,t){return this.throwIfDisposed(),Jj(this,e,n,t)},X().prototype.resizeNearestNeighbor=function(e,n,t){return this.throwIfDisposed(),eG(this,e,n,t)},X().prototype.reverse=function(e){return this.throwIfDisposed(),Io(this,e)},X().prototype.rfft=function(){return this.throwIfDisposed(),mv(this)},X().prototype.round=function(){return this.throwIfDisposed(),XC(this)},X().prototype.rsqrt=function(){return this.throwIfDisposed(),YC(this)},X().prototype.selu=function(){return this.throwIfDisposed(),ZC(this)},X().prototype.separableConv2d=function(e,n,t,r,s,o){return this.throwIfDisposed(),QC(this,e,n,t,r,s,o)},X().prototype.sigmoid=function(){return this.throwIfDisposed(),wo(this)},X().prototype.sign=function(){return this.throwIfDisposed(),MA(this)},X().prototype.sin=function(){return this.throwIfDisposed(),JC(this)},X().prototype.sinh=function(){return this.throwIfDisposed(),eI(this)},X().prototype.slice=function(e,n){return this.throwIfDisposed(),Et(this,e,n)},X().prototype.softmax=function(e){return this.throwIfDisposed(),fv(this,e)},X().prototype.softplus=function(){return this.throwIfDisposed(),Lc(this)},X().prototype.spaceToBatchND=function(e,n){return this.throwIfDisposed(),uv(this,e,n)},X().prototype.split=function(e,n){return this.throwIfDisposed(),Os(this,e,n)},X().prototype.sqrt=function(){return this.throwIfDisposed(),Nr(this)},X().prototype.square=function(){return this.throwIfDisposed(),Kt(this)},X().prototype.squaredDifference=function(e){return this.throwIfDisposed(),rI(this,e)},X().prototype.squeeze=function(e){return this.throwIfDisposed(),Qs(this,e)},X().prototype.stack=function(e,n){this.throwIfDisposed();const t=e instanceof St?[this,e]:[this,...e];return ps(t,n)},X().prototype.step=function(e){return this.throwIfDisposed(),Bc(this,e)},X().prototype.stridedSlice=function(e,n,t,r,s,o,i,a){return this.throwIfDisposed(),OA(this,e,n,t,r,s,o,i,a)},X().prototype.sub=function(e){return this.throwIfDisposed(),Ce(this,e)},X().prototype.sum=function(e,n){return this.throwIfDisposed(),De(this,e,n)},X().prototype.tan=function(){return this.throwIfDisposed(),FA(this)},X().prototype.tanh=function(){return this.throwIfDisposed(),Zl(this)},X().prototype.tile=function(e){return this.throwIfDisposed(),Co(this,e)},X().prototype.toBool=function(){return this.throwIfDisposed(),pe(this,"bool")},X().prototype.toFloat=function(){return this.throwIfDisposed(),pe(this,"float32")},X().prototype.toInt=function(){return this.throwIfDisposed(),pe(this,"int32")},X().prototype.topk=function(e,n){return this.throwIfDisposed(),$A(this,e,n)},X().prototype.transpose=function(e){return this.throwIfDisposed(),Ct(this,e)},X().prototype.unique=function(e){return this.throwIfDisposed(),PA(this,e)},X().prototype.unsortedSegmentSum=function(e,n){return this.throwIfDisposed(),oI(this,e,n)},X().prototype.unstack=function(e){return this.throwIfDisposed(),So(this,e)},X().prototype.where=function(e,n){return this.throwIfDisposed(),zr(e,this,n)},X().prototype.zerosLike=function(){return this.throwIfDisposed(),_t(this)};class ra extends Error{constructor(n){super(n),Object.setPrototypeOf(this,ra.prototype)}}class Ho extends Error{constructor(n){super(n),Object.setPrototypeOf(this,Ho.prototype)}}class $ extends Error{constructor(n){super(n),Object.setPrototypeOf(this,$.prototype)}}class rt extends Error{constructor(n){super(n),Object.setPrototypeOf(this,rt.prototype)}}class wR extends Error{constructor(n){super(n),Object.setPrototypeOf(this,wR.prototype)}}Error;class UG{constructor(n){this.maxEntries=n||100,this.cache=new Map}get(n){let t;return this.cache.has(n)&&(t=this.cache.get(n),this.cache.delete(n),this.cache.set(n,t)),t}put(n,t){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(n,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(n){if(n<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${n}.`);if(this.maxEntries>n)for(let t=0;t<this.maxEntries-n;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=n}}function Uc(e,n){if(Array.isArray(e)){let t=[];for(let r=0;r<n;r++)t=t.concat(e);return t}{const t=new Array(n);return t.fill(e),t}}function _o(e,n){if(!e)throw new wR(n)}function WG(e,n){let t=0;for(const r of e)r===n&&t++;return t}function $s(e){return 1===e.length?e[0]:e}function zt(e){return Array.isArray(e)?e:[e]}function Ya(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Wc(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(n,t)=>t.toUpperCase())}let jo={};function xR(e){if(null==e)return null;const n={};return n.className=e.getClassName(),n.config=e.getConfig(),n}function CR(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(n=>CR(n));else{const n=Object.keys(e);for(const t of n){const r=e[t];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?CR(r):e[t]=r.value)}}}function bv(e,n={},t={},r="object",s=!1){if("string"==typeof e){let i;if(e in t)i=t[e];else if(e in jo)i=jo[e];else if(i=n[e],null==i)throw new $(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const o=e;if(null==o.className||null==o.config)throw new $(`${r}: Improper config format: ${JSON.stringify(o)}.\n'className' and 'config' must set.`);const i=o.className;let a,l;if(i in t?[a,l]=t[i]:i in jo?[a,l]=jo.className:i in n&&([a,l]=n[i]),null==a)throw new $(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const f of Object.keys(jo))u[f]=jo[f];for(const f of Object.keys(t))u[f]=t[f];o.config.customObjects=u;const d=Object.assign({},jo);for(const f of Object.keys(t))jo[f]=t[f];CR(o.config);const h=l(a,o.config,t,s);return jo=Object.assign({},d),h}{const u=Object.assign({},jo);for(const d of Object.keys(t))jo[d]=t[d];const c=new a(o.config);return jo=Object.assign({},u),c}}}function vI(e,n){return-1*function DIe(e,n){return e<n?-1:e>n?1:0}(e,n)}function ru(e){if(null==e)return e;const n=[];for(const t of e)-1===n.indexOf(t)&&n.push(t);return n}function NIe(e){if(null==e)throw new $(`Invalid value in obj: ${JSON.stringify(e)}`);for(const n in e)if(e.hasOwnProperty(n))return!1;return!0}function Hc(e,n,t){if(null!=t&&e.indexOf(t)<0)throw new $(`${t} is not a valid ${n}.  Valid values are ${e} or null/undefined.`)}function IR(e,n,t=0,r=1/0){return _o(t>=0),_o(r>=t),Array.isArray(e)&&e.length>=t&&e.length<=r&&e.every(s=>typeof s===n)}function Ar(e,n){Array.isArray(e)?(S(e.length>0,()=>`${n} is unexpectedly an empty array.`),e.forEach((t,r)=>Ar(t,`element ${r+1} of ${n}`))):S(Number.isInteger(e)&&e>0,()=>`Expected ${n} to be a positive integer, but got ${HG(e)}.`)}function HG(e){return null===e?"null":Array.isArray(e)?"["+e.map(n=>HG(n)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function jG(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let kIe=0;function GG(){return kIe++}const bI={};function wI(e=""){return e in bI||(bI[e]=0),bI[e]+=1,e+bI[e].toString()}const AIe=["channelsFirst","channelsLast"],RIe=["nearest","bilinear"],MIe=["valid","same","causal"],OIe=["max","avg"],FIe=["sum","mul","concat","ave"],Jf=new Map;function Gn(e){Hc(AIe,"DataFormat",e)}function Eo(e){Hc(MIe,"PaddingMode",e)}function qG(e){Hc(OIe,"PoolMode",e)}const wv=[];function jc(e,n){wv.push(e);try{const t=n();return wv.pop(),t}catch(t){throw wv.pop(),t}}function XG(e){if(!ZG(e))throw new Error("Not a valid tensor name: '"+e+"'");return function PIe(){return 0===wv.length?"":wv.join("/")+"/"}()+e}function YG(e){if(!ZG(e))throw new Error("Not a valid tensor name: '"+e+"'");Jf.has(e)||Jf.set(e,0);const n=Jf.get(e);if(Jf.set(e,Jf.get(e)+1),n>0){const t=`${e}_${n}`;return Jf.set(t,1),t}return e}const LIe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function ZG(e){return!!e.match(LIe)}function VIe(e){return e===parseInt(e.toString(),10)}function su(e,n,t){null==n&&(n=0),null==t&&(t=e.length);let r=1;for(let s=n;s<t;++s)r*=e[s];return r}function ep(e){if(0===e.length)return Number.NaN;let n=Number.POSITIVE_INFINITY;for(let t=0;t<e.length;t++){const r=e[t];r<n&&(n=r)}return n}function ou(e){if(0===e.length)return Number.NaN;let n=Number.NEGATIVE_INFINITY;for(let t=0;t<e.length;t++){const r=e[t];r>n&&(n=r)}return n}function yi(e,n){if(n<e)throw new $(`end (${n}) < begin (${e}) is forbidden.`);const t=[];for(let r=e;r<n;++r)t.push(r);return t}let xI;function cr(){return null==xI&&(xI=EC().epsilon()),xI}function sa(e,n){return pe(e,n)}function xv(e,n=-1){const t=e.shape.slice();return n<0&&(n=t.length+n+1),t.splice(n,0,1),O(e,t)}function Gc(e,n,t){return L(()=>{switch(e.rank){case 1:return dv(e,n,t);case 2:return tI(e,[n,0],[t,e.shape[1]]);case 3:return hv(e,[n,0,0],[t,e.shape[1],e.shape[2]]);case 4:return Yf(e,[n,0,0,0],[t,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Et(e,[n,0,0,0,0],[t,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Et(e,[n,0,0,0,0,0],[t,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new $(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function SR(e,n,t){return L(()=>{switch(e.rank){case 1:return dv(e,n,t);case 2:return tI(e,[0,n],[e.shape[0],t]);case 3:return hv(e,[0,0,n],[e.shape[0],e.shape[1],t]);case 4:return Yf(e,[0,0,0,n],[e.shape[0],e.shape[1],e.shape[2],t]);default:throw new $(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function CI(e,n,t,r){return L(()=>{switch(e.rank){case 1:return dv(e,n,t);case 2:switch(r){case 1:return Gc(e,n,t);case 2:return SR(e,n,t);default:throw new $(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Gc(e,n,t);case 2:return hv(e,[0,n,0],[e.shape[0],t,e.shape[2]]);case 3:return SR(e,n,t);default:throw new $(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Gc(e,n,t);case 2:return Yf(e,[0,n,0,0],[e.shape[0],t,e.shape[2],e.shape[3]]);case 3:return Yf(e,[0,0,n,0],[e.shape[0],e.shape[1],t,e.shape[3]]);case 4:return SR(e,n,t);default:throw new $(`The axis is not within the rank of the tensor ${r}`)}default:throw new $(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function _R(e,n=-1){let t;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),Un(e,n)}function JG(e,n){switch(e.rank){case 1:return rA([e,n]);case 2:return sA([e,n],0);case 3:return oA([e,n],0);case 4:return iA([e,n],0);default:throw new $(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function ER(e,n){if(Array.isArray(n)||(n=[n]),e.rank!==n.length)throw new $(`The length of input n (${n.length}) does not match the number of dimensions in input x (${e.rank})`);return Co(e,n)}function II(e,n=0,t=1,r,s){return qC(e,n,t,r,s)}function oa(e,n,t,r){if(e.rank<2||n.rank<2)throw new rt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${n.shape}`);if(n.rank>=3&&e.shape.slice(-1)[0]!==n.shape.slice(-2)[0])throw new rt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${n.shape}`);if(2===e.rank&&2===n.rank)return GA({a:e,b:n,transposeA:!1,transposeB:!1,bias:r?DR(e.rank,r,"channelsLast"):null,activation:t});{const s=e.shape.slice(),o=s.pop();e=O(e,[-1,o]);const i=n.shape.slice(),a=i.pop(),l=i.pop(),u=[...i,a],c=Array.from({length:n.rank},(p,m)=>0===m?n.rank-2:m<=n.rank-2?m-1:m);n=O(Ct(n,c),[l,-1]);const d=[...s,...u];return O(GA({a:e,b:n,transposeA:!1,transposeB:!1,bias:r?DR(e.rank,r,"channelsLast"):null,activation:t}),d)}}function eq(e,n,t){return L(()=>(n=Array.isArray(n)?Wr(n,"int32"):pe(n,"int32"),qf(e,n,t)))}function Cv(e){return M(e,e)}function DR(e,n,t){const r=n.shape;if(1!==n.rank&&n.rank!==e)throw new $(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===t)return O(n,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===t)return O(n,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===e){if("channelsFirst"===t)return O(n,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===t)return O(n,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===e){if("channelsFirst"===t)return O(n,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===t)return O(n,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(e<3)return n;throw new $(`Unsupported input rank by biasAdd: ${n.rank}`)}function bi(e,n,t){return L(()=>(null==t&&(t="channelsLast"),Gn(t),ne(e,DR(e.rank,n,t))))}function tq(e,n,t,r){return L(()=>UA(e,n,t,r))}function Iv(e,n,t=!1){return t?e():n()}const KIe=["fanIn","fanOut","fanAvg"],XIe=["normal","uniform","truncatedNormal"];class Go extends kc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}oe((()=>{class e extends Go{apply(t,r){return tr(t,r)}}return e.className="Zeros",e})());let nq=(()=>{class e extends Go{apply(t,r){return Ms(t,r)}}return e.className="Ones",e})();oe(nq),oe((()=>{class e extends Go{constructor(t){if(super(),"object"!=typeof t)throw new $(`Expected argument of type ConstantConfig but got ${t}`);if(void 0===t.value)throw new $(`config must have value set but got ${t}`);this.value=t.value}apply(t,r){return L(()=>M(Re(this.value),Ms(t,r)))}getConfig(){return{value:this.value}}}return e.className="Constant",e})()),oe((()=>{class e extends Go{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,r){return tu(t,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return e.className="RandomUniform",e})()),oe((()=>{class e extends Go{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new rt(`randomNormal does not support dType ${r}.`);return II(t,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return e.className="RandomNormal",e})()),oe((()=>{class e extends Go{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new rt(`truncatedNormal does not support dType ${r}.`);return sI(t,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return e.className="TruncatedNormal",e})()),oe((()=>{class e extends Go{constructor(t){super(),this.gain=null!=t.gain?t.gain:1}apply(t,r){return L(()=>{if(2!==t.length||t[0]!==t[1])throw new $("Identity matrix initializer can only be used for 2D square matrices.");return M(this.gain,UC(t[0]))})}getConfig(){return{gain:this.gain}}}return e.className="Identity",e})());let Do=(()=>{class e extends Go{constructor(t){if(super(),t.scale<0)throw new $(`scale must be a positive float. Got: ${t.scale}`);this.scale=null==t.scale?1:t.scale,this.mode=null==t.mode?"fanIn":t.mode,function YIe(e){Hc(KIe,"FanMode",e)}(this.mode),this.distribution=null==t.distribution?"normal":t.distribution,function ZIe(e){Hc(XIe,"Distribution",e)}(this.distribution),this.seed=t.seed}apply(t,r){const s=function QIe(e,n="channelsLast"){let t,r;if(Gn(n),2===e.length)t=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===n){const s=su(e,2);t=e[1]*s,r=e[0]*s}else if("channelsLast"===n){const s=su(e,0,e.length-2);t=e[e.length-2]*s,r=e[e.length-1]*s}}else{const s=su(e);t=Math.sqrt(s),r=Math.sqrt(s)}return[t,r]}(t),o=s[0],i=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,o):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(o+i)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new rt(`${this.getClassName()} does not support dType ${r}.`);return sI(t,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return tu(t,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return e.className="VarianceScaling",e})();oe(Do);let rq=(()=>{class e extends Do{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Do.className}}return e.className="GlorotUniform",e})();oe(rq);let sq=(()=>{class e extends Do{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Do.className}}return e.className="GlorotNormal",e})();oe(sq);let oq=(()=>{class e extends Do{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Do.className}}return e.className="HeNormal",e})();oe(oq);let iq=(()=>{class e extends Do{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Do.className}}return e.className="HeUniform",e})();oe(iq);let aq=(()=>{class e extends Do{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==t?null:t.seed})}getClassName(){return Do.className}}return e.className="LeCunNormal",e})();oe(aq);let lq=(()=>{class e extends Do{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==t?null:t.seed})}getClassName(){return Do.className}}return e.className="LeCunUniform",e})();oe(lq),oe((()=>{class e extends Go{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==t.gain?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,r){return L(()=>{if(t.length<2)throw new rt("Shape must be at least 2D.");if("int32"!==r&&"float32"!==r&&void 0!==r)throw new TypeError(`Unsupported data type ${r}.`);const s=j(t.slice(0,-1)),o=t[t.length-1],i=s*o;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const l=II([Math.max(o,s),Math.min(o,s)],0,1,r,this.seed),u=ZA.qr(l,!1);let c=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(o,s)*Math.min(o,s)],[Math.min(o,s)+1]);return c=M(c,h.sign()),s<o&&(c=c.transpose()),M(Re(this.gain),c.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return e.className="Orthogonal",e})());const uq={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function cq(e,n={}){return bv(e,bo.getMap().classNameMap,n,"initializer")}function Tn(e){return xR(e)}function yn(e){if("string"==typeof e){const n=e in uq?uq[e]:e;if("GlorotNormal"===n)return new sq;if("GlorotUniform"===n)return new rq;if("HeNormal"===n)return new oq;if("HeUniform"===n)return new iq;if("LeCunNormal"===n)return new aq;if("LeCunUniform"===n)return new lq;{const t={};return t.className=n,t.config={},cq(t)}}return e instanceof Go?e:cq(e)}function NR(e){return Array.isArray(e)&&Array.isArray(e[0])}function SI(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Ge(e){let n;if(Array.isArray(e)){if(1!==e.length)throw new $(`Expected Tensor length to be 1; got ${e.length}`);n=e[0]}else n=e;return n}function Ot(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new $(`Expected exactly 1 Shape; got ${e.length}`)}return e}function _I(e){let n=0;for(const t of e)n+=0===t.shape.length?1:t.shape.reduce((r,s)=>r*s);return n}const dq="Variable";class ia{constructor(n,t="float32",r=dq,s=!0,o=null){this.dtype=t??"float32",this.shape=n.shape,this.id=GG(),this.originalName=XG(r=r??dq),this.name=YG(this.originalName),this.trainable_=s,this.constraint=o,this.val=LA(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),function JIe(e,n){if(e.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(n.shape))}(this.val,n),this.val.id!==n.id&&(this.val.assign(n),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}}function TR(e){return e.map(n=>n.read())}function kR(e){e.forEach(n=>{n[0].write(n[1])})}class dr{constructor(n){this.dtype=n.dtype,this.shape=n.shape,this.ndim=null!=n.shape?n.shape.length:n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}}class aa{constructor(n,t,r,s,o,i,a){this.dtype=n,this.shape=t,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=a,this.id=GG(),null!=i&&(this.originalName=XG(i),this.name=YG(this.originalName)),this.rank=t.length}}let eSe=0;class EI{constructor(n,t){this.callArgs=t,this.id=eSe++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(const r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){const n=[];for(const t of this.inboundLayers)n.push(null!=t?t.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let tSe=0;class yt extends kc{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=tSe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=n.name;if(!t){const r=this.getClassName();t=Ya(r)+"_"+wI(r)}if(this.name=t,this.trainable_=null==n.trainable||n.trainable,null!=n.inputShape||null!=n.batchInputShape){let r;if(null!=n.batchInputShape)r=n.batchInputShape;else if(null!=n.inputShape){let o=null;null!=n.batchSize&&(o=n.batchSize),r=[o].concat(n.inputShape)}this.batchInputShape=r;let s=n.dtype;null==s&&(s=n.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=n.weights?n.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,t){return n.name+"_ib-"+t.toString()}getNodeAtIndex(n,t){if(0===this.inboundNodes.length)throw new Ho(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=n)throw new $(`Asked to get ${t} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return $s(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return $s(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ra(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new ra(`Layer ${this.name} is not connected, no input to return.`);return $s(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new ra(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ra(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return $s(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(t=>t.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){const t=zt(n);if(null==this.inputSpec||0===this.inputSpec.length)return;const r=zt(this.inputSpec);if(t.length!==r.length)throw new $(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${n}`);for(let s=0;s<t.length;s++){const o=t[s],i=r[s];if(null==i)continue;const a=o.rank;if(null!=i.ndim&&a!==i.ndim)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(null!=i.maxNDim&&a>i.maxNDim)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(null!=i.minNDim&&a<i.minNDim)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(null!=i.dtype&&o.dtype!==i.dtype)throw new $(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${o.dtype}.`);if(i.axes){const l=o.shape;for(const u in i.axes){const c=Number(u),d=i.axes[u];if(null!=d&&-1===[d,null].indexOf(c>=0?l[c]:l[l.length+c]))throw new $(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${l}.`)}}if(null!=i.shape)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=o.shape[l];if(null!=u&&null!=c&&u!==c)throw new $(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${o.shape}.`)}}}call(n,t){return n}invokeCallHook(n,t){null!=this._callHook&&this._callHook(n,t)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,t){t=t||{},this.assertNotDisposed();const r=zt(n),s=function sSe(e){let n=!0;for(const t of zt(e))if(!(t instanceof aa)){n=!1;break}return n}(n),o=function oSe(e){let n=!0;for(const t of zt(e))if(t instanceof aa){n=!1;break}return n}(n);if(s===o)throw new $("Arguments to apply() must be all SymbolicTensors or all Tensors");return jc(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);const i=[];for(const a of zt(n))i.push(a.shape);this.build($s(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&o&&(this._refCount=1)}if(this.assertInputCompatibility(n),o){let i=this.call(n,t);this.supportsMasking&&this.setMaskMetadata(n,i);const a=zt(i),l=[];for(let u of a)-1!==r.indexOf(u)&&(u=u.clone()),l.push(u);if(i=$s(l),null!=this.activityRegularizer)throw new rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function nSe(e){e=zt(e);const n=[];for(const t of e)n.push(t.shape);return $s(n)}(n),a=this.computeOutputShape(i);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(n)?i[0]:i),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((c,d)=>new aa(u,c,this,zt(n),t,this.name,d)):new aa(u,a,this,zt(n),t,this.name),this.addInboundNode(n,l,null,null,i,a,t),this._refCount++,null!=this.activityRegularizer)throw new rt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(n){if(null!=this.batchInputShape)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=n[s]&&n[s]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new ra(`The layer ${this.name} has never been called and thus has no defined output shape.`);const n=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);-1===n.indexOf(r)&&n.push(r)}if(1===n.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new ra(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ho(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return _I(this.weights)}build(n){this.built=!0}getWeights(n=!1){return TR(n?this.trainableWeights:this.weights)}setWeights(n){L(()=>{const t=this.weights;if(t.length!==n.length)throw new $(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${t.length} weights. Provided weights: ${n}...`);if(0===t.length)return;const r=[],s=TR(t);for(let o=0;o<s.length;++o){const i=s[o],a=t[o],l=n[o];if(!wt(i.shape,l.shape))throw new $(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}kR(r)})}addWeight(n,t,r,s,o,i,a,l){if(-1!==this._addedWeightNames.indexOf(n))throw new $(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():yn("zeros"));const u=s.apply(t,r),c=new ia(u,r,n,i,a);return u.dispose(),null!=o&&this.addLoss(()=>o.apply(c.read())),null==i&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){null==n||Array.isArray(n)&&0===n.length||(n=zt(n),null!=this._losses&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}setMaskMetadata(n,t,r){if(!this.supportsMasking)return;const s=this.computeMask(n,r),o=zt(t),i=zt(s);if(o.length!==i.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let a=0;a<o.length;a++)o[a].kerasMask=i[a]}addInboundNode(n,t,r,s,o,i,a=null){const l=zt(n);t=zt(t),r=zt(r),s=zt(s),o=SI(o),i=SI(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new EI({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:t,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:i},a);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const n={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(n.batchInputShape=this.batchInputShape),null!=this.dtype&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return 0==--this._refCount&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}}function hq(e,n,t){if((null==n||null!=t&&t>0)&&(n=e.sourceLayer,t=e.nodeIndex),0===n.inboundNodes.length)return[e];{const r=n.inboundNodes[t];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const u=hq(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const c of u)-1===s.indexOf(c)&&s.push(c)}return s}}}let DI=(()=>{class e extends yt{constructor(t){if(super({dtype:t.dtype,name:null!=t.name?t.name:wI("input").toString()}),null==t.batchSize&&(t.batchSize=null),null==t.sparse&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,null!=t.inputShape&&null!=t.batchInputShape)throw new $("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=t.batchInputShape;if(null==r){if(null==t.inputShape)throw new $("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[t.batchSize].concat(t.inputShape)}else if(null!=t.batchSize)throw new $("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=t.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const o=new aa(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new EI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(t,r){throw new $(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return e.className="InputLayer",e})();oe(DI);class iu{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof iu)for(const t in n.id2Value)this.id2Value[t]=n.id2Value[t],t in n.id2Mask&&(this.id2Mask[t]=n.id2Mask[t]);else{if(null==n)return;for(const t of n)this.add(t.key,t.value)}}add(n,t,r){if(null!=this.id2Value[n.id])throw new $(`Duplicate key: name=${n.name}, id=${n.id}`);return this.id2Value[n.id]=function aSe(e,n){if(null==e.dtype||e.dtype===n.dtype)return n;try{return pe(n,e.dtype)}catch{throw new $(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(n,t),this.name2Id[n.name]=n.id,null!=r&&(this.id2Mask[n.id]=r),this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return null!=this.id2Value[n.id]}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof aa){if(null==this.id2Value[n.id])throw new $(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}{const t=this.name2Id[n];if(null==t)throw new $(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[t]}}getMask(n){if(n instanceof aa){if(null==this.id2Value[n.id])throw new $(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}{const t=this.name2Id[n];if(null==t)throw new $(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&ot(this.id2Mask)}}const NI=new UG,TI=new UG;function Sv(e,n,t,r){const s=null!=t&&t.training,o=Array.isArray(e),i=o?e:[e],a=i.map(p=>p.name),l=[],u=n.names();for(const p of a)-1!==u.indexOf(p)?l.push(n.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=a.join(",")+"|"+n.names().sort().join(",");let h,d=NI.get(c);if(null==d){const p=function uSe(e,n){S(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(1===e.length){const s=fq(e[0],n);t=s.sorted,r=s.recipientMap}else{const s=new Set;for(const o of e){const{sorted:i,recipientMap:a}=fq(o,n);for(const l of i)s.has(l.name)||(t.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:t,recipientCounts:cSe(r)}}(i,n);d=p.sorted,h=p.recipientCounts,NI.put(c,d),TI.put(c,h)}h={},s||Object.assign(h,TI.get(c));const f=new iu(n);for(let p=0;p<d.length;++p){if(null!=r){const N=_C().numTensors;N>r.maxNumTensors&&(r.maxNumTensors=N),N<r.minNumTensors&&(r.minNumTensors=N)}const m=d[p],g=m.sourceLayer;if(g instanceof DI)continue;const y=[],v=[],b=[];let w=!1;for(const N of m.inputs){const T=f.getValue(N),P=f.getMask(N);y.push(T),v.push(P),null!=P&&(w=!0),s||(h[N.name]--,0===h[N.name]&&!n.hasKey(N)&&-1===a.indexOf(N.name)&&!T.isDisposed&&!0!==N.sourceLayer.stateful&&b.push(T))}w&&((t=t||{}).mask=v[0]);const x=zt(g.apply(y,t));let I=null;g.supportsMasking&&(I=g.computeMask(y,v));const _=dSe(m),D=Array.isArray(_)?_:[_];for(let N=0;N<D.length;++N){f.hasKey(D[N])||f.add(D[N],x[N],Array.isArray(I)?I[0]:I);const T=a.indexOf(D[N].name);-1!==T&&(l[T]=x[N])}s||ot(b)}return f.disposeMasks(),o?l:l[0]}function cSe(e){const n={};for(const t in e)n[t]=e[t].size;return n}function fq(e,n){const t=new Set,r=[],s={};for(const a of n.names())t.add(a);const o=[],i=[];for(o.push(e);o.length>0;){const a=o[o.length-1];if(t.has(a.name)){o.pop();continue}const l=i[i.length-1]===o.length-1;if(0===a.inputs.length||l)o.pop(),r.push(a),t.add(a.name),l&&i.pop();else{i.push(o.length-1);for(const u of a.inputs)null==s[u.name]&&(s[u.name]=new Set),s[u.name].add(a.name),!t.has(u.name)&&o.push(u)}}return{sorted:r,recipientMap:s}}function dSe(e){let n;if(1===e.sourceLayer.inboundNodes.length)n=e.sourceLayer.output;else{let t=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(const s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){t=r;break}n=e.sourceLayer.getOutputAt(t)}return n}function AR(e,n){return L(()=>Nr(De(M(e,e),n,!0)))}V().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function lSe(e){NI?.setMaxEntries(e),TI?.setMaxEntries(e)});class _v extends kc{getConfig(){return{}}}oe((()=>{class e extends _v{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return L(()=>{const r=AR(t,this.axis),s=As(r,0,this.maxValue);return M(t,ke(s,ne(cr(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return e.className="MaxNorm",e})()),oe((()=>{class e extends _v{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return L(()=>ke(t,ne(cr(),AR(t,this.axis))))}getConfig(){return{axis:this.axis}}}return e.className="UnitNorm",e})()),oe((()=>{class e extends _v{apply(t){return gi(t)}}return e.className="NonNeg",e})()),oe((()=>{class e extends _v{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return L(()=>{const r=AR(t,this.axis),s=ne(M(this.rate,As(r,this.minValue,this.maxValue)),M(1-this.rate,r));return M(t,ke(s,ne(cr(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return e.className="MinMaxNorm",e})());const pq={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function hr(e){return xR(e)}function mq(e,n={}){return bv(e,bo.getMap().classNameMap,n,"constraint")}function fr(e){return null==e?null:"string"==typeof e?mq({className:e in pq?pq[e]:e,config:{}}):e instanceof _v?e:mq(e)}function au(e){return RR.apply(this,arguments)}function RR(){return(RR=F(function*(e){if(null==e)return;const n=[],t=[],r=[];for(const s in e){const o=e[s];if("number"!=typeof o){const i=o;n.push(i.data()),t.push(s),r.push(i)}}if(n.length>0){const s=yield Promise.all(n);for(let o=0;o<s.length;++o)e[t[o]]=s[o][0];ot(r)}})).apply(this,arguments)}function gq(e){if(null!=e)for(const n in e){const t=e[n];"number"!=typeof t&&t.dispose()}}class tp{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,t){return F(function*(){})()}onEpochEnd(n,t){return F(function*(){})()}onBatchBegin(n,t){return F(function*(){})()}onBatchEnd(n,t){return F(function*(){})()}onTrainBegin(n){return F(function*(){})()}onTrainEnd(n){return F(function*(){})()}setModel(n){}}class pSe{constructor(n,t=10){null==n&&(n=[]),this.callbacks=n,this.queueLength=t}append(n){this.callbacks.push(n)}setParams(n){for(const t of this.callbacks)t.setParams(n)}setModel(n){for(const t of this.callbacks)t.setModel(n)}onEpochBegin(n,t){var r=this;return F(function*(){null==t&&(t={});for(const s of r.callbacks)yield s.onEpochBegin(n,t)})()}onEpochEnd(n,t){var r=this;return F(function*(){null==t&&(t={});for(const s of r.callbacks)yield s.onEpochEnd(n,t)})()}onBatchBegin(n,t){var r=this;return F(function*(){null==t&&(t={});for(const s of r.callbacks)yield s.onBatchBegin(n,t)})()}onBatchEnd(n,t){var r=this;return F(function*(){null==t&&(t={});for(const s of r.callbacks)yield s.onBatchEnd(n,t)})()}onTrainBegin(n){var t=this;return F(function*(){null==n&&(n={});for(const r of t.callbacks)yield r.onTrainBegin(n)})()}onTrainEnd(n){var t=this;return F(function*(){null==n&&(n={});for(const r of t.callbacks)yield r.onTrainEnd(n)})()}}class mSe extends tp{constructor(){super()}onEpochBegin(n){var t=this;return F(function*(){t.seen=0,t.totals={}})()}onBatchEnd(n,t){var r=this;return F(function*(){null==t&&(t={});const s=null==t.size?0:t.size;r.seen+=s;for(const o in t){const i=t[o];if("number"==typeof i)r.totals.hasOwnProperty(o)||(r.totals[o]=0),r.totals[o]=r.totals[o]+i*s;else{let a;o in r.totals?a=r.totals[o]:r.totals[o]=0;const l=L(()=>ne(r.totals[o],M(i,s)));r.totals[o]=l,a?.dispose()}}})()}onEpochEnd(n,t){var r=this;return F(function*(){if(null!=t)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?t[s]=r.totals[s]/r.seen:L(()=>{const o=M(ke(1,r.seen),r.totals[s]);t[s]=o,r.totals[s].dispose(),ur(t[s])}))})()}}class gSe extends tp{onTrainBegin(n){var t=this;return F(function*(){t.epoch=[],t.history={}})()}onEpochEnd(n,t){var r=this;return F(function*(){null==t&&(t={}),r.epoch.push(n);for(const s in t)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(t[s])})()}syncData(){var n=this;return F(function*(){const t=[],r=[],s=[];for(const i in n.history){const a=n.history[i];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(t.push(a[l].data()),r.push(i),s.push(l))}const o=yield Promise.all(t);for(let i=0;i<o.length;++i)n.history[r[i]][s[i]].dispose(),n.history[r[i]][s[i]]=o[i][0]})()}}class ySe extends tp{constructor(n,t){if(super(),this.currentEpoch=0,this.nowFunc=n.nowFunc,this.nextFrameFunc=n.nextFrameFunc||QA,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=n.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");l0(this.yieldEvery)&&(this.maybeWait=function TIe(e,n,t){let s,r=null!=t?t():Vr();return(...i)=>{const a=null!=t?t():Vr();return a-r<n||(r=a,s=e(...i)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,t,r){var s=this;return F(function*(){const o=[];null!=s.yield&&(yield au(r),o.push(s.yield(n,t,r))),o.push(s.nextFrameFunc()),yield Promise.all(o)})()}onEpochBegin(n,t){var r=this;return F(function*(){r.currentEpoch=n,null!=r.epochBegin&&(yield au(t),yield r.epochBegin(n,t))})()}onEpochEnd(n,t){var r=this;return F(function*(){const s=[];null!=r.epochEnd&&(yield au(t),s.push(r.epochEnd(n,t))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(n,t){var r=this;return F(function*(){null!=r.batchBegin&&(yield au(t),yield r.batchBegin(n,t))})()}onBatchEnd(n,t){var r=this;return F(function*(){const s=[];null!=r.batchEnd&&(yield au(t),s.push(r.batchEnd(n,t))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):l0(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,n,t)),yield Promise.all(s)})()}onTrainBegin(n){var t=this;return F(function*(){null!=t.trainBegin&&(yield au(n),yield t.trainBegin(n))})()}onTrainEnd(n){var t=this;return F(function*(){null!=t.trainEnd&&(yield au(n),yield t.trainEnd(n))})()}}function yq(e,n){return null==e&&(e={}),e instanceof tp?[e]:Array.isArray(e)&&e[0]instanceof tp?e:zt(e).map(r=>new ySe(r,n))}let vSe=(()=>{class e{constructor(){}static registerCallbackConstructor(t,r){S(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),e.checkForDuplicate(r),null==e.constructors[t]&&(e.constructors[t]=[]),e.constructors[t].push(r)}static checkForDuplicate(t){for(const r in e.constructors)e.constructors[+r].forEach(o=>{if(o===t)throw new $("Duplicate callback constructor.")})}static clear(){e.constructors={}}static createCallbacks(t){const r=[];for(const s in e.constructors){const o=+s;t>=o&&r.push(...e.constructors[o])}return r.map(s=>new s)}}return e.constructors={},e})();function vq(e,n,t,r,s,o,i,a,l){const u=new gSe,c=[new mSe,...vSe.createCallbacks(n)];null!=e&&c.push(...e),c.push(u);const d=new pSe(c);return d.setParams({epochs:t,initialEpoch:r,samples:s,steps:o,batchSize:i,verbose:n,doValidation:a,metrics:l}),{callbackList:d,history:u}}function Za(e,n={},t=!1){return bv(e,bo.getMap().classNameMap,n,"layer",t)}function kI(e,n){return L(()=>{"float32"!==e.dtype&&(e=pe(e,"float32"));const t=De(Cv(e),n,!0),r=Ac(t.shape,cr()),s=Nr(ea(t,r));return ke(e,s)})}function AI(e,n){return L(()=>Nn(Cv(Ce(n,e)),-1))}function MR(e,n){return L(()=>Nn(Jn(Ce(n,e)),-1))}function OR(e,n){return L(()=>{const t=Ce(e,n),r=As(Jn(e),cr(),Number.MAX_VALUE),s=Jn(ke(t,r));return M(100,Nn(s,-1))})}function Ev(e,n,t=!1){return L(()=>{if(t)n=fv(n);else{const r=De(n,n.shape.length-1,!0);n=ke(n,r)}return n=As(n,cr(),1-cr()),on(De(M(pe(e,"float32"),Ys(n)),n.shape.length-1))})}function RI(e,n,t=!1){return L(()=>{const r=pe(Gf(function WIe(e){const n=[su(e.shape)];return O(e,n)}(e)),"int32"),s=(n=As(n,cr(),1-cr())).shape;return Ev(O(Mc(r,s[s.length-1]),s),n,t)})}function MI(e,n){return L(()=>{let t;return t=As(n,cr(),1-cr()),t=Ys(ke(t,Ce(1,t))),Nn(function SSe(e,n){if(!wt(e.shape,n.shape))throw new $(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(n.shape)}`);return L(()=>{const t=gi(n),r=on(Jn(n));return ne(Ce(t,M(n,e)),sv(Rs(r)))})}(e,t),-1)})}function bq(e,n){return L(()=>{const t=kI(e,-1),r=kI(n,-1),s=M(t,r);return on(De(s,-1))})}const OI={meanSquaredError:AI,meanAbsoluteError:MR,meanAbsolutePercentageError:OR,meanSquaredLogarithmicError:function bSe(e,n){return L(()=>{const t=As(n,cr(),Number.MAX_VALUE),r=Ys(ne(1,t)),s=As(e,cr(),Number.MAX_VALUE),o=Ys(ne(1,s));return Nn(Cv(Ce(r,o)),-1)})},squaredHinge:function wSe(e,n){return L(()=>{const t=ea(0,Ce(1,M(e,n)));return Nn(Cv(t),-1)})},hinge:function xSe(e,n){return L(()=>{const t=ea(0,Ce(1,M(e,n)));return Nn(t,-1)})},categoricalHinge:function CSe(e,n){return L(()=>{const t=De(M(e,n),-1),r=xo(M(Ce(1,e),n),-1);return ea(0,ne(1,Ce(r,t)))})},logcosh:function ISe(e,n){return L(()=>{const t=Math.log(2),r=Ce(n,e),s=Ce(ne(r,Lc(M(-2,r))),t);return Nn(s,-1)})},categoricalCrossentropy:Ev,sparseCategoricalCrossentropy:RI,binaryCrossentropy:MI,kullbackLeiblerDivergence:function _Se(e,n){return L(()=>{const t=As(e,cr(),1),r=As(n,cr(),1);return De(M(e,Ys(ke(t,r))),-1)})},poisson:function ESe(e,n){return L(()=>{const t=Ys(ne(cr(),n));return Nn(Ce(n,M(e,t)),-1)})},cosineProximity:bq};function FR(e){if("string"==typeof e){if(e in OI)return OI[e];let n=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new $(n)}return e}function wq(e,n){return L(()=>{const t=M(.5,Zs(n)),r=sa(fs(n,t),e.dtype);return Nn(Xs(e,r),-1)})}function xq(e,n){return L(()=>sa(Xs(Kl(e,-1),Kl(n,-1)),"float32"))}function kSe(e,n){return MI(e,n)}function ASe(e,n){return e.rank===n.rank&&(e=Qs(e,[e.rank-1])),(n=Kl(n,-1)).dtype!==e.dtype&&(n=pe(n,e.dtype)),pe(Xs(e,n),"float32")}const Iq=Ev,Sq=RI,FI={binaryAccuracy:wq,categoricalAccuracy:xq,precision:function TSe(e,n){return L(()=>{const t=function Cq(e,n){return L(()=>pe(De(mi(Xs(e,1),Xs(n,1))),"float32"))}(e,n),r=function NSe(e,n){return L(()=>pe(De(mi(Xs(e,0),Xs(n,1))),"float32"))}(e,n),s=ne(t,r);return pe(zr(fs(s,0),ke(t,s),0),"float32")})},categoricalCrossentropy:Iq,sparseCategoricalCrossentropy:Sq,mse:AI,MSE:AI,mae:MR,MAE:MR,mape:OR,MAPE:OR,cosine:bq};function VSe(e){if("string"==typeof e&&e in FI)return FI[e];if("string"!=typeof e&&null!=e)return e;throw new $(`Unknown metric ${e}`)}function $I(e){if(_o(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let n;for(const t of Object.keys(OI))if(OI[t]===e){n=t;break}if(void 0!==n)return n;for(const t of Object.keys(FI))if(FI[t]===e){n=t;break}return void 0!==n?n:e.name}}function Eq(e,n,t=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!$R(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function $R(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const n=Object.keys(e);for(const t of n)if("string"!=typeof t||!$R(e[t]))return!1;return!0}if(Array.isArray(e)){for(const n of e)if(!$R(n))return!1;return!0}return!1}{const n=typeof e;return"string"===n||"number"===n||"boolean"===n}}function PI(e,n,t=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,n[s]),r+=" ".repeat(n[s]-r.length);t(r)}function HSe(e,n,t){let r,s;try{s=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}PI([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],n,t)}function jSe(e,n,t,r){let s,o;try{o=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{o="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}const i=[];for(const d of e.inboundNodes)if(!(null!=t&&t.length>0&&-1===t.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)i.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=e.name,l=e.getClassName(),u=0===i.length?"":i[0];PI([`${a} (${l})`,o,s,e.countParams().toString(),u],n,r);for(let d=1;d<i.length;++d)PI(["","","","",i[d]],n,r)}function Dq(e,n,t){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===n&&"string"==typeof t}function PR(e,n){if(null===e)return null;if("string"==typeof e)return Wc(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const t=[],r=e.length;for(let s=0;s<r;++s){const o=e[s];Dq(n,s,o)?t.push(o):t.push(PR(o,n))}return t}{const t={};for(const r of Object.keys(e)){const s=e[r];if("name"===r&&"string"==typeof s)t[r]=s;else{const o=Wc(r);t[o]=PR(s,o)}}return t}}function LR(e,n){if(null==e)return null;if("string"==typeof e)return Ya(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const t=[],r=e.length;for(let s=0;s<r;++s){const o=e[s];Dq(n,s,o)?t.push(o):t.push(LR(o,n))}return t}{const t={};for(const r of Object.keys(e)){const s=e[r];t[Ya(r)]="name"!==r&&"className"!==r||"string"!=typeof s?LR(s,r):s}return t}}class wi extends yt{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,null==this.name){const v=this.getClassName().toLowerCase();this.name=wI(v)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(n.inputs)?n.inputs.slice():[n.inputs],this.outputs=Array.isArray(n.outputs)?n.outputs.slice():[n.outputs],ru(this.inputs).length!==this.inputs.length)throw new $(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(v=>v.name)}`);ru(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(v=>v.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const v of this.outputs){const w=v.nodeIndex,x=v.tensorIndex;this.outputLayers.push(v.sourceLayer),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(x)}for(const v of this.inputs){const b=v.sourceLayer,w=v.nodeIndex,x=v.tensorIndex;_o(0===w,"input layer has >1 nodes"),_o(0===x,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(x)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let v=0;v<this.inputLayers.length;v++){const b=this.inputLayers[v];if(!(b instanceof DI))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${v} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const v of this.outputLayers)this.outputNames.push(v.name);this.internalInputShapes=this.inputs.map(v=>v.shape),this.internalOutputShapes=this.outputs.map(v=>v.shape);const t={},r={},s={},o={},i={},a=[],l=(v,b,w,x,I,_)=>{(null==x||null==I||null==_)&&(x=v.sourceLayer,I=v.nodeIndex,_=v.tensorIndex);const D=x.inboundNodes[I];if(-1!==w.indexOf(D))throw new Ho(`The tensor ${v.name} at layer "${x.name}" is part of a cycle.`);if(-1!==b.indexOf(D))return;this.containerNodes.add(wi.nodeKey(x,I)),x.id in i||(i[x.id]=Object.keys(i).length),-1===w.indexOf(D)&&w.push(D);const N=D.inboundLayers.length;for(let T=0;T<N;T++)l(D.inputTensors[T],b,w,D.inboundLayers[T],D.nodeIndices[T],D.tensorIndices[T]);for(b.push(D);w.indexOf(D)>=0;)w.splice(w.indexOf(D),1);a.push(D)},u=[],c=[];for(const v of this.outputs)l(v,u,c);const d=a.slice().reverse();for(const v of d){r[v.id]=v,v.id in t||(t[v.id]=0);let b=t[v.id];b=Math.max(b,null==s[v.outboundLayer.id]?0:s[v.outboundLayer.id]),s[v.outboundLayer.id]=b,o[v.outboundLayer.id]=v.outboundLayer,t[v.id]=b;for(let x=0;x<v.inboundLayers.length;x++){const D=v.inboundLayers[x].inboundNodes[v.nodeIndices[x]];t[D.id]=Math.max(b+1,null==t[D.id]?0:t[D.id]),r[D.id]=D}}const h={};for(const v in t){const b=t[v];b in h||(h[b]=[]),h[b].push(r[v])}const f={};for(const v in s){const b=s[v];b in f||(f[b]=[]),f[b].push(o[v])}let p=Object.keys(f).map(v=>parseInt(v,10)).sort(vI);this.layers=[];for(const v of p){const b=f[v];b.sort((w,x)=>{const I=i[w.id],_=i[x.id];return I<_?-1:I>_?1:0});for(const w of b)w instanceof wi&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=f,p=Object.keys(h).map(v=>parseInt(v,10)).sort(vI);const m=this.inputs.slice(),g=[];for(const v of p)for(const b of h[v]){const w=b.outboundLayer;if(null!=w){for(const x of b.inputTensors)if(-1===m.indexOf(x))throw new Ho(`Graph disconnected: cannot obtain value for tensor ${x} at layer "${w.name}". The following previous layers were accessed without issue: ${g}`);for(const x of b.outputTensors)m.push(x);g.push(w.name)}}this.nodesByDepth=h;const y=this.layers.map(v=>v.name);for(const v of y){const b=y.filter(w=>w===v).length;if(1!==b)throw new Ho(`The name "${v}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new EI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(v=>null),outputMasks:this.outputs.map(v=>null),inputShapes:this.inputs.map(v=>v.shape),outputShapes:this.outputs.map(v=>v.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const n={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)n.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)n.numDisposedVariables+=t.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new $("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(const t of this.layers)n=n.concat(t.trainableWeights);return n}get nonTrainableWeights(){const n=[];for(const t of this.layers)n.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,t=!0){const r={};let s=0;const o=(e=>{const n=Object.keys(e);if(0===n.length)return!1;const t=n[0].split("/");return!isNaN(parseInt(t[t.length-1],10))})(n);o&&this.parseWeights(n);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=o?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(null!=r[c])throw new $(`Duplicate weight name: ${c}`);r[c]=u,s++}const i=[];for(const a in n){let l=a;if(null==r[a]){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(null!=r[l])i.push([r[l],n[a]]);else if(t)throw new $(`Provided weight data has no target variable: ${a}`);delete r[l]}if(t){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new $(`${a.length} of ${s} weights are not set: ${a}`)}kR(i)}parseWeights(n){for(const t in Object.keys(n)){const r=t.split("/"),s=["vars","layer_checkpoint_dependencies"],o=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");o!==t&&(n[o]=n[t],delete n[t])}}updatedConfig(){const n=this.getConfig(),t={};return t.className=this.getClassName(),t.config=n,t.kerasVersion="tfjs-layers 4.22.0",t.backend="TensorFlow.js",t}toJSON(n,t=!0){const r=LR(this.updatedConfig());return t?JSON.stringify(r):r}call(n,t){return L(()=>{n=zt(n);const r=new iu;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],n[s]);return Sv(this.outputs,r,t)})}computeMask(n,t){return L(()=>{let r;return n=zt(n),r=null==t?Uc(null,n.length):zt(t),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){const t=SI(n);if(t.length!==this.inputLayers.length)throw new $(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<t.length;a++)r[this.inputLayers[a].name+"_0_0"]=t[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(vI);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(c.id))continue;const d=[];for(let m=0;m<u.inboundLayers.length;m++)d.push(r[`${u.inboundLayers[m].name}_${u.nodeIndices[m]}_${u.tensorIndices[m]}`]);const f=SI(c.computeOutputShape($s(d))),p=c.inboundNodes.indexOf(u);for(let m=0;m<f.length;m++)r[`${c.name}_${p}_${m}`]=f[m]}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++)i.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<i.length;a++){const l=i[a];_o(l in r),o.push(r[l])}return $s(o)}runInternalGraph(n,t){null==t&&(t=Uc(null,n.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[n[l],t[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(vI);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,f=c.outputTensors,p=new Array;for(const m of h)m.id in r&&p.push(r[m.id]);if(p.length===h.length){let g,y,v,b,m={};if(null!=c.callArgs&&(m=c.callArgs),1===p.length){const[w,x]=p[0];null==m.mask&&(m.mask=x),v=zt(d.call(w,m)),b=zt(d.computeMask(w,x)),g=[w],y=[x]}else g=p.map(w=>w[0]),y=p.map(w=>w[1]),null==m.mask&&(m.mask=y),v=zt(d.call(g,m)),b=zt(d.computeMask(g,y));if(d.activityRegularizer)throw new rt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<f.length;++w)r[f[w].id]=[v[w],b[w]]}}}const o=[],i=[],a=[];for(const l of this.outputs){_o(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),o.push(u),i.push(c)}return[o,i,a]}buildNodeConversionMap(n){const t={};let r;for(const s of this.layers){r=s instanceof wi?1:0;for(let o=0;o<s.inboundNodes.length;o++){const i=wi.nodeKey(s,o);this.containerNodes.has(i)&&(t[i]=r,r+=1)}}return t}getLayer(n,t){if(null!=t)return this.findLayer(t);if(null==n)throw new $("Provide either a layer name or layer index");if("number"==typeof n)return this.findLayer(n);for(const r of this.layers)if(r.name===n)return r;throw new $(`No such layer: ${n}`)}findLayer(n){if(this.layers.length<=n)throw new $(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}calculateLosses(){return L(()=>{const n=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const s=wi.nodeKey(t,r);this.containerNodes.has(s)&&n.push(...t.calculateLosses())}return n})}getConfig(){const n={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const a=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],f=wi.nodeKey(i,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],b=h.tensorIndices[g];let x=t[wi.nodeKey(y,h.nodeIndices[g])];null==x&&(x=0),m.push([y.name,x,b,p])}u.push(m)}}}const c={};c.name=i.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}n.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=wi.nodeKey(a,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=t[u];null==c&&(c=0),s.push([a.name,c,this.inputLayersTensorIndices[i]])}n.inputLayers=s;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=wi.nodeKey(a,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(u))continue;let c=t[u];null==c&&(c=0),o.push([a.name,c,this.outputLayersTensorIndices[i]])}return n.outputLayers=o,n}static fromConfig(n,t,r={},s=!1){const o={},i={};function a(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){const v=[];let b;for(const w of y){const x=w[0],I=w[1],_=w[2];if(b=null==w[3]?{}:w[3],!(x in o))return void a(g,y);const D=o[x];if(D.inboundNodes.length<=I)return void a(g,y);v.push(D.inboundNodes[I].outputTensors[_])}v.length>0&&g.apply($s(v),b)}function u(g){const y=g.name,v=Za(g,null!=t.customObjects?t.customObjects:{});v.setFastWeightInitDuringBuild(s),o[y]=v,g.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new $(`Corrupted configuration, expected array for nodeData: ${w}`);a(v,w)})}const c=t.name,d=t.layers;for(const g of d)u(g);for(;!NIe(i);)for(const g of d){const y=o[g.name];if(y.name in i){const v=i[y.name];delete i[y.name];for(const b of v)l(y,b)}}const h=[],f=[],p=t.inputLayers;for(const g of p){const y=g[0],v=g[1],b=g[2];_o(y in o),h.push(o[y].inboundNodes[v].outputTensors[b])}const m=t.outputLayers;for(const g of m){const y=g[0],v=g[1],b=g[2];_o(y in o),f.push(o[y].inboundNodes[v].outputTensors[b])}return new n({inputs:h,outputs:f,name:c})}get stateful(){if(this._stateful)throw new $("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const n of this.layers)if(n.stateful)return!0;return!1}resetStates(){L(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}}function Tq(e,n){return function Nq(e,n,t){const r=n.length;if(null==e||Array.isArray(e)&&0===e.length)return n.map(s=>null);if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&n[0]in e?[e[n[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${t} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const s=[];return n.forEach(o=>{s.push(o in e?e[o]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${n} keys. Provided ${t} not understood: ${JSON.stringify(e)}`)}(e,n,"classWeight")}function kq(e,n,t,r){return BR.apply(this,arguments)}function BR(){return(BR=F(function*(e,n,t,r){if(null!=n||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=t){const s=L(()=>{if(1===e.shape.length)return Zi(e);if(2===e.shape.length){if(e.shape[1]>1)return Kl(e,1);if(1===e.shape[1])return O(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(yield s.data());ot(s);const i=[];return o.forEach(a=>{if(null==t[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(t[a])}),Wr(i,"float32")}return null})).apply(this,arguments)}function qSe(e,n){return M(e,n)}function Aq(e,n){let t,r;t=n.xs,r=n.ys,S(null!=t&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);const o=Rq("input",e.inputNames,t),i=Rq("output",e.outputNames,r),a=o[0].shape[0];S(o.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),S(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${e.inputNames[0]}.`);return{xs:o,ys:i}}function Rq(e,n,t){if(t instanceof St)return[t];if(Array.isArray(t))return S(t.length===n.length,()=>`Received an array of ${t.length} Tensors, but expected ${n.length} to match the ${e} keys ${n}.`),t;{const r=[];for(const s of n){if(null==t[s])throw new $(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(t[s])}return r}}function zR(){return(zR=F(function*(e,n,t){const r=null!=t.batchesPerEpoch;if(S(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=t,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=t.epochs&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),S(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),S(null==t.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=t.validationData;let o,i;if(s)if(Mq(t.validationData))S(null==t.validationBatches||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const g=function XSe(e){if(3===e.length)throw new rt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(t.validationData);o=g.xs,i=g.ys}const a=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const c=yq(t.callbacks,t.yieldEvery),d=null==t.verbose?1:t.verbose,{callbackList:h,history:f}=vq(c,d,t.epochs,null,null,function ZSe(e,n){let t=null;return null!=n.batchesPerEpoch?t=n.batchesPerEpoch:Number.isFinite(e.size)&&(t=e.size),t}(n,t),null,s,u);h.setModel(e),e.history=f,yield h.onTrainBegin(),e.stopTraining_=!1;let p=null==t.initialEpoch?0:t.initialEpoch,m=yield n.iterator();for(;p<t.epochs;){const g={};yield h.onEpochBegin(p);let y=0,v=0;for(r||(m=yield n.iterator());!r||y<t.batchesPerEpoch;){const b=yield m.next();if(r&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=b.value){const{xs:w,ys:x}=Aq(e,b.value),I={};I.batch=v,I.size=w[0].shape[0],yield h.onBatchBegin(v,I);const _=[];if(null!=t.classWeight){const T=Tq(t.classWeight,e.outputNames);for(let P=0;P<T.length;++P)_.push(yield kq(x[P],null,T[P]))}const D=w.concat(x).concat(_),N=a(D);ot(D);for(let T=0;T<l.length;++T){const B=N[T];I[l[T]]=B,ur(B)}yield h.onBatchEnd(v,I),gq(I),v++,y++}if(r?y>=t.batchesPerEpoch:b.done){if(s){let w;w=Mq(t.validationData)?zt(yield e.evaluateDataset(t.validationData,{batches:t.validationBatches})):zt(e.evaluate(o,i,{batchSize:null==t.validationBatchSize?32:t.validationBatchSize,verbose:0}));for(let x=0;x<e.metricsNames.length;++x)g[`val_${e.metricsNames[x]}`]=w[x]}break}if(e.stopTraining_)break}if(yield h.onEpochEnd(p,g),p++,e.stopTraining_)break}return yield h.onTrainEnd(),yield e.history.syncData(),e.history}finally{e.isTraining=!1}})).apply(this,arguments)}function Mq(e){return"function"==typeof e.iterator}function UR(){return(UR=F(function*(e,n,t){const r=null!=(t=t||{}).batches,s=e.testFunction;let o=[];if(t.verbose>0)throw new rt("Verbose mode is not implemented yet.");S(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const i=function QSe(e){return"function"==typeof e.next}(n)?n:yield n.iterator();let a=0,l=0;for(;!r||l<t.batches;){const u=yield i.next();if(o=L(()=>{if(u.value){const{xs:c,ys:d}=Aq(e,u.value),h=c.concat(d),f=L(()=>s(h));if(ot(h),0===l)for(let m=0;m<f.length;++m)o.push(Re(0));const p=h[0].shape[0];for(let m=0;m<f.length;++m){const g=f[m],y=o[m];o[m]=L(()=>ne(o[m],M(p,g))),l>0&&ot(y)}ot(f),a+=p,++l}return o}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<o.length;++u){const c=o[u];o[u]=ke(o[u],a),ot(c)}return $s(o)})).apply(this,arguments)}function WR(e){S(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Dv(e,n,t){return null==e?[null]:Array.isArray(e)?e.map(r=>Gc(r,n,t-n)):Gc(e,n,t-n)}function HR(e,n){return L(()=>null==e?null:Array.isArray(e)?e.map(t=>HR(t,n)):eq(e,"int32"===n.dtype?n:pe(n,"int32")))}function jR(e,n){const t=[];let r=0,s=null;for(;r<e;)s=r+n,s>=e&&(s=e),t.push([r,s]),r=s;return t}function Oq(e){const n=[];e instanceof St&&(e=[e]);for(let t=0;t<e.length;++t){const r=e[t];if(1===r.rank)n.push(xv(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function xi(e,n){if(null==e)return;const t=[];if(n instanceof St)t.push(n.id);else if(Array.isArray(n))n.forEach(s=>t.push(s.id));else if(null!=n)for(const s in n)t.push(n[s].id);const r=[];if(e instanceof St)-1===t.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{-1===t.indexOf(s.id)&&r.push(s)});else if(null!=e)for(const s in e){const o=e[s];-1===t.indexOf(o.id)&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function GR(e){return Array.isArray(e)}function Fq(e){return!function e_e(e){return e instanceof St}(e)&&!GR(e)}function $q(e,n,t,r=!0,s=""){if(null==n||0===n.length){if(null!=e){let i=!1;if(GR(e)&&e.length>0)i=!0;else if(Fq(e)){for(const a in e)if(e.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new $(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return n.map(i=>null);let o;if(Fq(e)){o=[];for(const i of n){if(null==e[i])throw new $(`No data provided for "${i}". Need data for each key in: ${n}`);o.push(e[i])}}else if(GR(e)){if(e.length!==n.length)throw new $(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);o=e}else{if(n.length>1)throw new $(`The model ${s} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);o=[e]}if(o=Oq(o),null!=t)for(let i=0;i<n.length;++i){if(null==t[i])continue;const a=o[i];if(a.shape.length!==t[i].length)throw new $(`Error when checking ${s}: expected ${n[i]} to have ${t[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[i].length;++l){if(0===l&&!r)continue;const c=t[i][l];if(null!=c&&c>=0&&a.shape[l]!==c)throw new $(`${s} expected a batch of elements where each example has shape [${t[i].slice(1,t[i].length)}] (i.e.,tensor shape [*,${t[i].slice(1,t[i].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function Pq(e,n,t,r=!0,s=""){let o;if(Array.isArray(e)){if(e.length!==n.length)throw new $(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${e.length} Tensors(s).`);o=e}else{if(n.length>1)throw new $(`The model expects ${n.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);o=[e]}if(null!=t)for(let i=0;i<n.length;++i){if(null==t[i])continue;const a=o[i];if(a.shape.length!==t[i].length)throw new $(`Error when checking ${s}: expected ${n[i]} to have ${t[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[i].length;++l){if(0===l&&!r)continue;const c=t[i][l];if(null!=c&&c!==a.shape[l])throw new $(`Error when checking ${s}: expected ${n[i]} to have shape ${JSON.stringify(t[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let np=(()=>{class e extends wi{constructor(t){super(t),this.isTraining=!1}summary(t,r,s=console.log){if(!this.built)throw new $("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function zSe(e,n,t,r=console.log){const s=function WSe(e){let n=!0;const t=[],r=[];for(const s in e.nodesByDepth)t.push(e.nodesByDepth[s]);for(const s of t){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){n=!1;break}r.push(...s)}if(n)for(const s of e.layers){let o=!1;for(const i of s.inboundNodes)if(-1!==r.indexOf(i)){if(o){n=!1;break}o=!0}if(!n)break}return n}(e),o=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(n=n||90,t=t||[.32,.61,.89,1]):(n=n||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(n*c))),!s){o.push("Receives inputs"),i=[];for(const c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}r("_".repeat(n)),PI(o,t,r),r("=".repeat(n));const a=e.layers;for(let c=0;c<a.length;++c)s?HSe(a[c],t,r):jSe(a[c],t,i,r),r((c===a.length-1?"=":"_").repeat(n));e.checkTrainableWeightsConsistency();const l=function USe(e){let n;return n=_I(null!=e.collectedTrainableWeights?e.collectedTrainableWeights:e.trainableWeights),n}(e),u=_I(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(n))}(this,t,r,s)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=function BSe(e){const n={Adagrad:()=>zc.adagrad(.01),Adadelta:()=>zc.adadelta(1,.95,cr()),Adam:()=>zc.adam(.001,.9,.999,cr()),Adamax:()=>zc.adamax(.002,.9,.999,cr(),0),RMSProp:()=>zc.rmsprop(.001,.9,0,cr()),SGD:()=>zc.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,e in n)return n[e]();throw new $(`Unknown Optimizer ${e}`)}(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Ba))throw new $("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new $(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);r=t.loss.map(l=>FR(l))}else{const a=FR(t.loss);this.outputs.forEach(l=>{r.push(a)})}else{t.loss=t.loss;for(const a in t.loss)if(-1===this.outputNames.indexOf(a))throw new $(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==t.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(FR(t.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],jc("loss",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[a],a]),this.metricsNames.push(this.outputNames[a]+"_loss"))});const o=function r_e(e,n){if(null==e||Array.isArray(e)&&0===e.length)return n.map(r=>[]);let t;if("string"==typeof e||"function"==typeof e)t=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);t=e}if(Array.isArray(t))return n.map(r=>t);{const r=[];for(const s of n){let o=t.hasOwnProperty(s)?t[s]:[];Array.isArray(o)||(o=[o]),r.push(o)}return r}}(t.metrics,this.outputNames),i=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};jc("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(c=>{let h,f,p;for(const m of c){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const y=this.internalOutputShapes[a];let v;1===y[y.length-1]||this.lossFunctions[a]===MI?-1!==["accuracy","acc"].indexOf(m)?f=wq:-1!==["crossentropy","ce"].indexOf(m)&&(f=kSe):this.lossFunctions[a]===RI?-1!==["accuracy","acc"].indexOf(m)?f=ASe:-1!==["crossentropy","ce"].indexOf(m)&&(f=Sq):-1!==["accuracy","acc"].indexOf(m)?f=xq:-1!==["crossentropy","ce"].indexOf(m)&&(f=Iq),-1!==["accuracy","acc"].indexOf(m)?v="acc":-1!==["crossentropy","ce"].indexOf(m)&&(v="ce"),p=f,h=""+v}else p=VSe(m),h=""+$I(m);let g;jc(h,()=>{g=p}),i(a,h,g)}})(o[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,r,s={}){const o=null==s.batchSize?32:s.batchSize;WR(o);const a=this.standardizeUserDataXY(t,r,!0,o);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),$s(this.testLoop(this.testFunction,l,o,s.verbose,s.steps))}finally{xi(a[0],t),xi(a[1],r)}}evaluateDataset(t,r){var s=this;return F(function*(){return s.makeTestFunction(),function JSe(e,n,t){return UR.apply(this,arguments)}(s,t,r)})()}checkNumSamples(t,r,s,o="steps"){let i;if(null!=s){if(i=null,null!=r)throw new $(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==t)throw new $(`Either the input data should have a defined shape, or ${o} shoud be specified.`);i=Array.isArray(t)?t[0].shape[0]:t.shape[0]}return i}execute(t,r){if(Array.isArray(r)&&0===r.length)throw new $("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),i=this.retrieveSymbolicTensors(s?r:[r]),a=new iu;if(t instanceof St&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new $(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],t[u])}else for(const u of this.inputs){const c=t[u.name];if(null==c)throw new $(`No value is provided for the model's input ${u.name}`);a.add(u,c)}const l=Sv(i,a);return s?l:l[0]}retrieveSymbolicTensors(t){const r=Uc(null,t.length);let s=t.length;for(const o of this.layers){const i=Array.isArray(o.output)?o.output:[o.output],a=i.map(l=>l.name);for(let l=0;l<t.length;++l){const u=a.indexOf(t[l]);if(-1!==u&&(r[l]=i[u],s--),0===s)break}if(0===s)break}if(s>0){const o=[];throw r.forEach((i,a)=>{null==i&&o.push(t[a])}),new $(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return r}predictLoop(t,r=32,s=!1){return L(()=>{const o=this.checkNumSamples(t);if(s)throw new rt("Verbose predictLoop() is not implemented yet.");const i=jR(o,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)L(()=>{const h=Dv(t,i[l][0],i[l][1]),f=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)f.push({key:this.inputs[m],value:h[m]});else f.push({key:this.inputs[0],value:h});const p=new iu(f);return Sv(this.outputs,p)}).forEach((c,d)=>a[d].push(c));return $s(a.map(l=>Un(l,0)))})}predict(t,r={}){const s=Oq(t);Pq(s,this.inputNames,this.feedInputShapes,!1);try{const o=null==r.batchSize?32:r.batchSize;return WR(o),this.predictLoop(s,o)}finally{xi(s,t)}}predictOnBatch(t){Pq(t,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,r)}standardizeUserDataXY(t,r,s=!0,o){if(null==this.optimizer_)throw new Ho("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];i.push(this.feedLossFns[a]===RI?l.slice(0,l.length-1).concat([1]):l)}if(function t_e(e,n){const r=ru(e.map(o=>o.shape[0]));r.sort();const s=ru(n.map(o=>o.shape[0]));if(s.sort(),r.length>1)throw new $(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>1)throw new $(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(o=>o.shape))}`);if(r.length>0&&s.length>0&&!wt(r,s))throw new $(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(t=$q(t,this.feedInputNames,this.feedInputShapes,!1,"input"),r=$q(r,this.feedOutputNames,i,!1,"target")),function n_e(e,n,t){const r=[AI,MI,Ev];for(let s=0;s<e.length;++s){const o=e[s],i=n[s],a=t[s];if(null!=i){if(i===Ev&&1===o.shape[o.shape.length-1])throw new $(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const l=o.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=u[c];if(null!=h&&l[c]!==h)throw new $(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=o&&o>0&&t[0].shape[0]%o!=0)throw new $(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${t[0].shape[0]} sample(s).`);return[t,r]}standardizeUserData(t,r,s,o,i=!0,a){var l=this;return F(function*(){const[u,c]=l.standardizeUserDataXY(t,r,i,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=o){const h=Tq(o,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield kq(c[f],null,h[f]))}return[u,c,d]})()}testLoop(t,r,s,o=0,i){return L(()=>{const a=this.checkNumSamples(r,s,i,"steps"),l=[];if(o>0)throw new rt("Verbose mode is not implemented yet.");if(null!=i)throw new rt("steps mode in testLoop() is not implemented yet");{const u=jR(a,s),c=Wr(yi(0,a));for(let d=0;d<u.length;++d){const h=u[d][0],f=u[d][1],p=Gc(c,h,f-h),m=HR(r,p),g=t(m);if(0===d)for(let y=0;y<g.length;++y)l.push(Re(0));for(let y=0;y<g.length;++y)l[y]=ne(l[y],M(f-h,g[y]))}for(let d=0;d<l.length;++d)l[d]=ke(l[d],a)}return l})}getDedupedMetricsNames(){const t=this.metricsNames,r=[];for(let s=0;s<t.length;++s){const o=t[s];let i=o;WG(t,o)>1&&(i+=`_${WG(t.slice(0,s),o)}`),r.push(i)}return r}makeTrainFunction(){return t=>{const r=[],s=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const f=new iu(h),p=Sv(this.outputs,f,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let v=(0,this.lossFunctions[g])(o[g],p[g]);null!=i[g]&&(v=qSe(v,i[g]));const b=Nn(v);r.push(b),m=0===g?v:ne(m,v)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=r[g];else{const b=this.metricsTensors[g][1];y=Nn((0,this.metricsTensors[g][0])(o[b],p[b]))}ur(y),a.push(y)}return m=Nn(m),this.calculateLosses().forEach(g=>{m=ne(m,g)}),m},!0,u)].concat(a)}}makeTestFunction(){this.testFunction=t=>L(()=>{const r=[];let s;const o=t.slice(0,this.inputs.length),i=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:o[c]});const l=new iu(a),u=Sv(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=Nn((0,this.lossFunctions[c])(i[c],u[c]));s=0===c?h:ne(s,h),r.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],f=Nn((0,this.metricsTensors[c][0])(i[h],u[h]));r.push(f)}return r})}fit(t,r,s={}){var o=this;return F(function*(){if(o.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,a,l,u,c,d,h,f,p;o.isTraining=!0;try{const m=null==s.batchSize?32:s.batchSize;WR(m);const y=yield o.standardizeUserData(t,r,s.sampleWeight,s.classWeight,!1,m);i=y[0],a=y[1],p=y[2];let b,v=!1;if(null!=s.validationData&&s.validationData.length>0){if(v=!0,2!==s.validationData.length)throw 3===s.validationData.length?new rt("validationData including sample weights is not supported yet."):new $(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);c=s.validationData[0],d=s.validationData[1];const B=yield o.standardizeUserData(c,d,null,null,!0,m);h=B[0],f=B[1],b=h.concat(f)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){v=!0;const P=Math.floor(i[0].shape[0]*(1-s.validationSplit)),B=i[0].shape[0];h=Dv(i,P,B),l=i,i=Dv(i,0,P),f=Dv(a,P,B),u=a,a=Dv(a,0,P),b=h.concat(f)}else null!=s.validationSteps&&(v=!0);const w=i.concat(a).concat(p);o.checkTrainableWeightsConsistency();const x=o.makeTrainFunction(),I=o.getDedupedMetricsNames();let _,D;v?(o.makeTestFunction(),_=o.testFunction,D=I.slice().concat(I.map(P=>"val_"+P))):(_=null,b=[],D=I.slice());const N=yq(s.callbacks,s.yieldEvery);return yield o.fitLoop(x,w,I,m,s.epochs,s.verbose,N,_,b,s.shuffle,D,s.initialEpoch,null,null)}finally{o.isTraining=!1,xi(i,t),xi(a,r),xi(l,t),xi(u,r),xi(h,c),xi(f,d),null!=p&&ot(p)}})()}fitLoop(t,r,s,o,i,a,l,u,c,d,h,f,p,m){var g=this;return F(function*(){null==o&&(o=32),null==i&&(i=1),null==d&&(d=!0),null==f&&(f=0);let y=!1;if(null!=u&&null!=c&&(y=!0),null!=m&&(y=!0,null==p))throw new $("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const v=g.checkNumSamples(r,o,p,"steps_per_epoch");let b;null!=v&&(b=yi(0,v)),null==a&&(a=1);const{callbackList:w,history:x}=vq(l,a,i,f,v,p,o,y,h);w.setModel(g),g.history=x,yield w.onTrainBegin(),g.stopTraining_=!1;for(let I=f;I<i;++I){yield w.onEpochBegin(I);const _={};if(null!=p)throw new rt("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new rt("batch shuffling is not implemneted yet");d&&T1(b);const D=Wr(b),N=jR(v,o);for(let T=0;T<N.length;++T){const P={};if(yield w.onBatchBegin(T,P),L(()=>{const B=N[T][0],W=N[T][1],H=Gc(D,B,W-B);P.batch=T,P.size=W-B;const G=HR(r,H),Y=t(G);for(let Q=0;Q<s.length;++Q){const J=Y[Q];P[s[Q]]=J,ur(J)}if(T===N.length-1&&y){const Q=g.testLoop(u,c,o);for(let q=0;q<s.length;++q){const J=s[q],ie=Q[q];ur(ie),_["val_"+J]=ie}}}),yield w.onBatchEnd(T,P),gq(P),g.stopTraining_)break}D.dispose()}if(yield w.onEpochEnd(I,_),g.stopTraining_)break}return yield w.onTrainEnd(),yield g.history.syncData(),g.history})()}fitDataset(t,r){var s=this;return F(function*(){return function YSe(e,n,t){return zR.apply(this,arguments)}(s,t,r)})()}trainOnBatch(t,r){var s=this;return F(function*(){const o=yield s.standardizeUserData(t,r),i=o[0],a=o[1],u=s.makeTrainFunction()(i.concat(a)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return ot(u),xi(o[0],t),xi(o[1],r),$s(c)})()}getNamedWeights(t){const r=[],s=null!=t&&t.trainableOnly,o=s?this.trainableWeights:this.weights,i=this.getWeights(s);for(let a=0;a<o.length;++a)s&&!o[a].trainable||r.push({name:o[a].originalName,tensor:i[a]});return r}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(0===t.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=_C().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=r-_C().numTensors}return t}getLossIdentifiers(){let t;if("string"==typeof this.loss)t=Ya(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(r=>Ya(r))}else{const r=Object.keys(this.loss);t={};const s=this.loss;for(const o of r){if("string"!=typeof s[o])throw new Error("Serialization of non-string loss is not supported.");t[o]=Ya(s[o])}}return t}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Ya($I(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Ya($I(t)));{const t={};for(const r in this.metrics)t[r]=Ya($I(this.metrics[r]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(null!=t.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=t.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=t.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=Za(PR(t.optimizer_config));let o,i;if("string"==typeof t.loss)o=Wc(t.loss);else if(Array.isArray(t.loss))o=t.loss.map(a=>Wc(a));else if(null!=t.loss){o={};for(const a in t.loss)o[a]=Wc(t.loss[a])}if(Array.isArray(t.metrics))i=t.metrics.map(a=>Wc(a));else if(null!=t.metrics){i={};for(const a in t.metrics)i[a]=Wc(t.metrics[a])}this.compile({loss:o,metrics:i,optimizer:s})}save(t,r){var s=this;return F(function*(){if("string"==typeof t){const d=EH(t);if(0===d.length)throw new $(`Cannot find any save handlers for URL '${t}'`);if(d.length>1)throw new $(`Found more than one (${d.length}) save handlers for URL '${t}'`);t=d[0]}if(null==t.save)throw new $("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const o=yield K1(s.getNamedWeights(r)),u={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.22.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){u.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield K1(yield s.optimizer.getWeights(),d);o.specs.push(...f),o.data=CH([o.data,h])}return null!=s.userDefinedMetadata&&(Eq(s.userDefinedMetadata,s.name,!0),u.userDefinedMetadata=s.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,t.save(u)})()}setUserDefinedMetadata(t){Eq(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}return e.className="Model",e})();oe(np),oe((()=>{class e extends np{}return e.className="Functional",e})()),oe((()=>{class e extends np{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=null!=t.name?t.name:wI("sequential_"),null!=t.layers)for(const r of t.layers)this.add(r)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new $(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const r=t instanceof e||t instanceof np;let s;if(r){if(s=t,1!==s.outputs.length)throw new $("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new $("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===t.inboundNodes.length){if(null==t.batchInputShape)throw new $("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=function iSe(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new $("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=e.batchShape;null!=e.shape&&null==n&&(n=[null].concat(e.shape));let t=e.dtype;return null==t&&(t="float32"),new DI({batchInputShape:n,name:e.name,dtype:t,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(o)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==t.inboundNodes.length)throw new $(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(1!==t.inboundNodes[0].outputTensors.length)throw new $("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=hq(this.outputs[0])}this.inboundNodes=[],new EI({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Uc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=t.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,r){return null==this.model&&this.build(),this.model.call(t,r)}build(t){if(Ot(t),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new np({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,r,s=console.log){this.built||this.build(),super.summary(t,r,s)}setWeights(t){null==this.model&&this.build(),this.model.setWeights(t)}evaluate(t,r,s={}){if(!this.built)throw new Ho("The model needs to be compiled before being used.");return this.model.evaluate(t,r,s)}evaluateDataset(t,r){var s=this;return F(function*(){if(!s.built)throw new Ho("The model needs to be compiled before being used.");return s.model.evaluateDataset(t,r)})()}predict(t,r={}){return null==this.model&&this.build(),this.model.predict(t,r)}predictOnBatch(t){return null==this.model&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}fit(t,r,s={}){var o=this;return F(function*(){if(!o.built)throw new Ho("The model needs to be compiled before being used.");return o.model.fit(t,r,s)})()}fitDataset(t,r){var s=this;return F(function*(){if(!s.built)throw new Ho("The model needs to be compiled before being used.");return s.model.fitDataset(t,r)})()}trainOnBatch(t,r){var s=this;return F(function*(){return s.model.trainOnBatch(t,r)})()}static fromConfig(t,r,s={},o=!1){let i,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new $("Legacy serialization format not supported yet.");i=r}else S(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;const l=new t(a);if(!(l instanceof e))throw new rt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of i){const d=Za(u,void 0,o);o&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(t){if(null==this.model)throw new $("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(null==this.model)throw new $("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),t.push(s)}return{name:this.name,layers:t}}}return e.className="Sequential",e})());class Jr extends kc{getConfig(){return{}}}oe((()=>{class e extends Jr{apply(t,r=1){return function jIe(e,n=1){if(1!==n)throw new rt(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return Wf(e)}(t,r)}}return e.className="elu",e})()),oe((()=>{class e extends Jr{apply(t){return ZC(t)}}return e.className="selu",e})()),oe((()=>{class e extends Jr{apply(t){return gi(t)}}return e.className="relu",e})()),oe((()=>{class e extends Jr{apply(t){return L(()=>eu(6,gi(t)))}}return e.className="relu6",e})()),oe((()=>{class e extends Jr{apply(t){return t}}return e.className="linear",e})()),oe((()=>{class e extends Jr{apply(t){return wo(t)}}return e.className="sigmoid",e})()),oe((()=>{class e extends Jr{apply(t){return function qIe(e){return L(()=>{const n=ne(.5,M(.2,e));return As(n,0,1)})}(t)}}return e.className="hardSigmoid",e})()),oe((()=>{class e extends Jr{apply(t){return Lc(t)}}return e.className="softplus",e})()),oe((()=>{class e extends Jr{apply(t){return function GIe(e){return L(()=>ke(e,ne(Jn(e),1)))}(t)}}return e.className="softsign",e})()),oe((()=>{class e extends Jr{apply(t){return Zl(t)}}return e.className="tanh",e})());let Lq=(()=>{class e extends Jr{apply(t,r=-1){return fv(t,r)}}return e.className="softmax",e})();function lu(e){return e.getClassName()}function YR(e,n={}){return bv(e,bo.getMap().classNameMap,n,"activation")}function uu(e){if(null==e){return YR({className:"linear",config:{}})}if("string"==typeof e){const n={};return n.className=e,n.config={},YR(n)}return e instanceof Jr?e:YR(e)}oe(Lq),oe((()=>{class e extends Jr{apply(t,r=-1){return WC(t,r)}}return e.className="logSoftmax",e})()),oe((()=>{class e extends Jr{apply(t){return L(()=>L(()=>{const r=Math.sqrt(2),s=M(.5,ne(1,zC(ke(t,r))));return M(t,s)}))}}return e.className="gelu",e})()),oe((()=>{class e extends Jr{apply(t){return L(()=>M(.5,M(t,ne(1,Zl(M(Nr(ke(2,Math.PI)),ne(t,M(.044715,Ji(t,3)))))))))}}return e.className="gelu_new",e})()),oe((()=>{class e extends Jr{apply(t){return L(()=>M(t,Zl(Lc(t))))}}return e.className="mish",e})()),oe((()=>{class e extends Jr{apply(t,r=1){return L(()=>M(wo(M(t,r)),t))}}return e.className="swish",e})());class Vq extends kc{}oe((()=>{class e extends Vq{constructor(t){super(),function ZR(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(t),this.l1=null==t||null==t.l1?.01:t.l1,this.l2=null==t||null==t.l2?.01:t.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(t){return L(()=>{let r=tr([1]);return this.hasL1&&(r=ne(r,De(M(this.l1,Jn(t))))),this.hasL2&&(r=ne(r,De(M(this.l2,Cv(t))))),O(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,r){return new t({l1:r.l1,l2:r.l2})}}return e.className="L1L2",e})());const Bq={l1l2:"L1L2"};function Jt(e){return xR(e)}function zq(e,n={}){return bv(e,bo.getMap().classNameMap,n,"regularizer")}function vn(e){return null==e?null:"string"==typeof e?zq({className:e in Bq?Bq[e]:e,config:{}}):e instanceof Vq?e:zq(e)}function rp(e,n,t){if("number"==typeof e)return Uc(e,n);if(e.length!==n)throw new $(`The ${t} argument must be an integer or tuple of ${n} integers. Received: ${e.length} elements.`);for(let r=0;r<n;++r){const s=e[r];if(!VIe(s))throw new $(`The ${t} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Ci(e,n,t,r,s=1){if(null==e)return e;let i;return i="same"===t?e:e-(n+(n-1)*(s-1))+1,Math.floor((i+r-1)/r)}function la(e,n,t,r){if(null==e)return null;if("valid"===r)e=e*n+ou([t-n,0]);else{if("same"!==r)throw new $(`Unsupport padding mode: ${r}.`);e*=n}return e}function JR(e,n){return L(()=>(Gn(n),"channelsFirst"===n?Ct(e,[0,2,3,1]):e))}function Uq(e,n){return L(()=>(Gn(n),"channelsFirst"===n?Ct(e,[0,2,3,4,1]):e))}function eM(e,n,t,r=[1,1],s="valid",o,i,a=null){return L(()=>{if(null==o&&(o="channelsLast"),Gn(o),3!==e.rank&&4!==e.rank)throw new $(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==n.rank&&4!==n.rank)throw new $(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=JR(e,o);if("causal"===s)throw new rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=qj({x:l,filter:n,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:t,activation:a}),"channelsFirst"===o&&(l=Ct(l,[0,3,1,2])),l})}oe((()=>{class e extends yt{constructor(t){super(t??{}),this.supportsMasking=!0,null!=t&&(this.maxValue=t.maxValue)}call(t,r){t=Ge(t);let s=gi(t);return null!=this.maxValue&&(s=As(s,0,this.maxValue)),s}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},r=super.getConfig();return Object.assign(t,r),t}}return e.className="ReLU",e})()),oe((()=>{class e extends yt{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,null==t&&(t={}),this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,r){const s=Ge(t);return rv(s,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},r=super.getConfig();return Object.assign(t,r),t}}return e.className="LeakyReLU",e})()),oe((()=>{class e extends yt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==t&&(t={}),this.supportsMasking=!0,this.alphaInitializer=yn(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=vn(t.alphaRegularizer),this.alphaConstraint=fr(t.alphaConstraint),null==t.sharedAxes)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else{if("number"!=typeof t.sharedAxes)throw new $(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`);this.sharedAxes=[t.sharedAxes]}}build(t){const r=(t=Ot(t)).slice(1);if(null!=this.sharedAxes)for(const o of this.sharedAxes)r[o-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let o=1;o<t.length;++o)s[o]=t[o];this.inputSpec=[new dr({ndim:t.length,axes:s})],this.built=!0}call(t,r){return t=Ge(t),cv(t,this.alpha.read())}getConfig(){const t={alphaInitializer:Tn(this.alphaInitializer),alphaRegularizer:Jt(this.alphaRegularizer),alphaConstraint:hr(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(t,r),t}}return e.className="PReLU",e})()),oe((()=>{class e extends yt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,null==t&&(t={}),null!=t.alpha&&t.alpha!==this.DEFAULT_ALPHA)throw new rt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==t.alpha?this.DEFAULT_ALPHA:t.alpha}call(t,r){const s=Ge(t);return Wf(s)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},r=super.getConfig();return Object.assign(t,r),t}}return e.className="ELU",e})()),oe((()=>{class e extends yt{constructor(t){super(t??{}),this.DEFAULT_THETA=1,null==t&&(t={}),this.theta=null==t.theta?this.DEFAULT_THETA:t.theta}call(t,r){const s=Ge(t);return M(s,pe(fs(s,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},r=super.getConfig();return Object.assign(t,r),t}}return e.className="ThresholdedReLU",e})()),oe((()=>{class e extends yt{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,null==t&&(t={}),this.softmax=(new Lq).apply,this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis}call(t,r){return L(()=>{let s=Ge(t);const o=r.mask;if(null!=o){const i=M(Ce(Ms(s.shape),pe(o,s.dtype)),Re(-1e9));s=ne(s,i)}return this.axis instanceof Array?this.axis.length>1?Rs(Ce(s,ov(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Softmax",e})());class LI extends yt{constructor(n,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",LI.verifyArgs(t),this.rank=n,Ar(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new rt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=rp(t.kernelSize,n,"kernelSize"),this.strides=rp(null==t.strides?1:t.strides,n,"strides"),this.padding=null==t.padding?"valid":t.padding,Eo(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Gn(this.dataFormat),this.activation=uu(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=yn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=fr(t.biasConstraint),this.biasRegularizer=vn(t.biasRegularizer),this.activityRegularizer=vn(t.activityRegularizer),this.dilationRate=rp(null==t.dilationRate?1:t.dilationRate,n,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new $(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new $(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new $(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(n){if(_o("kernelSize"in n,"required key 'kernelSize' not in config"),"number"!=typeof n.kernelSize&&!IR(n.kernelSize,"number",1,3))throw new $(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){const n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:lu(this.activation),useBias:this.useBias,biasInitializer:Tn(this.biasInitializer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),biasConstraint:hr(this.biasConstraint)},t=super.getConfig();return Object.assign(n,t),n}}class sp extends LI{constructor(n,t){super(n,t),this.kernel=null,sp.verifyArgs(t),this.filters=t.filters,Ar(this.filters,"filters"),this.kernelInitializer=yn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=fr(t.kernelConstraint),this.kernelRegularizer=vn(t.kernelRegularizer)}build(n){n=Ot(n);const t="channelsFirst"===this.dataFormat?1:n.length-1;if(null==n[t])throw new $(`The channel dimension of the input should be defined. Found ${n[t]}`);const r=n[t],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(n,t){return L(()=>{let r;n=Ge(n);const s=null==this.bias?null:this.bias.read(),o=jG(this.activation.getClassName());if(null!=o&&2===this.rank)r=eM(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(1===this.rank)r=function Wq(e,n,t,r=1,s="valid",o,i=1){return L(()=>{if(null==o&&(o="channelsLast"),Gn(o),3!==e.shape.length)throw new $(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==n.shape.length)throw new $(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(null!=t&&1!==t.shape.length)throw new $(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===o&&(e=Ct(e,[0,2,1])),"causal"===s)throw new rt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=$C(e,n,r,"same"===s?"same":"valid","NWC",i);return null!=t&&(a=bi(a,t)),a})}(n,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=eM(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new rt("convolutions greater than 3D are not implemented yet.");r=function Hq(e,n,t,r=[1,1,1],s="valid",o,i){return L(()=>{if(null==o&&(o="channelsLast"),Gn(o),4!==e.rank&&5!==e.rank)throw new $(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==n.rank&&5!==n.rank)throw new $(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let a=Uq(e,o);if("causal"===s)throw new rt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=lA(a,n,r,"same"===s?"same":"valid","NDHWC",i),null!=t&&(a=bi(a,t)),"channelsFirst"===o&&(a=Ct(a,[0,4,1,2,3])),a})}(n,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=Ot(n);const t=[],r="channelsLast"===this.dataFormat?n.slice(1,n.length-1):n.slice(2);for(let o=0;o<r.length;++o){const i=Ci(r[o],this.kernelSize[o],this.padding,this.strides[o],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[o]);t.push(i)}let s=[n[0]];return"channelsLast"===this.dataFormat?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const n={filters:this.filters,kernelInitializer:Tn(this.kernelInitializer),kernelRegularizer:Jt(this.kernelRegularizer),kernelConstraint:hr(this.kernelConstraint)},t=super.getConfig();return Object.assign(n,t),n}static verifyArgs(n){if(!("filters"in n)||"number"!=typeof n.filters||n.filters<1)throw new $(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}}let jq=(()=>{class e extends sp{constructor(t){super(2,t),e.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!IR(t.kernelSize,"number",1,2))throw new $(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}return e.className="Conv2D",e})();oe(jq);let Gq=(()=>{class e extends sp{constructor(t){super(3,t),e.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&(!Array.isArray(t.kernelSize)||1!==t.kernelSize.length&&3!==t.kernelSize.length))throw new $(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}return e.className="Conv3D",e})();oe(Gq),oe((()=>{class e extends jq{constructor(t){if(super(t),this.inputSpec=[new dr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new $(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(4!==(t=Ot(t)).length)throw new $("Input should have rank 4; Received input shape: "+JSON.stringify(t));const r="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[r])throw new $("The channel dimension of the inputs should be defined. Found `None`.");const s=t[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new dr({ndim:4,axes:{[r]:s}})],this.built=!0}call(t,r){return L(()=>{let s=Ge(t);if(4!==s.shape.length)throw new $(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const c=o[l],h=this.kernelSize[1],p=this.strides[1],y=[o[0],la(o[a],this.strides[0],this.kernelSize[0],this.padding),la(c,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Ct(s,[0,2,3,1]));let v=PC(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(v=Ct(v,[0,3,1,2])),null!=this.bias&&(v=bi(v,this.bias.read(),this.dataFormat)),null!=this.activation&&(v=this.activation.apply(v)),v})}computeOutputShape(t){const r=(t=Ot(t)).slice();let s,o,i;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3):(s=3,o=1,i=2);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return r[s]=this.filters,r[o]=la(r[o],u,a,this.padding),r[i]=la(r[i],c,l,this.padding),r}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}return e.className="Conv2DTranspose",e})()),oe((()=>{class e extends Gq{constructor(t){if(super(t),this.inputSpec=[new dr({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new $(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(5!==(t=Ot(t)).length)throw new $("Input should have rank 5; Received input shape: "+JSON.stringify(t));const r="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[r])throw new $("The channel dimension of the inputs should be defined. Found `None`.");const s=t[r],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new dr({ndim:5,axes:{[r]:s}})],this.built=!0}call(t,r){return L(()=>{let s=Ge(t);if(5!==s.shape.length)throw new $(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape;let a,l,u;"channelsFirst"===this.dataFormat?(u=2,a=3,l=4):(u=1,a=2,l=3);const d=o[a],h=o[l],p=this.kernelSize[1],m=this.kernelSize[2],y=this.strides[1],v=this.strides[2],I=[o[0],la(o[u],this.strides[0],this.kernelSize[0],this.padding),la(d,y,p,this.padding),la(h,v,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Ct(s,[0,2,3,4,1]));let _=uA(s,this.kernel.read(),I,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(_=Ct(_,[0,4,1,2,3])),null!==this.bias&&(_=bi(_,this.bias.read(),this.dataFormat)),null!==this.activation&&(_=this.activation.apply(_)),_})}computeOutputShape(t){const r=(t=Ot(t)).slice();let s,o,i,a;"channelsFirst"===this.dataFormat?(s=1,o=2,i=3,a=4):(s=4,o=1,i=2,a=3);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],f=this.strides[2];return r[s]=this.filters,r[o]=la(r[o],d,l,this.padding),r[i]=la(r[i],h,u,this.padding),r[a]=la(r[a],f,c,this.padding),r}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}return e.className="Conv3DTranspose",e})());let a_e=(()=>{class e extends sp{constructor(t,r){if(super(t,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new $("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new $("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new $(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=null==r.depthMultiplier?1:r.depthMultiplier,this.depthwiseInitializer=yn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=vn(r.depthwiseRegularizer),this.depthwiseConstraint=fr(r.depthwiseConstraint),this.pointwiseInitializer=yn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=vn(r.pointwiseRegularizer),this.pointwiseConstraint=fr(r.pointwiseConstraint)}build(t){if((t=Ot(t)).length<this.rank+2)throw new $(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const r="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[r]||t[r]<0)throw new $(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[r])}`);const s=t[r],o=this.kernelSize.concat([s,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new dr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(t,r){return L(()=>{let s;if(t=Ge(t),1===this.rank)throw new rt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(t=Ct(t,[0,2,3,1])),s=QC(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=bi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=Ct(s,[0,3,1,2])),s})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=Tn(this.depthwiseInitializer),t.pointwiseInitializer=Tn(this.pointwiseInitializer),t.depthwiseRegularizer=Jt(this.depthwiseRegularizer),t.pointwiseRegularizer=Jt(this.pointwiseRegularizer),t.depthwiseConstraint=hr(this.depthwiseConstraint),t.pointwiseConstraint=hr(this.pointwiseConstraint),t}}return e.className="SeparableConv",e})();function qq(e,n,t,r){if(Array.isArray(e)){if(null!=n||null!=t)throw new $("When inputs is an array, neither initialState or constants should be provided");null!=r&&(t=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(n=e.slice(1,e.length)),e=e[0]}function s(o){return null==o||Array.isArray(o)?o:[o]}return{inputs:e,initialState:n=s(n),constants:t=s(t)}}function Kq(e,n,t,r=!1,s,o,i=!1,a=!1){return L(()=>{const l=n.shape.length;if(l<3)throw new $(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(yi(2,l));if(n=Ct(n,u),null!=o)throw new rt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=pe(pe(s,"bool"),"float32")).rank===l-1&&(s=jn(s,-1)),s=Ct(s,u)),r&&(n=Io(n,0),null!=s&&(s=Io(s,0)));const c=[];let d,h=t;const f=n.shape[0],p=So(n);let m,g;null!=s&&(m=So(s));for(let y=0;y<f;++y){const v=p[y],b=L(()=>e(v,h));if(null==s)d=b[0],h=b[1];else{const w=L(()=>{const x=m[y],I=Ce(Zs(x),x);return{output:ne(M(b[0],x),M(h[0],I)),newStates:h.map((N,T)=>ne(M(b[1][T],x),M(N,I)))}});d=w.output,h=w.newStates}a&&c.push(d)}return a&&(g=ps(c,1)),[d,g,h]})}oe((()=>{class e extends a_e{constructor(t){super(2,t)}}return e.className="SeparableConv2D",e})()),oe((()=>{class e extends sp{constructor(t){super(1,t),e.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if("number"!=typeof t.kernelSize&&!IR(t.kernelSize,"number",1,1))throw new $(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}return e.className="Conv1D",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.cropping="number"==typeof t.cropping?[[t.cropping,t.cropping],[t.cropping,t.cropping]]:"number"==typeof t.cropping[0]?[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:t.cropping,this.dataFormat=void 0===t.dataFormat?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,r){return L(()=>{if(t=Ge(t),"channelsLast"===this.dataFormat){const s=CI(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return CI(s,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=CI(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return CI(s,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Cropping2D",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==t.size?this.DEFAULT_SIZE:t.size,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Gn(this.dataFormat),this.interpolation=null==t.interpolation?"nearest":t.interpolation,function $Ie(e){Hc(RIe,"InterpolationFormat",e)}(this.interpolation)}computeOutputShape(t){return"channelsFirst"===this.dataFormat?[t[0],t[1],null==t[2]?null:this.size[0]*t[2],null==t[3]?null:this.size[1]*t[3]]:[t[0],null==t[1]?null:this.size[0]*t[1],null==t[2]?null:this.size[1]*t[2],t[3]]}call(t,r){return L(()=>{let s=Ge(t);const o=s.shape;if("channelsFirst"===this.dataFormat){s=Ct(s,[0,2,3,1]);const i=this.size[0]*o[2],a=this.size[1]*o[3],l="nearest"===this.interpolation?ms.resizeNearestNeighbor(s,[i,a]):ms.resizeBilinear(s,[i,a]);return Ct(l,[0,3,1,2])}{const i=this.size[0]*o[1],a=this.size[1]*o[2];return"nearest"===this.interpolation?ms.resizeNearestNeighbor(s,[i,a]):ms.resizeBilinear(s,[i,a])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(t,r),t}}return e.className="UpSampling2D",e})()),oe((()=>{class e extends LI{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=yn(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=fr(t.depthwiseConstraint),this.depthwiseRegularizer=vn(t.depthwiseRegularizer)}build(t){if((t=Ot(t)).length<4)throw new $(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==t[r]||t[r]<0)throw new $(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[r]}).`);const s=t[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,r){return L(()=>{let s=function l_e(e,n,t=[1,1],r="valid",s,o){return L(()=>{null==s&&(s="channelsLast"),Gn(s);let i=JR(e,s);if(4!==e.rank)throw new $(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==n.rank)throw new $(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return i=Uf(i,n,t,"same"===r?"same":"valid","NHWC",o),"channelsFirst"===s&&(i=Ct(i,[0,3,1,2])),i})}(t=Ge(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=bi(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(t){t=Ot(t);const s="channelsFirst"===this.dataFormat?t[3]:t[2],o="channelsFirst"===this.dataFormat?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,i=Ci("channelsFirst"===this.dataFormat?t[2]:t[1],this.kernelSize[0],this.padding,this.strides[0]),a=Ci(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[t[0],o,i,a]:[t[0],i,a,o]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=Tn(this.depthwiseInitializer),t.depthwiseRegularizer=Jt(this.depthwiseRegularizer),t.depthwiseConstraint=hr(this.depthwiseRegularizer),t}}return e.className="DepthwiseConv2D",e})());let Nv=(()=>{class e extends yt{constructor(t){let r;if(super(t),null==t.cell)throw new $("cell property is missing for the constructor of RNN.");if(r=Array.isArray(t.cell)?new Zq({cells:t.cell}):t.cell,null==r.stateSize)throw new $("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new dr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?yi(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null):this.states_}setStates(t){this.states_=t}computeOutputShape(t){NR(t)&&(t=t[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let o;if(o=this.returnSequences?[t[0],t[1],s]:[t[0],s],this.returnState){const i=[];for(const a of r)i.push([t[0],a]);return[o].concat(i)}return o}computeMask(t,r){return L(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const o=this.states.map(i=>null);return[s].concat(o)}return s})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<t;++s)r.push(null);return r}return this.states_}set states(t){this.states_=t}build(t){if(null!=this.numConstants)throw new rt("Constants support is not implemented in RNN yet.");NR(t)&&(t=t[0]);const s=this.stateful?t[0]:null,o=t.slice(2);this.inputSpec[0]=new dr({shape:[s,null,...o]});const i=[t[0]].concat(t.slice(2));let a;if(this.cell.build(i),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!wt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new $(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new dr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(t,r=!1){L(()=>{if(!this.stateful)throw new ra("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new $("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>tr([s,o])):[tr([s,this.cell.stateSize])];else if(null==t)ot(this.states_),null!=this.keptStates&&(ot(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>tr([s,o])):this.states_[0]=tr([s,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new $(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);!0===r?this.keptStates.push(this.states_.slice()):ot(this.states_);for(let o=0;o<this.states_.length;++o){const i=t[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,l=[s,a];if(!wt(i.shape,l))throw new $(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[o]=i}}this.states_=this.states_.map(o=>ur(o.clone()))})}apply(t,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=qq(t,s,o,this.numConstants);t=i.inputs,s=i.initialState,o=i.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new dr({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=o&&(r.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof aa){const c=[t].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(t,r)}call(t,r){return L(()=>{const s=null==r?null:r.mask,o=null==r?null:r.training;let i=null==r?null:r.initialState;t=Ge(t),null==i&&(i=this.stateful?this.states_:this.getInitialState(t));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new $(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:o},c=Kq((m,g)=>{const y=this.cell.call([m].concat(g),l);return[y[0],y.slice(1)]},t,i,this.goBackwards,s,null,this.unroll,this.returnSequences),d=c[0],h=c[1],f=c[2];this.stateful&&this.resetStates(f,o);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(t){return L(()=>{let r=tr(t.shape);return r=De(r,[1,2]),r=xv(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?ER(r,[1,s]):r):this.cell.stateSize>1?[ER(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===e.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),t),r)}static fromConfig(t,r,s={}){const i=Za(r.cell,s);return new t(Object.assign(r,{cell:i}))}}return e.className="RNN",e})();oe(Nv);class VI extends yt{}let Xq=(()=>{class e extends VI{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ar(this.units,"units"),this.activation=uu(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=yn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=yn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=yn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vn(t.kernelRegularizer),this.recurrentRegularizer=vn(t.recurrentRegularizer),this.biasRegularizer=vn(t.biasRegularizer),this.kernelConstraint=fr(t.kernelConstraint),this.recurrentConstraint=fr(t.recurrentConstraint),this.biasConstraint=fr(t.biasConstraint),this.dropout=ep([1,ou([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=ep([1,ou([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Ot(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,r){return L(()=>{if(2!==t.length)throw new $(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let s=t[1];t=t[0];const o=null!=r.training&&r.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cu({ones:()=>Zs(t),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cu({ones:()=>Zs(s),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;i=oa(null!=a?M(t,a):t,this.kernel.read()),null!=this.bias&&(i=bi(i,this.bias.read())),null!=l&&(s=M(s,l));let u=ne(i,oa(s,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const t=super.getConfig(),r={units:this.units,activation:lu(this.activation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),recurrentInitializer:Tn(this.recurrentInitializer),biasInitializer:Tn(this.biasInitializer),kernelRegularizer:Jt(this.kernelRegularizer),recurrentRegularizer:Jt(this.recurrentRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:hr(this.kernelConstraint),recurrentConstraint:hr(this.recurrentConstraint),biasConstraint:hr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),r)}}return e.className="SimpleRNNCell",e})();oe(Xq),oe((()=>{class e extends Nv{constructor(t){t.cell=new Xq(t),super(t)}call(t,r){return L(()=>(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(t,r){return new t(r)}}return e.className="SimpleRNN",e})());let Yq=(()=>{class e extends VI{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new $("GRUCell does not support reset_after parameter set to true.");this.units=t.units,Ar(this.units,"units"),this.activation=uu(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=uu(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=yn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=yn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=yn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=vn(t.kernelRegularizer),this.recurrentRegularizer=vn(t.recurrentRegularizer),this.biasRegularizer=vn(t.biasRegularizer),this.kernelConstraint=fr(t.kernelConstraint),this.recurrentConstraint=fr(t.recurrentConstraint),this.biasConstraint=fr(t.biasConstraint),this.dropout=ep([1,ou([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=ep([1,ou([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=Ot(t),this.kernel=this.addWeight("kernel",[t[t.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(t,r){return L(()=>{if(2!==t.length)throw new $(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const s=null!=r.training&&r.training;let o=t[1];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cu({ones:()=>Zs(t),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cu({ones:()=>Zs(o),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(t=M(t,this.dropoutMask[0]));let d=oa(t,this.kernel.read());this.useBias&&(d=bi(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=M(o,a[0]));const h=this.recurrentKernel.read(),[f,p]=Os(h,[2*this.units,this.units],h.rank-1),m=oa(o,f),[g,y,v]=Os(d,3,d.rank-1),[b,w]=Os(m,2,m.rank-1);l=this.recurrentActivation.apply(ne(g,b)),u=this.recurrentActivation.apply(ne(y,w));const x=oa(M(u,o),p);c=this.activation.apply(ne(v,x));const I=ne(M(l,o),M(ne(1,on(l)),c));return[I,I]})}getConfig(){const t=super.getConfig(),r={units:this.units,activation:lu(this.activation),recurrentActivation:lu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),recurrentInitializer:Tn(this.recurrentInitializer),biasInitializer:Tn(this.biasInitializer),kernelRegularizer:Jt(this.kernelRegularizer),recurrentRegularizer:Jt(this.recurrentRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:hr(this.kernelConstraint),recurrentConstraint:hr(this.recurrentConstraint),biasConstraint:hr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),r)}}return e.className="GRUCell",e})();oe(Yq),oe((()=>{class e extends Nv{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Yq(t),super(t)}call(t,r){return L(()=>(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(t,r){return 0===r.implmentation&&(r.implementation=1),new t(r)}}return e.className="GRU",e})());let tM=(()=>{class e extends VI{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,Ar(this.units,"units"),this.activation=uu(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=uu(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=yn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=yn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=yn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=vn(t.kernelRegularizer),this.recurrentRegularizer=vn(t.recurrentRegularizer),this.biasRegularizer=vn(t.biasRegularizer),this.kernelConstraint=fr(t.kernelConstraint),this.recurrentConstraint=fr(t.recurrentConstraint),this.biasConstraint=fr(t.biasConstraint),this.dropout=ep([1,ou([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=ep([1,ou([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var r;let o;if(t=Ot(t),this.kernel=this.addWeight("kernel",[t[t.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,a=this.units;o=new((r=class extends Go{apply(u,c){const d=i.apply([a]),h=(new nq).apply([a]),f=i.apply([2*a]);return JG(JG(d,h),f)}}).className="CustomInit",r)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,r){return L(()=>{const s=null!=r.training&&r.training;if(3!==t.length)throw new $(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let o=t[1];const i=t[2];t=t[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cu({ones:()=>Zs(t),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cu({ones:()=>Zs(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(t=M(t,this.dropoutMask[0]));let f=oa(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=M(o,l[0])),f=ne(f,oa(o,this.recurrentKernel.read())),this.useBias&&(f=bi(f,this.bias.read()));const[p,m,g,y]=Os(f,4,f.rank-1);u=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(m),d=ne(M(c,i),M(u,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const v=M(h,this.activation.apply(d));return[v,v,d]})}getConfig(){const t=super.getConfig(),r={units:this.units,activation:lu(this.activation),recurrentActivation:lu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),recurrentInitializer:Tn(this.recurrentInitializer),biasInitializer:Tn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Jt(this.kernelRegularizer),recurrentRegularizer:Jt(this.recurrentRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:hr(this.kernelConstraint),recurrentConstraint:hr(this.recurrentConstraint),biasConstraint:hr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),r)}}return e.className="LSTMCell",e})();oe(tM),oe((()=>{class e extends Nv{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new tM(t),super(t)}call(t,r){return L(()=>(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(t,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(t,r){return 0===r.implmentation&&(r.implementation=1),new t(r)}}return e.className="LSTM",e})());let Zq=(()=>{class e extends VI{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?t.push(...r.stateSize):t.push(r.stateSize);return t}call(t,r){return L(()=>{let s=t.slice(1);const o=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?o.push(s.splice(0,l.stateSize.length)):o.push(s.splice(0,1));o.reverse();const i=[];let a;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];s=o[l],a=0===l?[t[0]].concat(s):[a[0]].concat(s),a=u.call(a,r),i.push(a.slice(1))}s=[];for(const l of i.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(t){let r;NR(t)&&(t=t[0]),this.cells.forEach((s,o)=>{jc(`RNNCell_${o}`,()=>{s.build(t),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,t=[t[0],r]})}),this.built=!0}getConfig(){const t=super.getConfig(),o={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign(Object.assign({},t),o)}static fromConfig(t,r,s={}){const o=[];for(const i of r.cells)o.push(Za(i,s));return new t({cells:o})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const r of this.cells)t.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(t)}return t}getWeights(){const t=[];for(const r of this.cells)t.push(...r.weights);return TR(t)}setWeights(t){const r=[];for(const s of this.cells){const i=t.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],i[a]])}kR(r)}}return e.className="StackedRNNCells",e})();function cu(e){const{ones:n,rate:t,training:r=!1,count:s=1,dropoutFunc:o}=e,i=()=>null!=o?o(n(),t):tq(n(),t),a=()=>Iv(i,n,r);return!s||s<=1?ur(a().clone()):Array(s).fill(void 0).map(a).map(u=>ur(u.clone()))}oe(Zq);let c_e=(()=>{class e extends Nv{constructor(t){if(t.unroll)throw new rt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new rt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new dr({ndim:5})]}call(t,r){return L(()=>{if(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new $("ConvRNN2D cell does not support constants");return super.call(t,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(t){let r=this.computeSingleOutputShape(t);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([t[0],...r.slice(-3)])]),r}getInitialState(t){return L(()=>{const{stateSize:r}=this.cell,o=this.computeSingleOutputShape(t.shape),a=tr([o[0],...o.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(t,r=!1){L(()=>{if(!this.stateful)throw new ra("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),i=[o[0],...o.slice(2)];if(null==s[0])throw new $("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>tr(i)):[tr(i)];else if(null==t)ot(this.states_),null!=this.keptStates&&(ot(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>tr(i)):this.states_[0]=tr(i);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new $(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);r?this.keptStates.push(this.states_.slice()):ot(this.states_);for(let l=0;l<this.states_.length;++l){const u=t[l],c=i;if(!wt(u.shape,c))throw new $(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>ur(l.clone()))})}computeSingleOutputShape(t){const{dataFormat:r,filters:s,kernelSize:o,padding:i,strides:a,dilationRate:l}=this.cell,u="channelsFirst"===r,d=t[u?4:3],h=Ci(t[u?3:2],o[0],i,a[0],l[0]),f=Ci(d,o[1],i,a[1],l[1]);return[...t.slice(0,2),...u?[s,h,f]:[h,f,s]]}}return e.className="ConvRNN2D",e})(),Qq=(()=>{class e extends tM{constructor(t){const{filters:r,kernelSize:s,strides:o,padding:i,dataFormat:a,dilationRate:l}=t;super(Object.assign(Object.assign({},t),{units:r})),this.filters=r,Ar(this.filters,"filters"),this.kernelSize=rp(s,2,"kernelSize"),this.kernelSize.forEach(u=>Ar(u,"kernelSize")),this.strides=rp(o||1,2,"strides"),this.strides.forEach(u=>Ar(u,"strides")),this.padding=i||"valid",Eo(this.padding),this.dataFormat=a||"channelsLast",Gn(this.dataFormat),this.dilationRate=rp(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Ar(u,"dilationRate"))}build(t){var r;t=Ot(t);const s="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[s])throw new $(`The channel dimension of the input should be defined. Found ${t[s]}`);const a=this.kernelSize.concat([t[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((r=class extends Go{apply(f,p){return _R([c.apply([d]),Ms([d]),c.apply([2*d])])}}).className="CustomInit",r)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,r){return L(()=>{if(3!==t.length)throw new $(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const s=r.training||!1,o=t[0],i=t[1],a=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cu({ones:()=>Zs(o),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(ue,me,de)=>me&&me[de]?M(me[de],ue):ue;let d=c(o,u,0),h=c(o,u,1),f=c(o,u,2),p=c(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cu({ones:()=>Zs(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=c(i,m,0),y=c(i,m,1),v=c(i,m,2),b=c(i,m,3);const[x,I,_,D]=Os(this.kernel.read(),4,3),[N,T,P,B]=this.useBias?Os(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,x,N,this.padding),h=this.inputConv(h,I,T,this.padding),f=this.inputConv(f,_,P,this.padding),p=this.inputConv(p,D,B,this.padding);const[W,H,G,Y]=Os(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,W),y=this.recurrentConv(y,H),v=this.recurrentConv(v,G),b=this.recurrentConv(b,Y);const Q=this.recurrentActivation.apply(ne(d,g)),q=this.recurrentActivation.apply(ne(h,y)),J=ne(M(q,a),M(Q,this.activation.apply(ne(f,v)))),ie=M(this.recurrentActivation.apply(ne(p,b)),this.activation.apply(J));return[ie,ie,J]})}getConfig(){const s=function(e,n){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&n.indexOf(r)<0&&(t[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)n.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(t[r[s]]=e[r[s]])}return t}(super.getConfig(),["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),o)}inputConv(t,r,s,o){const i=Wa(t,r,this.strides,o||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?bi(i,s,this.dataFormat):i}recurrentConv(t,r){return Wa(t,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return e.className="ConvLSTM2DCell",e})();oe(Qq),oe((()=>{class e extends c_e{constructor(t){const r=new Qq(t);super(Object.assign(Object.assign({},t),{cell:r}))}static fromConfig(t,r){return new t(r)}}return e.className="ConvLSTM2D",e})());let Jq=(()=>{class e extends yt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const r=t.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(null==this.noiseShape[o]?r[o]:this.noiseShape[o]);return s}call(t,r){return L(()=>{this.invokeCallHook(t,r);const s=Ge(t);if(0<this.rate&&this.rate<1){const o=null!=r.training&&r.training,i=this.getNoiseShape(s);return Iv(()=>tq(s,this.rate,i,this.seed),()=>s,o)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(t,r),t}dispose(){return super.dispose()}}return e.className="Dropout",e})();oe(Jq),oe((()=>{class e extends Jq{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const r=t.shape;return[r[0],1,r[2]]}}return e.className="SpatialDropout1D",e})()),oe((()=>{class e extends yt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let r=null;null!=t.batchSize&&(r=t.batchSize),this.batchInputShape=[r,t.inputDim]}this.units=t.units,Ar(this.units,"units"),this.activation=uu(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=yn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=yn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=fr(t.kernelConstraint),this.biasConstraint=fr(t.biasConstraint),this.kernelRegularizer=vn(t.kernelRegularizer),this.biasRegularizer=vn(t.biasRegularizer),this.activityRegularizer=vn(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const r=(t=Ot(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(t){const r=(t=Ot(t)).slice();return r[r.length-1]=this.units,r}call(t,r){return L(()=>{this.invokeCallHook(t,r);const s=Ge(t),o=jG(this.activation.getClassName());let i;return null!=o?i=oa(s,this.kernel.read(),o,this.bias?this.bias.read():null):(i=oa(s,this.kernel.read()),null!=this.bias&&(i=bi(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const t={units:this.units,activation:lu(this.activation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),biasInitializer:Tn(this.biasInitializer),kernelRegularizer:Jt(this.kernelRegularizer),biasRegularizer:Jt(this.biasRegularizer),activityRegularizer:Jt(this.activityRegularizer),kernelConstraint:hr(this.kernelConstraint),biasConstraint:hr(this.biasConstraint)},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Dense",e})()),oe((()=>{class e extends yt{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=Ot(t);for(const r of t.slice(1))if(null==r)throw new $(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],su(t,1)]}call(t,r){return L(()=>{this.invokeCallHook(t,r);let s=Ge(t);if("channelsFirst"===this.dataFormat&&s.rank>1){const o=[0];for(let i=2;i<s.rank;++i)o.push(i);o.push(1),s=Ct(s,o)}return function HIe(e){if(e.rank<=1)throw new $(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const n=[e.shape[0],su(e.shape,1)];return O(e,n)}(s)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(t,r),t}}return e.className="Flatten",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.supportsMasking=!0,this.activation=uu(t.activation)}call(t,r){return L(()=>{this.invokeCallHook(t,r);const s=Ge(t);return this.activation.apply(s)})}getConfig(){const t={activation:lu(this.activation)},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Activation",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,r){return L(()=>function UIe(e,n){return L(()=>{if(2!==e.shape.length)throw new $(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);return ER(xv(e,1),[1,n,1])})}(t=Ge(t),this.n))}getConfig(){const t={n:this.n},r=super.getConfig();return Object.assign(t,r),t}}return e.className="RepeatVector",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.targetShape=t.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,r){const s="Total size of new array must be unchanged.",o=r.slice();let i=1,a=null;for(let u=0;u<o.length;++u){const c=o[u];if(this.isUnknown(c)){if(null!==a)throw new $("Can only specifiy one unknown dimension.");a=u}else i*=c}const l=su(t);if(null!==a){if(0===i||l%i!=0)throw new $(s);o[a]=l/i}else if(l!==i)throw new $(s);return o}computeOutputShape(t){let r=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){r=!0;break}return r?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,r){return L(()=>{this.invokeCallHook(t,r);const s=Ge(t),o=s.shape,i=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return O(s,i)})}getConfig(){const t={targetShape:this.targetShape},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Reshape",e})()),oe((()=>{class e extends yt{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const r=yi(1,t.dims.length+1);if(!wt(t.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new dr({ndim:this.dims.length+1})]}computeOutputShape(t){const r=(t=Ot(t)).slice();return this.dims.forEach((s,o)=>{r[o+1]=t[s]}),r}call(t,r){return Ct(Ge(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Permute",e})()),oe((()=>{class e extends yt{constructor(t){super(t??{}),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,t),r}computeMask(t,r){const s=Ge(t);return Xy(Vc(s,this.maskValue),-1)}call(t,r){return L(()=>{this.invokeCallHook(t,r);const s=Ge(t),a=Xy(Vc(s,this.maskValue),-1,!0);return M(s,pe(a,s.dtype))})}}return e.className="Masking",e})()),oe((()=>{class e extends yt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let r=null;null!=t.batchSize&&(r=t.batchSize),this.batchInputShape=null==t.inputLength?[r,null]:[r].concat(zt(t.inputLength))}this.inputDim=t.inputDim,Ar(this.inputDim,"inputDim"),this.outputDim=t.outputDim,Ar(this.outputDim,"outputDim"),this.embeddingsInitializer=yn(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=vn(t.embeddingsRegularizer),this.activityRegularizer=vn(t.activityRegularizer),this.embeddingsConstraint=fr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,r){return L(()=>this.maskZero?(t=Ge(t),Vc(t,_t(t))):null)}computeOutputShape(t){if(t=Ot(t),null==this.inputLength)return[...t,this.outputDim];const r=zt(this.inputLength);if(r.length!==t.length-1)throw new $(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let o=0;o<r.length;++o){const i=r[o],a=t[o+1];if(null!=i&&null!=a&&i!==a)throw new $(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==i&&(r[s]=a),s++}}return[t[0],...r,this.outputDim]}call(t,r){return L(()=>{this.invokeCallHook(t,r);let s=Ge(t);"int32"!==s.dtype&&(s=sa(s,"int32"));const o=eq(this.embeddings.read(),O(s,[s.size]));return O(o,Ot(this.computeOutputShape(s.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Tn(this.embeddingsInitializer),embeddingsRegularizer:Jt(this.embeddingsRegularizer),activityRegularizer:Jt(this.activityRegularizer),embeddingsConstraint:hr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Embedding",e})());class qc extends yt{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new rt}computeElementwiseOpOutputShape(n,t){if(null==n||null==t)return null;if(n.length<t.length)return this.computeElementwiseOpOutputShape(t,n);if(0===t.length)return n;const r=n.slice(0,n.length-t.length);for(let s=0;s<t.length;++s){const o=n[n.length-t.length+s],i=t[s];if(null==o||null==i||o<0||i<0)r.push(null);else if(1===o)r.push(i);else if(1===i)r.push(o);else{if(o!==i)throw new $("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(t));r.push(o)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[Ot(n)]),n.length<2)throw new $(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let t=[];for(const o of n)null!=o&&null!==o[0]&&t.push(o[0]);if(t=ru(t),t.length>1)throw new $(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=null==n[0]?null:n[0].slice(1);for(let o=1;o<n.length;++o){const i=null==n[o]?null:n[o].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=n.map(o=>o.length);this.reshapeRequired=-1!==n.indexOf(null)||1!==ru(s).length}call(n,t){return L(()=>{if(this.reshapeRequired){const r=[],s=n.map(o=>o.rank);if(-1===s.indexOf(null)){const o=ou(s);for(let i of n){const a=i.rank;for(let l=0;l<o-a;++l)i=xv(i,1);r.push(i)}return this.mergeFunction(r)}{let o=!1;for(const l of n){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let f=O(l,[d].concat(su(c.slice(1))));f=Ct(f,[1,0]),f=O(f,h),r.push(f),o=!0}else if(u>1){const c=yi(1,u).concat([0]);r.push(Ct(l,c)),o=!0}else r.push(l)}let i=this.mergeFunction(r);const a=i.rank;if(o)if(null==a){const l=i.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));i=O(Ct(O(i,[-1,c]),[1,0]),d)}else if(a>1){const l=[a-1].concat(yi(0,a-1));i=Ct(i,l)}return i}}return this.mergeFunction(n)})}computeOutputShape(n){let t;t=null==n[0]?null:n[0].slice(1);for(let s=1;s<n.length;++s){const o=null==n[s]?null:n[s].slice(1);t=this.computeElementwiseOpOutputShape(t,o)}let r=[];for(const s of n)null!=s&&null!==s[0]&&r.push(s[0]);return r=ru(r),t=1===r.length?r.concat(t):[null].concat(t),t}computeMask(n,t){return L(()=>{if(null==t)return null;if(!Array.isArray(t))throw new $("`mask` should be an Array");if(!Array.isArray(n))throw new $("`inputs` should be an Array");if(t.length!==n.length)throw new $(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${t.length})`);if(t.every(s=>null==s))return null;let r=(t=t.map(s=>null==s?s:jn(s,0)))[0];for(let s=1;s<t.length-1;++s)r=mi(r,t[s]);return r})}}function Tv(e,n){for(;e<0;)e+=n;return e}function kv(e,n,t,r,s,o=.001){let i;if(2===e.rank)i=Qk(e,n,t,r,s,o);else if(3===e.rank)i=Jk(e,n,t,r,s,o);else{if(4!==e.rank)throw new rt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=eA(e,n,t,r,s,o)}return i}function BI(e,n,t,r,s,o){return L(()=>{let i;Gn(s),qG(o),Eo(r),null==t&&(t=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),e=JR(e,s);const a="same"===r?"same":"valid";return i="max"===o?av(e,n,t,a):Jy(e,n,t,a),"channelsFirst"===s&&(i=Ct(i,[0,3,1,2])),i})}function e6(e,n,t,r,s,o){return L(()=>{let i;Gn(s),qG(o),Eo(r),null==t&&(t=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==o&&(o="max"),e=Uq(e,s);const a="same"===r?"same":"valid";return i="max"===o?IA(e,n,t,a):Zk(e,n,t,a),"channelsFirst"===s&&(i=Ct(i,[0,4,1,2,3])),i})}oe((()=>{class e extends qc{constructor(t){super(t)}mergeFunction(t){return L(()=>{let r=t[0].clone();for(let s=1;s<t.length;++s)r=ne(r,t[s]);return r})}}return e.className="Add",e})()),oe((()=>{class e extends qc{constructor(t){super(t)}mergeFunction(t){return L(()=>{let r=t[0].clone();for(let s=1;s<t.length;++s)r=M(r,t[s]);return r})}}return e.className="Multiply",e})()),oe((()=>{class e extends qc{constructor(t){super(t)}mergeFunction(t){return L(()=>{let r=t[0].clone();for(let s=1;s<t.length;++s)r=ne(r,t[s]);return M(1/t.length,r)})}}return e.className="Average",e})()),oe((()=>{class e extends qc{constructor(t){super(t)}mergeFunction(t){return L(()=>{let r=t[0];for(let s=1;s<t.length;++s)r=ea(r,t[s]);return r})}}return e.className="Maximum",e})()),oe((()=>{class e extends qc{constructor(t){super(t)}mergeFunction(t){return L(()=>{let r=t[0];for(let s=1;s<t.length;++s)r=eu(r,t[s]);return r})}}return e.className="Minimum",e})()),oe((()=>{class e extends qc{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new $("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const o of t)if(null!=o){r=!1;break}if(r)return;const s=[];for(let o=0;o<t.length;++o){const i=t[o].slice();i.splice(this.axis,1);let a=!1;for(const l of s)if(wt(l,i)){a=!0;break}a||s.push(i)}if(s.length>1)throw new $("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return L(()=>_R(t,this.axis))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new $("A `Concatenate` layer should be called on a list of inputs.");const r=t,s=r[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const i of r.slice(1)){if(null==s[o]||null==i[o]){s[o]=null;break}s[o]+=i[o]}return s}computeMask(t,r){if(null==r)return null;if(!Array.isArray(r))throw new $("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new $("`inputs` should be an array for Concatenate");if(r.length!==t.length)throw new $(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${t.length})`);return L(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const o=[];for(let a=0;a<t.length;++a)o.push(null==r[a]?pe(Zs(t[a]),"bool"):r[a].rank<t[a].rank?jn(r[a],-1):r[a]);const i=Un(o,this.axis);return FC(i,-1,!1)})}getConfig(){const t={axis:this.axis},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Concatenate",e})()),oe((()=>{class e extends qc{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){S(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=t[0],s=t[1];if(r.length>3||s.length>3)throw new rt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);if(r[o[0]]!==s[o[1]])throw new $(`Dimension incompatibility: ${r[o[0]]} !== ${s[o[1]]}`)}mergeFunction(t){if(2!==t.length)throw new $(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let o,r=t[0],s=t[1];return o=Array.isArray(this.axes)?this.axes.map((i,a)=>Tv(i,t[a].shape.length)):[Tv(this.axes,r.shape.length),Tv(this.axes,s.shape.length)],this.normalize&&(r=kI(r,o[0]),s=kI(s,o[1])),function d_e(e,n,t){if(e.shape.length>3||n.shape.length>3)throw new rt("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),S(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),"number"==typeof t&&(t=[t,t]),"complex64"===e.dtype||"complex64"===n.dtype)throw new rt("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=n.shape.length;null==t&&(t=[r-1,s-2]);const o=t;return L(()=>{let i,a;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);n=O(n,n.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);e=O(e,e.shape.concat(l))}else i=0;if(a=2===e.shape.length&&2===n.shape.length?o[0]===o[1]?De(M(e,n),o[0]):De(M(Ct(e,[1,0]),n),o[1]):at(e,n,o[0]!==e.shape.length-1,o[1]===n.shape.length-1),i>0){let l;l=r>s?r+s-3:r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);a=Qs(a,u)}return 1===a.shape.length&&(a=jn(a,1)),a})}(r,s,o)}interpretAxes(t,r){let s;return s=Array.isArray(this.axes)?this.axes:[Tv(this.axes,t.length),Tv(this.axes,r.length)],s}computeOutputShape(t){S(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=t[0].slice(),s=t[1].slice();if(r.length>3||s.length>3)throw new rt("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(r,s);r.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const i=r.concat(s);return 1===i.length&&i.push(1),i}computeMask(t,r){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(t,r),t}}return e.className="Dot",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,t),r}call(t,r){return L(()=>{this.invokeCallHook(t,r);const s=Ge(t);return Iv(()=>ne(II(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return e.className="GaussianNoise",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),r={rate:this.rate};return Object.assign(r,t),r}call(t,r){return L(()=>{this.invokeCallHook(t,r);const s=Ge(t);return this.rate>0&&this.rate<1?Iv(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return M(s,II(s.shape,1,i))},()=>s,r.training||!1):s})}}return e.className="GaussianDropout",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||Ge(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),r={rate:this.rate};return Object.assign(r,t),r}call(t,r){return L(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t);return Iv(()=>{const i=Ge(t),u=-1.7580993408473766;let c=Ha(tu(s),this.rate);c=sa(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,f=ne(M(i,c),M(ne(c,-1),u));return ne(M(f,d),h)},()=>Ge(t),r.training||!1)}return t})}}return e.className="AlphaDropout",e})()),oe((()=>{class e extends yt{constructor(t){null==t&&(t={}),super(t),this.supportsMasking=!0,this.axis=null==t.axis?-1:t.axis,this.momentum=null==t.momentum?.99:t.momentum,this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=yn(t.betaInitializer||"zeros"),this.gammaInitializer=yn(t.gammaInitializer||"ones"),this.movingMeanInitializer=yn(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=yn(t.movingVarianceInitializer||"ones"),this.betaConstraint=fr(t.betaConstraint),this.gammaConstraint=fr(t.gammaConstraint),this.betaRegularizer=vn(t.betaRegularizer),this.gammaRegularizer=vn(t.gammaRegularizer)}build(t){t=Ot(t);const r=this.axis>=0?this.axis:this.axis+t.length,s=t[r];if(null==s)throw new $(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new dr({ndim:t.length,axes:{[r]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,r){return L(()=>{const s=null!=r.training&&r.training,o=Ge(t),i=o.shape,a=i.length,l=yi(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);const c=Uc(1,a);c[u]=i[u];const d=l.slice();d.sort();const h=!wt(d,yi(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const b=O(this.movingMean.read(),c),w=O(this.movingVariance.read(),c),x=this.center?O(this.beta.read(),c):null,I=this.scale?O(this.gamma.read(),c):null;return kv(o,b,w,x,I,this.epsilon)}return kv(o,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,m,g]=function p_e(e,n,t,r,s=.001){return wt(r.slice().sort(),yi(0,e.rank-1))?function h_e(e,n,t,r,s=.001){return L(()=>{const o=lv(e,r),i=o.mean,a=o.variance;return[kv(e,i,a,t,n,s),i,a]})}(e,n,t,r,s):function f_e(e,n,t,r,s=.001){return L(()=>{const o=lv(e,r),i=o.mean,a=o.variance,l=[];for(const p of yi(0,e.rank))-1!==r.indexOf(p)?l.push(1):l.push(e.shape[p]);const u=O(i,l),c=O(a,l),d=null==n?null:O(n,l),h=null==t?null:O(t,l);return[kv(e,u,c,h,d,s),i,a]})}(e,n,t,r,s)}(o,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(b,w,x)=>{L(()=>{const I=1-x,_=b.read(),D=M(Ce(_,w),I);b.write(Ce(_,D))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tn(this.betaInitializer),gammaInitializer:Tn(this.gammaInitializer),movingMeanInitializer:Tn(this.movingMeanInitializer),movingVarianceInitializer:Tn(this.movingVarianceInitializer),betaRegularizer:Jt(this.betaRegularizer),gammaRegularizer:Jt(this.gammaRegularizer),betaConstraint:hr(this.betaConstraint),gammaConstraint:hr(this.gammaConstraint)},r=super.getConfig();return Object.assign(t,r),t}}return e.className="BatchNormalization",e})()),oe((()=>{class e extends yt{constructor(t){if(null==t&&(t={}),super(t),this.axis=null==t.axis?-1:t.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==t.epsilon?.001:t.epsilon,this.center=null==t.center||t.center,this.scale=null==t.scale||t.scale,this.betaInitializer=yn(t.betaInitializer||"zeros"),this.gammaInitializer=yn(t.gammaInitializer||"ones"),this.betaRegularizer=vn(t.betaRegularizer),this.gammaRegularizer=vn(t.gammaRegularizer),this.supportsMasking=!0}build(t){const r=(t=Ot(t)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(const i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==ru(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(i=>t[i]),o=!0;this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,o):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,o):null,this.built=!0}call(t,r){const s=Ge(t),o=s.shape,i=o.length;return L(()=>{let{mean:l,variance:u}=lv(s,this.axis,!0);const c=Uc(1,i);for(const g of this.axis)c[g]=o[g];const d=g=>null!=g&&g.shape.length!==i?O(g,c):g;let h=this.scale?d(this.gamma.read()):null,f=this.center?d(this.beta.read()):null;const p=[],m=[];for(let g=0;g<i;++g)-1!==this.axis.indexOf(g)?(p.push(o[g]),m.push(1)):(p.push(1),m.push(o[g]));return l=Co(l,p),u=Co(u,p),null!=h&&(h=Co(h,m)),null!=f&&(f=Co(f,m)),kv(s,l,u,f,h,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tn(this.betaInitializer),gammaInitializer:Tn(this.gammaInitializer),betaRegularizer:Jt(this.betaRegularizer),gammaRegularizer:Jt(this.gammaRegularizer)},r=super.getConfig();return Object.assign(t,r),t}}return e.className="LayerNormalization",e})()),oe((()=>{class e extends yt{constructor(t){if(null==t&&(t={}),super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,null==t.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof t.padding)this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,2!==t.padding.length)throw new $(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let r,s;if("number"==typeof t.padding[0])r=[t.padding[0],t.padding[0]],s=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,2!==t.padding[0].length)throw new $(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(r=t.padding[0],2!==t.padding[1].length)throw new $(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);s=t.padding[1]}this.padding=[r,s]}this.inputSpec=[new dr({ndim:4})]}computeOutputShape(t){let r,s;return t=Ot(t),"channelsFirst"===this.dataFormat?(r=null!=t[2]&&t[2]>=0?t[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=t[3]&&t[3]>=0?t[3]+this.padding[1][0]+this.padding[1][1]:null,[t[0],t[1],r,s]):(r=null!=t[1]&&t[1]>=0?t[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=t[2]&&t[2]>=0?t[2]+this.padding[1][0]+this.padding[1][1]:null,[t[0],r,s,t[3]])}call(t,r){return L(()=>function m_e(e,n,t){return L(()=>{if(4!==e.rank)throw new $(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new $("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==t&&(t="channelsLast"),"channelsLast"!==t&&"channelsFirst"!==t)throw new $(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===t?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],ja(e,r)})}(Ge(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(t,r),t}}return e.className="ZeroPadding2D",e})());class t6 extends yt{constructor(n){if(null==n.poolSize&&(n.poolSize=2),super(n),"number"==typeof n.poolSize)this.poolSize=[n.poolSize];else{if(!Array.isArray(n.poolSize)||1!==n.poolSize.length||"number"!=typeof n.poolSize[0])throw new $(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);this.poolSize=n.poolSize}if(Ar(this.poolSize,"poolSize"),null==n.strides)this.strides=this.poolSize;else if("number"==typeof n.strides)this.strides=[n.strides];else{if(!Array.isArray(n.strides)||1!==n.strides.length||"number"!=typeof n.strides[0])throw new $(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);this.strides=n.strides}Ar(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,Eo(this.padding),this.inputSpec=[new dr({ndim:3})]}computeOutputShape(n){const t=Ci((n=Ot(n))[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],t,n[2]]}call(n,t){return L(()=>{this.invokeCallHook(n,t),n=xv(Ge(n),2);const r=this.poolingFunction(Ge(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Qs(r,[2])})}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(n,t),n}}oe((()=>{class e extends t6{constructor(t){super(t)}poolingFunction(t,r,s,o,i){return Gn(i),Eo(o),BI(t,r,s,o,i,"max")}}return e.className="MaxPooling1D",e})()),oe((()=>{class e extends t6{constructor(t){super(t)}poolingFunction(t,r,s,o,i){return Gn(i),Eo(o),BI(t,r,s,o,i,"avg")}}return e.className="AveragePooling1D",e})());class n6 extends yt{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(2!==n.strides.length)throw new $(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];Ar(this.poolSize,"poolSize"),Ar(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Gn(this.dataFormat),Eo(this.padding),this.inputSpec=[new dr({ndim:4})]}computeOutputShape(n){n=Ot(n);let t="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2];return t=Ci(t,this.poolSize[0],this.padding,this.strides[0]),r=Ci(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[n[0],n[1],t,r]:[n[0],t,r,n[3]]}call(n,t){return L(()=>(this.invokeCallHook(n,t),this.poolingFunction(Ge(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(n,t),n}}oe((()=>{class e extends n6{constructor(t){super(t)}poolingFunction(t,r,s,o,i){return Gn(i),Eo(o),BI(t,r,s,o,i,"max")}}return e.className="MaxPooling2D",e})()),oe((()=>{class e extends n6{constructor(t){super(t)}poolingFunction(t,r,s,o,i){return Gn(i),Eo(o),BI(t,r,s,o,i,"avg")}}return e.className="AveragePooling2D",e})());class r6 extends yt{constructor(n){if(null==n.poolSize&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],null==n.strides)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(3!==n.strides.length)throw new $(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];Ar(this.poolSize,"poolSize"),Ar(this.strides,"strides"),this.padding=null==n.padding?"valid":n.padding,this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Gn(this.dataFormat),Eo(this.padding),this.inputSpec=[new dr({ndim:5})]}computeOutputShape(n){n=Ot(n);let t="channelsFirst"===this.dataFormat?n[2]:n[1],r="channelsFirst"===this.dataFormat?n[3]:n[2],s="channelsFirst"===this.dataFormat?n[4]:n[3];return t=Ci(t,this.poolSize[0],this.padding,this.strides[0]),r=Ci(r,this.poolSize[1],this.padding,this.strides[1]),s=Ci(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[n[0],n[1],t,r,s]:[n[0],t,r,s,n[4]]}call(n,t){return L(()=>(this.invokeCallHook(n,t),this.poolingFunction(Ge(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(n,t),n}}oe((()=>{class e extends r6{constructor(t){super(t)}poolingFunction(t,r,s,o,i){return Gn(i),Eo(o),e6(t,r,s,o,i,"max")}}return e.className="MaxPooling3D",e})()),oe((()=>{class e extends r6{constructor(t){super(t)}poolingFunction(t,r,s,o,i){return Gn(i),Eo(o),e6(t,r,s,o,i,"avg")}}return e.className="AveragePooling3D",e})());class s6 extends yt{constructor(n){super(n),this.inputSpec=[new dr({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,t){throw new rt}}oe((()=>{class e extends s6{constructor(t){super(t||{})}call(t,r){return L(()=>{const s=Ge(t);return Nn(s,1)})}}return e.className="GlobalAveragePooling1D",e})()),oe((()=>{class e extends s6{constructor(t){super(t||{})}call(t,r){return L(()=>{const s=Ge(t);return xo(s,1)})}}return e.className="GlobalMaxPooling1D",e})());class o6 extends yt{constructor(n){super(n),this.dataFormat=null==n.dataFormat?"channelsLast":n.dataFormat,Gn(this.dataFormat),this.inputSpec=[new dr({ndim:4})]}computeOutputShape(n){return"channelsLast"===this.dataFormat?[n[0],n[3]]:[n[0],n[1]]}call(n,t){throw new rt}getConfig(){const n={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(n,t),n}}oe((()=>{class e extends o6{call(t,r){return L(()=>{const s=Ge(t);return Nn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return e.className="GlobalAveragePooling2D",e})()),oe((()=>{class e extends o6{call(t,r){return L(()=>{const s=Ge(t);return xo(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return e.className="GlobalMaxPooling2D",e})());class i6 extends yt{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(n){null!=this.layer&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){const n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(n,t),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,t,r={}){const o=Za(t.layer,r);delete t.layer;const i={layer:o};return Object.assign(i,t),new n(i)}}oe((()=>{class e extends i6{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=Ot(t)).length<3)throw new $(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const r=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(t)}computeOutputShape(t){const r=[(t=Ot(t))[0]].concat(t.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],t[1]].concat(s.slice(1))}call(t,r){return L(()=>Kq((a,l)=>[Ge(this.layer.call(a,r)),[]],t=Ge(t),[],!1,null,null,!1,!0)[1])}}return e.className="TimeDistributed",e})()),oe((()=>{class e extends i6{constructor(t){super(t);const r=t.layer.getConfig(),s={};s.className=t.layer.getClassName(),s.config=r,this.forwardLayer=Za(s),r.goBackwards=!0!==r.goBackwards;const o={};if(o.className=t.layer.getClassName(),o.config=r,this.backwardLayer=Za(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,function g_e(e){Hc(FIe,"BidirectionalMergeMode",e)}(this.mergeMode),t.weights)throw new rt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const s=Math.floor(t.length/2);this.forwardLayer.setWeights(t.slice(0,s)),this.backwardLayer.setWeights(t.slice(s))}computeOutputShape(t){let s,o,i,r=this.forwardLayer.computeOutputShape(t);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(i=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,o=[s]):o=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?o.concat(i).concat(i.slice()):[s].concat(i).concat(i.slice()):$s(o)}apply(t,r){let s=null==r?null:r.initialState,o=null==r?null:r.constants;null==r&&(r={});const i=qq(t,s,o,this.numConstants);if(t=i.inputs,s=i.initialState,o=i.constants,Array.isArray(t)&&(s=t.slice(1),t=t[0]),(null==s||0===s.length)&&null==o)return super.apply(t,r);const a=[],l=[];if(null!=s){const c=s.length;if(c%2>0)throw new $("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new dr({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=o)throw new rt("Support for constants in Bidirectional layers is not implemented yet.");const u=a[0]instanceof aa;for(const c of a)if(c instanceof aa!==u)throw new $("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[t].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(c,r);return this.inputSpec=h,f}return super.apply(t,r)}call(t,r){return L(()=>{const s=r.initialState;let o,i,a,l;if(null==s)o=this.forwardLayer.call(t,r),i=this.backwardLayer.call(t,r);else{const u=s.slice(0,s.length/2),c=s.slice(s.length/2);o=this.forwardLayer.call(t,Object.assign(r,{initialState:u})),i=this.backwardLayer.call(t,Object.assign(r,{initialState:c}))}return this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(i.slice(1))),o=o[0],i=i[0]),this.returnSequences&&(i=Io(i,1)),"concat"===this.mergeMode?l=_R([o,i]):"sum"===this.mergeMode?l=ne(o,i):"ave"===this.mergeMode?l=M(.5,ne(o,i)):"mul"===this.mergeMode?l=M(o,i):null==this.mergeMode&&(l=[o,i]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){jc(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),jc(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(t,r),t}static fromConfig(t,r){const s=Za(r.layer);if(delete r.layer,null!=r.numConstants)throw new rt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=r;return o.layer=s,new t(o)}}return e.className="Bidirectional",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.scale=t.scale,this.offset=t.offset?t.offset:0}getConfig(){const t={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(t,r),t}call(t,r){return L(()=>("float32"!==(t=Ge(t)).dtype&&(t=sa(t,"float32")),ne(M(t,this.scale),this.offset)))}}return e.className="Rescaling",e})());const{resizeBilinear:v_e,cropAndResize:b_e}=ms;oe((()=>{class e extends yt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,r,s,o,i,a,l,u){return L(()=>{let c,d=!1;const g=[r/a,s/l,(o+r)/a,(i+s)/l],y=[];3===t.rank?(d=!0,c=ps([t])):c=t;for(let I=0;I<c.shape[0];I++)y.push(g);const v=cs(y,[y.length,4]),b=Ga(0,y.length,1,"int32"),x=b_e(c,v,b,[o,i],"nearest");return sa(d?Ge(So(x)):x,u)})}upsize(t,r,s,o){return L(()=>sa(v_e(t,[r,s]),o))}call(t,r){return L(()=>{const s=Ge(t),o=s.dtype,i=s.shape,a=i[i.length-3],l=i[i.length-2];let u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),0===c&&(c=1)),u>=0&&c>=0?this.centerCrop(s,u,c,this.height,this.width,a,l,o):this.upsize(t,this.height,this.width,o)})}getConfig(){const t={height:this.height,width:this.width},r=super.getConfig();return Object.assign(t,r),t}computeOutputShape(t){const s=(t=Ot(t)).length-2;return t[t.length-3]=this.height,t[s]=this.width,t}}return e.className="CenterCrop",e})()),oe((()=>{class e extends yt{constructor(t){super(t),this.numTokens=t.numTokens,this.outputMode=t.outputMode?t.outputMode:"multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(t,r),t}computeOutputShape(t){return null==(t=Ot(t))?[this.numTokens]:"oneHot"===this.outputMode&&1!==t[t.length-1]?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,r){return L(()=>{let s;if("int32"!==(t=Ge(t)).dtype&&(t=sa(t,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new $(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=Ge(r.countWeights)}const o=xo(t),i=Hf(t),a=fs(this.numTokens,o).bufferSync().get(0),l=Ha(i,0).bufferSync().get(0);if(!a||!l)throw new $(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function w_e(e,n,t,r){let s=Ge(e);if("int32"!==s.dtype&&(s=sa(s,"int32")),"int"===n)return s;const o=s.shape;if(0===s.rank&&(s=jn(s,-1)),"oneHot"===n&&1!==s.shape[s.shape.length-1]&&(s=jn(s,-1)),s.rank>2)throw new $(`When outputMode is not int, maximum output rank is 2 Received outputMode ${n} and input shape ${o} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(n);let l;if(l=BC(s,typeof r<"u"&&"count"===n?r:[],t,i),"tfIdf"!==n)return l;if(r)return M(l,r);throw new $("When outputMode is 'tfIdf', weights must be provided.")}(t,this.outputMode,this.numTokens,s)})}}return e.className="CategoryEncoding",e})());const a6=new Set(["bilinear","nearest"]);oe((()=>{class e extends yt{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!a6.has(t.interpolation))throw new $(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){return t=Ot(t),[this.height,this.width,t[2]]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(t,r),t}call(t,r){return L(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return ms.resizeBilinear(t,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return ms.resizeNearestNeighbor(t,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...a6]} are supported`)})}}return e.className="Resizing",e})());let C_e=(()=>{class e{constructor(t){this.seed=t}next(){if(void 0!==this.seed)return this.seed++}}return e.className="RandomSeed",e})(),I_e=(()=>{class e extends yt{constructor(t){super(t),this.randomGenerator=new C_e(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(t,r),t}}return e.className="BaseRandomLayer",e})();const l6=new Set(["bilinear","nearest"]);oe((()=>{class e extends I_e{constructor(t){super(t);const{factor:r,interpolation:s="bilinear"}=t;if(this.factor=r,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new $(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new $(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new $(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(s){if(!l6.has(s))throw new $(`Invalid interpolation parameter: ${s} is not implemented`);this.interpolation=s}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(t,r),t}computeOutputShape(t){return t=Ot(t),[this.imgHeight,-1,t[2]]}call(t,r){return L(()=>{const s=Ge(t);this.imgHeight=s.shape[s.shape.length-3];const o=s.shape[s.shape.length-2];this.widthFactor=tu([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*o;i=Math.round(i);const a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return ms.resizeBilinear(t,a);case"nearest":return ms.resizeNearestNeighbor(t,a);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...l6]} are supported`)}})}}return e.className="RandomWidth",e})()),V().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var f6,No=function(e){return e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF",e}(No||{});!function(e){let n;var t;(t=n=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(f6||(f6={}));const lM={};function p6(e){return lM[e]}function C(e,n,t,r,s){const o=n.inputParams[e];if(o&&void 0!==o.inputIndexStart){const a=o.inputIndexStart,l=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?a+1:o.inputIndexEnd,u=a<0?n.inputNames.length+a:a;if("tensor"===o.type)return Hr(n.inputNames[u],t,r,s);if("tensors"===o.type){const h=n.inputs.slice(a,l);return n.inputNames.slice(a,l).filter((p,m)=>{var g;return"NoOp"!==(null===(g=h[m])||void 0===g?void 0:g.op)}).map(p=>Hr(p,t,r,s))}const c=Hr(n.inputNames[u],t,r,s),d=c.dataSync();return"number"===o.type?d[0]:go(c.shape,d)}const i=n.attrParams[e];return i&&i.value}function Hr(e,n,t,r){const[s,o]=Js(e,t);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const i=t.currentContextIds.find(a=>!!n[UI(s,a)]);return void 0!==i?n[UI(s,i)][o]:void 0}function m6(e,n,t){return n[UI(e,t.currentContextId)]}function Qa(e,n){const[t,r,s]=Js(e,n);return[UI(t,n&&n.currentContextId),r,s]}function UI(e,n){return n?`${e}-${n}`:e}function Js(e,n){if(""===e)return["",0,void 0];const t=null!=n&&null!=n.parseNodeNameCache;if(t){const o=n.parseNodeNameCache.get(e);if(null!=o)return o}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const i=3===r.length?r[1]:void 0;s=[r[0],Number(r[r.length-1]),i]}return t&&n.parseNodeNameCache.set(e,s),s}function WI(e,n,t){let r=C("pad",e,n,t);if("explicit"===r){r=C("explicitPaddings",e,n,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function Ja(e){return e.kept?e:Zi(e)}const N_e=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],T_e=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],k_e=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],A_e=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],R_e=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],M_e=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],O_e=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],F_e=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],$_e=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],P_e=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],L_e=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],V_e=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],B_e=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],z_e=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],U_e=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],W_e=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],H_e=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],j_e=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],G_e=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class g6{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[Xn,Ao,no,Nt,Ft,$t,ae,ee,A,we,He,Tt,gt,Pt,An,$n,rr,wn,ns].map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(n,t={}){const s=[],o=[],i=[],a=n.node.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):"Const"===g.op?o.push(m[g.name]):(null==g.input||0===g.input.length)&&i.push(m[g.name]),m),{});let l=[];const u=[];let c={},d={};null!=t&&(c=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const h=Object.keys(a);h.forEach(m=>{const g=a[m];g.inputNames.forEach((y,v)=>{const[b,,w]=Qa(y),x=a[b];if(null!=x.outputs){const I=x.outputs.indexOf(w);-1!==I&&(g.inputNames[v]=`${b}:${I}`)}g.inputs.push(x),x.children.push(g)})}),0===Object.keys(d).length?h.forEach(m=>{const g=a[m];0===g.children.length&&u.push(g)}):Object.keys(d).forEach(m=>{const[g]=Qa(m),y=a[g];null!=y&&(y.signatureKey=d[m],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(m=>{const[g]=Qa(m),y=a[g];y&&(y.signatureKey=c[m],l.push(y))}):l=s;let f={};null!=n.library&&null!=n.library.function&&(f=n.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:u,weights:o,placeholders:s,signature:t,functions:f};return i.length>0&&(p.initNodes=i),p}mapSignatureEntries(n){return Object.keys(n||{}).reduce((t,r)=>(t[n[r].name]=r,t),{})}mapNode(n){const t=p6(n.op)||this.opMappers[n.op]||{};null==n.attr&&(n.attr={});const r={name:n.name,op:n.op,category:t.category,inputNames:(n.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:n.attr,outputs:t.outputs};return null!=t.inputs&&(r.inputParams=t.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),null!=t.attrs&&(r.attrParams=t.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=uM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=uM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=yM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=yM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=dM(n.attr,o.tfName,o.defaultValue||0),void 0===a&&o.tfDeprecatedName&&(a=dM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=gM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=gM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=cM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=cM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=bM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=bM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=mM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=mM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=vM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=vM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=fM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=fM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=pM(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=pM(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=v6(n.attr,o.tfName,o.defaultValue),void 0===a&&o.tfDeprecatedName&&(a=v6(n.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${n.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(n){const t=n.nodeDef,s=[];let o={};null!=t&&(o=t.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const i=[],a=[];n.signature.inputArg.forEach(d=>{const[h]=Qa(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:hM(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,i.push(f),o[h]=f}),Object.keys(o).forEach(d=>{const h=o[d];h.inputNames.forEach((f,p)=>{const[m,,g]=Qa(f),y=o[m];if(null!=y.outputs){const v=y.outputs.indexOf(g);-1!==v&&(h.inputNames[p]=`${m}:${v}`)}h.inputs.push(y),y.children.push(h)})});const u=n.ret;n.signature.outputArg.forEach(d=>{const[h,f]=Qa(u[d.name]),p=o[h];null!=p&&(p.defaultOutput=f,a.push(p))});const c=this.mapArgsToSignature(n);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:[],signature:c}}mapArgsToSignature(n){return{methodName:n.signature.name,inputs:n.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:n.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,n.ret),t),{})}}mapArgToTensorInfo(n,t){let r=n.name;return null!=t&&(r=t[r]),{name:r,dtype:n.type}}}function y6(e,n){const t=Array.isArray(e)?String.fromCharCode.apply(null,e):function q_e(e){const n=V().global;if(typeof n.atob<"u")return n.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return n?t:t.toLowerCase()}function uM(e,n,t,r=!1){const s=e[n];return null!=s?y6(s.s,r):t}function cM(e,n,t){const r=e[n];return r?r.b:t}function dM(e,n,t){const r=e[n]||{},s=null!=r.i?r.i:null!=r.f?r.f:t;return"number"==typeof s?s:parseInt(s,10)}function hM(e){switch("string"==typeof e&&(e=No[e]),e){case No.DT_FLOAT:case No.DT_HALF:return"float32";case No.DT_INT32:case No.DT_INT64:case No.DT_INT8:case No.DT_UINT8:return"int32";case No.DT_BOOL:return"bool";case No.DT_DOUBLE:return"float32";case No.DT_STRING:return"string";case No.DT_COMPLEX64:case No.DT_COMPLEX128:return"complex64";default:return null}}function v6(e,n,t){const r=e[n];return r&&r.func?r.func.name:t}function fM(e,n,t){const r=e[n];return r&&r.type?hM(r.type):t}function pM(e,n,t){const r=e[n];return r&&r.list&&r.list.type?r.list.type.map(s=>hM(s)):t}function b6(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(n=>"number"==typeof n.size?n.size:parseInt(n.size,10)):[]}function mM(e,n,t){const r=e[n];return r&&r.shape?b6(r.shape):t}function gM(e,n,t){const r=e[n];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):t}function yM(e,n,t,r=!1){const s=e[n];return s&&s.list&&s.list.s?s.list.s.map(o=>y6(o,r)):t}function vM(e,n,t){const r=e[n];return r&&r.list&&r.list.shape?r.list.shape.map(s=>b6(s)):t}function bM(e,n,t){const r=e[n];return r&&r.list&&r.list.b?r.list.b:t}class K_e{constructor(n,t,r){this.node=n,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=n.inputNames.map(s=>this.getInput(s)),null!=n.rawAttrs&&(this.attrs=Object.keys(n.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(n){return Hr(n,this.tensorMap,this.context)}getAttr(n,t){const r=this.node.rawAttrs[n];if(null!=r.tensor)return Hr(n,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return dM(this.node.rawAttrs,n,t);if(null!=r.s)return uM(this.node.rawAttrs,n,t);if(null!=r.b)return cM(this.node.rawAttrs,n,t);if(null!=r.shape)return mM(this.node.rawAttrs,n,t);if(null!=r.type)return fM(this.node.rawAttrs,n,t);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return gM(this.node.rawAttrs,n,t);if(null!=r.list.s)return yM(this.node.rawAttrs,n,t);if(null!=r.list.shape)return vM(this.node.rawAttrs,n,t);if(null!=r.list.b)return bM(this.node.rawAttrs,n,t);if(null!=r.list.type)return pM(this.node.rawAttrs,n,t)}return t}}function qo(e,n,t=""){if("number"!=typeof e&&"number"!=typeof n){S(e.length===n.length,()=>t+` Shapes ${e} and ${n} must match`);for(let r=0;r<e.length;r++){const s=e[r],o=n[r];S(s<0||o<0||s===o,()=>t+` Shapes ${e} and ${n} must match`)}}}function w6(e){return!("number"==typeof e||e.some(n=>n<0))}function Av(e,n,t){let r=wM(e,t);const s=!w6(r);if(s&&0===n.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&n.forEach(o=>{r=wM(o.shape,r)}),!w6(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function wM(e,n){if("number"==typeof e)return n;if("number"==typeof n)return e;if(e.length!==n.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${n}`);const t=[];for(let r=0;r<e.length;++r){const s=e[r],o=n[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${e} vs. ${n}`);t[r]=s>=0?s:o}return t}class Z_e{constructor(n,t,r,s,o,i,a){this.name=n,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Re(0),ur(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(n){this.tensors.forEach(t=>{(null==n||!n.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||n>=this.size())throw new Error(`Tried to read from index ${n}, but array size is: ${this.size()}`);const t=this.tensors[n];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${n} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(n){return n.map(t=>this.read(t))}write(n,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||!this.dynamicSize&&n>=this.maxSize)throw new Error(`Tried to write to index ${n}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[n]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),qo(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${n}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been written.`);r.tensor=t,ur(t),r.written=!0,this.tensors[n]=r}writeMany(n,t){if(n.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${n.length} is not the same as tensors size: ${t.length}.`);n.forEach((r,s)=>this.write(r,t[s]))}gather(n,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(n)n=n.slice(0,this.size());else{n=[];for(let s=0;s<this.size();s++)n.push(s)}if(0===n.length)return cs([],[0].concat(this.elementShape));const r=this.readMany(n);return qo(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),ps(r,0)}concat(n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${n}`);if(0===this.size())return cs([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return qo(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Un(r,0)}scatter(n,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(n.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);const r=Math.max(...n);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(n,So(t,0))}split(n,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=n.map(l=>(r+=l,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&n.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${n.length}), and the TensorArray is not marked as dynamically resizeable`);const o=0===r?0:t.size/r,i=[];L(()=>{t=O(t,[1,r,o]);for(let l=0;l<n.length;++l)i[l]=O(Et(t,[0,0===l?0:s[l-1],0],[1,n[l],o]),this.elementShape);return i});const a=[];for(let l=0;l<n.length;l++)a[l]=l;this.writeMany(a,i)}}class Kc{get id(){return this.idTensor.id}constructor(n,t,r,s=-1){this.tensors=n,this.elementShape=t,this.elementDtype=r,n?.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);qo(t,o.shape,"TensorList shape mismatch: "),ur(o)}),this.idTensor=Re(0),this.maxNumElements=s,ur(this.idTensor)}copy(){return new Kc([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(n){this.tensors.forEach(t=>{(null==n||!n.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(n,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);qo(n,this.elementShape,"TensorList shape mismatch: ");const s=Av(this.elementShape,this.tensors,n);return L(()=>{const o=this.tensors.map(i=>O(i,s));return ps(o,0)})}popBack(n,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=Av(this.elementShape,this.tensors,n),s=this.tensors.pop();return s.kept=!1,qo(s.shape,n,"TensorList shape mismatch: "),O(s,r)}pushBack(n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(qo(n.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ur(n),this.tensors.push(n)}resize(n){if(n<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${n}`);if(-1!==this.maxNumElements&&n>this.maxNumElements)throw new Error(`TensorListResize input size ${n} is greater maxNumElement ${this.maxNumElements}.`);const t=new Kc([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=n;for(let r=0;r<Math.min(this.tensors.length,n);++r)t.tensors[r]=this.tensors[r];return t}getItem(n,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(n<0||n>this.tensors.length)throw new Error(`Trying to access element ${n} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[n])throw new Error(`element at index ${n} is null.`);qo(this.tensors[n].shape,t,"TensorList shape mismatch: ");const s=Av(this.elementShape,this.tensors,t);return O(this.tensors[n],s)}setItem(n,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(n<0||-1!==this.maxNumElements&&n>=this.maxNumElements)throw new Error(`Trying to set element ${n} in a list with max ${this.maxNumElements} elements.`);qo(this.elementShape,t.shape,"TensorList shape mismatch: "),ur(t),null!=this.tensors[n]&&(this.tensors[n].kept=!1),this.tensors[n]=t}gather(n,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);qo(this.elementShape,r,"TensorList shape mismatch: "),n=n.slice(0,this.size());const s=Av(this.elementShape,this.tensors,r);return 0===n.length?cs([],[0].concat(s)):L(()=>{const o=n.map(i=>O(this.tensors[i],s));return ps(o,0)})}concat(n,t){if(n&&n!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${n}`);qo(this.elementShape,t,"TensorList shape mismatch: ");const r=Av(this.elementShape,this.tensors,t);return 0===this.size()?cs([],[0].concat(r)):L(()=>{const s=this.tensors.map(o=>O(o,r));return Un(s,0)})}}const nEe=function(){var e=F(function*(n,t,r){switch(n.op){case"If":case"StatelessIf":{const s=C("thenBranch",n,t,r),o=C("elseBranch",n,t,r),i=C("cond",n,t,r),a=C("args",n,t,r);return(yield i.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[o].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=C("body",n,t,r),o=C("cond",n,t,r),i=C("args",n,t,r),a=yield r.functionMap[o].executeFunctionAsync(i,r.tensorArrayMap,r.tensorListMap),l=i.map(d=>d.id);let u=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let c=i;for(;u[0];){const d=c;c=yield r.functionMap[s].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);const h=c.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield r.functionMap[o].executeFunctionAsync(c,r.tensorArrayMap,r.tensorListMap);u=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return c}case"LoopCond":return[Ja(C("pred",n,t,r))];case"Switch":{const s=C("pred",n,t,r);let o=C("data",n,t,r);return o.kept||(o=Ja(o)),(yield s.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const s=n.inputNames.find(o=>void 0!==Hr(o,t,r));return s?[Ja(Hr(s,t,r))]:void 0}case"Enter":{const s=C("frameName",n,t,r),o=C("tensor",n,t,r);return r.enterFrame(s),[Ja(o)]}case"Exit":{const s=C("tensor",n,t,r);return r.exitFrame(),[Ja(s)]}case"NextIteration":{const s=C("tensor",n,t,r);return r.nextIteration(),[Ja(s)]}case"TensorArrayV3":{const s=C("size",n,t,r),o=C("dtype",n,t,r),i=C("elementShape",n,t,r),a=C("dynamicSize",n,t,r),l=C("clearAfterRead",n,t,r),u=C("identicalElementShapes",n,t,r),c=C("name",n,t,r),d=new Z_e(c,o,s,i,u,a,l);return r.addTensorArray(d),[d.idTensor,Re(1)]}case"TensorArrayWriteV3":{const s=C("tensorArrayId",n,t,r),o=C("index",n,t,r),i=C("tensor",n,t,r),a=r.getTensorArray(s.id);return a.write(o,i),[a.idTensor]}case"TensorArrayReadV3":{const s=C("tensorArrayId",n,t,r),o=C("index",n,t,r);return[r.getTensorArray(s.id).read(o)]}case"TensorArrayGatherV3":{const s=C("tensorArrayId",n,t,r),o=C("indices",n,t,r),i=C("dtype",n,t,r);return[r.getTensorArray(s.id).gather(o,i)]}case"TensorArrayScatterV3":{const s=C("tensorArrayId",n,t,r),o=C("indices",n,t,r),i=C("tensor",n,t,r),a=r.getTensorArray(s.id);return a.scatter(o,i),[a.idTensor]}case"TensorArrayConcatV3":{const s=C("tensorArrayId",n,t,r),o=r.getTensorArray(s.id),i=C("dtype",n,t,r);return[o.concat(i)]}case"TensorArraySplitV3":{const s=C("tensorArrayId",n,t,r),o=C("tensor",n,t,r),i=C("lengths",n,t,r),a=r.getTensorArray(s.id);return a.split(i,o),[a.idTensor]}case"TensorArraySizeV3":{const s=C("tensorArrayId",n,t,r);return[Re(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=C("tensorArrayId",n,t,r),o=r.getTensorArray(s.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const s=C("tensorListId",n,t,r),o=C("index",n,t,r),i=C("tensor",n,t,r),a=r.getTensorList(s.id);return a.setItem(o,i),[a.idTensor]}case"TensorListGetItem":{const s=C("tensorListId",n,t,r),o=C("index",n,t,r),i=C("elementShape",n,t,r),a=C("elementDType",n,t,r);return[r.getTensorList(s.id).getItem(o,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=C("indices",n,t,r),l=function eEe(e,n,t,r){if(n.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${e.shape[0]}`);const s=Math.max(...n);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Kc([],t,e.dtype,r),i=So(e,0);return n.forEach((a,l)=>{o.setItem(a,i[l])}),o}(C("tensor",n,t,r),s,C("elementShape",n,t,r),C("numElements",n,t,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=C("elementShape",n,t,r),o=C("elementDType",n,t,r);let i;i="TensorListReserve"===n.op?"numElements":"maxNumElements";const a=C(i,n,t,r),u=function J_e(e,n,t,r){return new Kc([],e,n,r)}(s,o,0,"TensorListReserve"===n.op?-1:a);return r.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=C("tensorListId",n,t,r),o=C("indices",n,t,r),i=C("elementShape",n,t,r),a=C("elementDType",n,t,r);return[r.getTensorList(s.id).gather(o,a,i)]}case"TensorListStack":{const s=C("tensorListId",n,t,r),o=C("elementShape",n,t,r),i=C("elementDType",n,t,r),a=C("numElements",n,t,r);return[r.getTensorList(s.id).stack(o,i,a)]}case"TensorListFromTensor":{const a=function Q_e(e,n,t){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==t)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${t}`);qo(e.shape.slice(1),n,"TensorList shape mismatch: ");const o=So(e);return new Kc(o,n,r)}(C("tensor",n,t,r),C("elementShape",n,t,r),C("elementDType",n,t,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=C("tensorListId",n,t,r),o=r.getTensorList(s.id),i=C("dtype",n,t,r),a=C("elementShape",n,t,r);return[o.concat(i,a)]}case"TensorListPushBack":{const s=C("tensorListId",n,t,r),o=C("tensor",n,t,r),i=r.getTensorList(s.id);return i.pushBack(o),[i.idTensor]}case"TensorListPopBack":{const s=C("tensorListId",n,t,r),o=C("elementShape",n,t,r),i=C("elementDType",n,t,r);return[r.getTensorList(s.id).popBack(o,i)]}case"TensorListSplit":{const s=C("tensor",n,t,r),o=C("elementShape",n,t,r),a=function tEe(e,n,t){let r=0;const s=n.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const i=wM(e.shape.slice(1),t),a=0===r?0:e.size/r,l=L(()=>{const c=[];e=O(e,[1,r,a]);for(let d=0;d<n.length;++d)c[d]=O(Et(e,[0,0===d?0:s[d-1],0],[1,n[d],a]),i);return e.dispose(),c}),u=new Kc([],t,e.dtype,n.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}(s,C("lengths",n,t,r),o);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=C("tensorListId",n,t,r);return[Re(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=C("tensorListId",n,t,r),o=C("size",n,t,r),a=r.getTensorList(s.id).resize(o);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(t,r,s){return e.apply(this,arguments)}}();function x6(e,n,t){const[r,s]=C("fusedOps",e,n,t),o="biasadd"===r,i=!o,a="prelu"===s,l="fusedbatchnorm"===r,u=C("numArgs",e,n,t);if(o){if(a&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=C("strides",e,n,t),d=WI(e,n,t),h=C("dataFormat",e,n,t).toUpperCase(),f=C("dilations",e,n,t);let[p,m]=C("args",e,n,t);return i&&(m=p,p=void 0),{stride:c,pad:d,dataFormat:h,dilations:f,biasArg:p,preluArg:m,activationFunc:s,leakyreluAlpha:C("leakyreluAlpha",e,n,t)}}function xM(e,n,t){return{boxes:C("boxes",e,n,t),scores:C("scores",e,n,t),maxOutputSize:C("maxOutputSize",e,n,t),iouThreshold:C("iouThreshold",e,n,t),scoreThreshold:C("scoreThreshold",e,n,t),softNmsSigma:C("softNmsSigma",e,n,t)}}const oEe=function(){var e=F(function*(n,t,r,s,o=vt){switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c,softNmsSigma:d}=xM(n,t,r),h=yield o.image.nonMaxSuppressionWithScoreAsync(i,a,l,u,c,d);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=xM(n,t,r),d=C("padToMaxOutputSize",n,t,r),h=yield o.image.nonMaxSuppressionPaddedAsync(i,a,l,u,c,d);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:a,maxOutputSize:l,iouThreshold:u,scoreThreshold:c}=xM(n,t,r);return[yield o.image.nonMaxSuppressionAsync(i,a,l,u,c)]}case"Where":{const i=o.cast(C("condition",n,t,r),"bool"),a=[yield o.whereAsync(i)];return i.dispose(),a}case"ListDiff":return o.setdiff1dAsync(C("x",n,t,r),C("y",n,t,r));default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(t,r,s,o){return e.apply(this,arguments)}}();class lEe{get id(){return this.handle.id}constructor(n,t){this.keyDType=n,this.valueDType=t,this.handle=Re(0),this.tensorMap=new Map,ur(this.handle)}clearAndClose(){this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Re(this.size(),"int32")}import(n,t){var r=this;return F(function*(){r.checkKeyAndValueTensor(n,t);const s=yield n.data();return r.tensorMap.forEach(o=>o.dispose()),r.tensorMap.clear(),L(()=>{const o=So(t),i=s.length,a=o.length;S(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let l=0;l<i;l++){const u=s[l],c=o[l];ur(c),r.tensorMap.set(u,c)}return r.handle})})()}find(n,t){var r=this;return F(function*(){r.checkKeyAndValueTensor(n,t);const s=yield n.data();return L(()=>{const o=[];for(let i=0;i<s.length;i++){const l=r.findWithDefault(s[i],t);o.push(l)}return ps(o)})})()}findWithDefault(n,t){return this.tensorMap.get(n)??t}checkKeyAndValueTensor(n,t){if(n.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${n.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const uEe=function(){var e=F(function*(n,t,r,s){switch(n.op){case"HashTable":case"HashTableV2":{const o=s.getHashTableHandleByName(n.name);if(null!=o)return[o];{const i=C("keyDType",n,t,r),a=C("valueDType",n,t,r),l=new lEe(i,a);return s.addHashTable(n.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const o=C("tableHandle",n,t,r,s),i=C("keys",n,t,r),a=C("values",n,t,r);return[yield s.getHashTableById(o.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const o=C("tableHandle",n,t,r,s),i=C("keys",n,t,r),a=C("defaultValue",n,t,r);return[yield s.getHashTableById(o.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const o=C("tableHandle",n,t,r,s);return[s.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}});return function(t,r,s,o){return e.apply(this,arguments)}}();function C6(e,n,t,r,s=L){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(C("a",e,n,t),C("b",e,n,t))];case"AddN":return[r.addN(C("tensors",e,n,t))];case"FloorMod":case"Mod":return[r.mod(C("a",e,n,t),C("b",e,n,t))];case"Mul":return[r.mul(C("a",e,n,t),C("b",e,n,t))];case"RealDiv":case"Div":return[r.div(C("a",e,n,t),C("b",e,n,t))];case"DivNoNan":return[r.divNoNan(C("a",e,n,t),C("b",e,n,t))];case"FloorDiv":return[r.floorDiv(C("a",e,n,t),C("b",e,n,t))];case"Sub":return[r.sub(C("a",e,n,t),C("b",e,n,t))];case"Minimum":return[r.minimum(C("a",e,n,t),C("b",e,n,t))];case"Maximum":return[r.maximum(C("a",e,n,t),C("b",e,n,t))];case"Pow":return[r.pow(C("a",e,n,t),C("b",e,n,t))];case"SquaredDifference":return[r.squaredDifference(C("a",e,n,t),C("b",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"basic_math":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(C("x",e,n,t))];case"Acos":return[r.acos(C("x",e,n,t))];case"Acosh":return[r.acosh(C("x",e,n,t))];case"Asin":return[r.asin(C("x",e,n,t))];case"Asinh":return[r.asinh(C("x",e,n,t))];case"Atan":return[r.atan(C("x",e,n,t))];case"Atan2":return[r.atan2(C("x",e,n,t),C("y",e,n,t))];case"Atanh":return[r.atanh(C("x",e,n,t))];case"Ceil":return[r.ceil(C("x",e,n,t))];case"Complex":return[r.complex(C("real",e,n,t),C("imag",e,n,t))];case"Cos":return[r.cos(C("x",e,n,t))];case"Cosh":return[r.cosh(C("x",e,n,t))];case"Elu":return[r.elu(C("x",e,n,t))];case"Erf":return[r.erf(C("x",e,n,t))];case"Exp":return[r.exp(C("x",e,n,t))];case"Expm1":return[r.expm1(C("x",e,n,t))];case"Floor":return[r.floor(C("x",e,n,t))];case"Log":return[r.log(C("x",e,n,t))];case"Log1p":return[r.log1p(C("x",e,n,t))];case"Imag":return[r.imag(C("x",e,n,t))];case"Neg":return[r.neg(C("x",e,n,t))];case"Reciprocal":return[r.reciprocal(C("x",e,n,t))];case"Real":return[r.real(C("x",e,n,t))];case"Relu":return[r.relu(C("x",e,n,t))];case"Round":return[r.round(C("x",e,n,t))];case"Selu":return[r.selu(C("x",e,n,t))];case"Sigmoid":return[r.sigmoid(C("x",e,n,t))];case"Sin":return[r.sin(C("x",e,n,t))];case"Sign":return[r.sign(C("x",e,n,t))];case"Sinh":return[r.sinh(C("x",e,n,t))];case"Softplus":return[r.softplus(C("x",e,n,t))];case"Sqrt":return[r.sqrt(C("x",e,n,t))];case"Square":return[r.square(C("x",e,n,t))];case"Tanh":return[r.tanh(C("x",e,n,t))];case"Tan":return[r.tan(C("x",e,n,t))];case"ClipByValue":return[r.clipByValue(C("x",e,n,t),C("clipValueMin",e,n,t),C("clipValueMax",e,n,t))];case"Relu6":return[r.relu6(C("x",e,n,t))];case"Rsqrt":return[r.rsqrt(Hr(e.inputNames[0],n,t))];case"LeakyRelu":return[r.leakyRelu(C("x",e,n,t),C("alpha",e,n,t))];case"Prelu":return[r.prelu(C("x",e,n,t),C("alpha",e,n,t))];case"IsNan":return[r.isNaN(Hr(e.inputNames[0],n,t))];case"IsInf":return[r.isInf(Hr(e.inputNames[0],n,t))];case"IsFinite":return[r.isFinite(Hr(e.inputNames[0],n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"control":return nEe(i,a,l);case"convolution":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"Conv1D":{const s=C("stride",e,n,t),o=C("pad",e,n,t),i=C("dataFormat",e,n,t).toUpperCase(),a=C("dilation",e,n,t);return[r.conv1d(C("x",e,n,t),C("filter",e,n,t),s,o,i,a)]}case"Conv2D":{const s=C("strides",e,n,t),o=WI(e,n,t),i=C("dataFormat",e,n,t).toUpperCase(),a=C("dilations",e,n,t);return[r.conv2d(C("x",e,n,t),C("filter",e,n,t),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=x6(e,n,t);return[r.fused.conv2d({x:C("x",e,n,t),filter:C("filter",e,n,t),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=x6(e,n,t);return[r.fused.depthwiseConv2d({x:C("x",e,n,t),filter:C("filter",e,n,t),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=C("outputShape",e,n,t),o=C("strides",e,n,t),i=WI(e,n,t);return[r.conv2dTranspose(C("x",e,n,t),C("filter",e,n,t),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=C("strides",e,n,t),o=WI(e,n,t),i=C("dilations",e,n,t),a=C("dataFormat",e,n,t).toUpperCase();return[r.depthwiseConv2d(C("input",e,n,t),C("filter",e,n,t),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=C("strides",e,n,t),o=C("pad",e,n,t),i=C("dataFormat",e,n,t).toUpperCase(),a=C("dilations",e,n,t);return[r.conv3d(C("x",e,n,t),C("filter",e,n,t),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=C("strides",e,n,t),o=C("pad",e,n,t),i=C("kernelSize",e,n,t);return[r.avgPool(C("x",e,n,t),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=C("strides",e,n,t),o=C("pad",e,n,t),i=C("kernelSize",e,n,t);return[r.maxPool(C("x",e,n,t),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=C("strides",e,n,t),o=C("pad",e,n,t),i=C("kernelSize",e,n,t),a=C("includeBatchInIndex",e,n,t),{result:l,indexes:u}=r.maxPoolWithArgmax(C("x",e,n,t),[i[1],i[2]],[s[1],s[2]],o,a);return[l,u]}case"AvgPool3D":{const s=C("strides",e,n,t),o=C("pad",e,n,t),i=C("kernelSize",e,n,t);return[r.avgPool3d(C("x",e,n,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=C("strides",e,n,t),o=C("pad",e,n,t),i=C("kernelSize",e,n,t);return[r.maxPool3d(C("x",e,n,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=C("strides",e,n,t),o=C("pad",e,n,t),i=C("dilations",e,n,t),a=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(C("x",e,n,t),C("filter",e,n,t),[a,l],o,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"creation":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"Fill":{const s=C("shape",e,n,t),o=C("dtype",e,n,t),i=C("value",e,n,t);return[r.fill(s,i,o)]}case"LinSpace":{const s=C("start",e,n,t),o=C("stop",e,n,t),i=C("num",e,n,t);return[r.linspace(s,o,i)]}case"Multinomial":{const s=C("logits",e,n,t),o=C("numSamples",e,n,t),i=C("seed",e,n,t);return[r.multinomial(s,o,i)]}case"OneHot":{const s=C("indices",e,n,t),o=C("depth",e,n,t),i=C("onValue",e,n,t),a=C("offValue",e,n,t),l=C("dtype",e,n,t);return[r.oneHot(s,o,i,a,l)]}case"Ones":return[r.ones(C("shape",e,n,t),C("dtype",e,n,t))];case"OnesLike":return[r.onesLike(C("x",e,n,t))];case"RandomStandardNormal":return[r.randomStandardNormal(C("shape",e,n,t),C("dtype",e,n,t),C("seed",e,n,t))];case"RandomUniform":return[r.randomUniform(C("shape",e,n,t),C("minval",e,n,t),C("maxval",e,n,t),C("dtype",e,n,t))];case"RandomUniformInt":return[r.randomUniformInt(C("shape",e,n,t),C("minval",e,n,t),C("maxval",e,n,t),C("seed",e,n,t))];case"Range":{const s=C("start",e,n,t),o=C("stop",e,n,t),i=C("step",e,n,t);return[r.range(s,o,i,C("dtype",e,n,t))]}case"TruncatedNormal":{const s=C("shape",e,n,t),o=C("mean",e,n,t),i=C("stdDev",e,n,t),a=C("seed",e,n,t);return[r.truncatedNormal(s,o,i,C("dtype",e,n,t),a)]}case"Zeros":return[r.zeros(C("shape",e,n,t),C("dtype",e,n,t))];case"ZerosLike":return[r.zerosLike(C("x",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"dynamic":return oEe(i,a,l);case"evaluation":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"LowerBound":{const s=C("sortedSequence",e,n,t),o=C("values",e,n,t);return[r.lowerBound(s,o)]}case"TopKV2":{const s=C("x",e,n,t),o=C("k",e,n,t),i=C("sorted",e,n,t),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=C("sortedSequence",e,n,t),o=C("values",e,n,t);return[r.upperBound(s,o)]}case"Unique":{const s=C("x",e,n,t),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=C("x",e,n,t),o=C("axis",e,n,t),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"image":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"ResizeBilinear":{const s=C("images",e,n,t),o=C("size",e,n,t),i=C("alignCorners",e,n,t),a=C("halfPixelCenters",e,n,t);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=C("images",e,n,t),o=C("size",e,n,t),i=C("alignCorners",e,n,t),a=C("halfPixelCenters",e,n,t);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=C("image",e,n,t),o=C("boxes",e,n,t),i=C("boxInd",e,n,t),a=C("cropSize",e,n,t),l=C("method",e,n,t),u=C("extrapolationValue",e,n,t);return[r.image.cropAndResize(s,o,i,a,l,u)]}case"ImageProjectiveTransformV3":{const s=C("images",e,n,t),o=C("transforms",e,n,t),i=C("outputShape",e,n,t),a=C("fillValue",e,n,t),l=C("interpolation",e,n,t),u=C("fillMode",e,n,t);return[r.image.transform(s,o,l.toLowerCase(),u.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"graph":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"Const":return n[e.name];case"PlaceholderWithDefault":const s=C("default",e,n,t);return[Hr(e.name,n,t)||s];case"Placeholder":return[Hr(e.name,n,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ja(C("x",e,n,t))];case"IdentityN":return C("x",e,n,t).map(c=>Ja(c));case"Shape":return[r.tensor1d(C("x",e,n,t).shape,"int32")];case"ShapeN":return C("x",e,n,t).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(C("x",e,n,t).size,"int32")];case"Rank":return[r.scalar(C("x",e,n,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=C("x",e,n,t),a=C("data",e,n,t),l=C("message",e,n,t),u=C("summarize",e,n,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"logical":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"Equal":return[r.equal(C("a",e,n,t),C("b",e,n,t))];case"NotEqual":return[r.notEqual(C("a",e,n,t),C("b",e,n,t))];case"Greater":return[r.greater(C("a",e,n,t),C("b",e,n,t))];case"GreaterEqual":return[r.greaterEqual(C("a",e,n,t),C("b",e,n,t))];case"Less":return[r.less(C("a",e,n,t),C("b",e,n,t))];case"LessEqual":return[r.lessEqual(C("a",e,n,t),C("b",e,n,t))];case"LogicalAnd":return[r.logicalAnd(C("a",e,n,t),C("b",e,n,t))];case"LogicalNot":return[r.logicalNot(C("a",e,n,t))];case"LogicalOr":return[r.logicalOr(C("a",e,n,t),C("b",e,n,t))];case"Select":case"SelectV2":return[r.where(C("condition",e,n,t),C("a",e,n,t),C("b",e,n,t))];case"BitwiseAnd":return[r.bitwiseAnd(C("a",e,n,t),C("b",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"matrices":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(C("a",e,n,t),C("b",e,n,t),C("transposeA",e,n,t),C("transposeB",e,n,t))];case"Einsum":return[r.einsum(C("equation",e,n,t),...C("tensors",e,n,t))];case"Transpose":return[r.transpose(C("x",e,n,t),C("perm",e,n,t))];case"_FusedMatMul":const[s,o]=C("fusedOps",e,n,t),i="biasadd"===s,a="prelu"===o,l=C("numArgs",e,n,t),u=C("leakyreluAlpha",e,n,t);if(i){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=C("args",e,n,t);return[r.fused.matMul({a:C("a",e,n,t),b:C("b",e,n,t),transposeA:C("transposeA",e,n,t),transposeB:C("transposeB",e,n,t),bias:c,activation:o,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(C("a",e,n,t),C("numLower",e,n,t),C("numUpper",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"normalization":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(C("x",e,n,t),C("axis",e,n,t),C("keepDims",e,n,t))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(C("x",e,n,t),C("mean",e,n,t),C("variance",e,n,t),C("offset",e,n,t),C("scale",e,n,t),C("epsilon",e,n,t))];case"LRN":return[r.localResponseNormalization(C("x",e,n,t),C("radius",e,n,t),C("bias",e,n,t),C("alpha",e,n,t),C("beta",e,n,t))];case"Softmax":return[r.softmax(C("x",e,n,t))];case"LogSoftmax":return[r.logSoftmax(C("x",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"ragged":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather(C("paramsNestedSplits",e,n,t),C("paramsDenseValues",e,n,t),C("indices",e,n,t),C("outputRaggedRank",e,n,t));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange(C("starts",e,n,t),C("limits",e,n,t),C("splits",e,n,t));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(C("shape",e,n,t),C("values",e,n,t),C("defaultValue",e,n,t),C("rowPartitionTensors",e,n,t),C("rowPartitionTypes",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"reduction":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"Max":{const a=C("axis",e,n,t),l=C("keepDims",e,n,t);return[r.max(C("x",e,n,t),a,l)]}case"Mean":{const a=C("axis",e,n,t),l=C("keepDims",e,n,t);return[r.mean(C("x",e,n,t),a,l)]}case"Min":{const a=C("axis",e,n,t),l=C("keepDims",e,n,t);return[r.min(C("x",e,n,t),a,l)]}case"Sum":{const a=C("axis",e,n,t),l=C("keepDims",e,n,t);return[r.sum(C("x",e,n,t),a,l)]}case"All":{const a=C("axis",e,n,t),l=C("keepDims",e,n,t);return[r.all(C("x",e,n,t),a,l)]}case"Any":{const a=C("axis",e,n,t),l=C("keepDims",e,n,t);return[r.any(C("x",e,n,t),a,l)]}case"ArgMax":{const a=C("axis",e,n,t);return[r.argMax(C("x",e,n,t),a)]}case"ArgMin":{const a=C("axis",e,n,t);return[r.argMin(C("x",e,n,t),a)]}case"Prod":{const a=C("axis",e,n,t),l=C("keepDims",e,n,t);return[r.prod(C("x",e,n,t),a,l)]}case"Cumprod":{const a=C("axis",e,n,t),l=C("exclusive",e,n,t),u=C("reverse",e,n,t);return[r.cumprod(C("x",e,n,t),a,l,u)]}case"Cumsum":{const a=C("axis",e,n,t),l=C("exclusive",e,n,t),u=C("reverse",e,n,t);return[r.cumsum(C("x",e,n,t),a,l,u)]}case"Bincount":const s=C("x",e,n,t),o=C("weights",e,n,t),i=C("size",e,n,t);return[r.bincount(s,o,i)];case"DenseBincount":{const a=C("x",e,n,t),l=C("weights",e,n,t),u=C("size",e,n,t),c=C("binaryOutput",e,n,t);return[r.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"slice_join":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=C("n",e,n,t),o=C("axis",e,n,t);let i=C("tensors",e,n,t);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=C("x",e,n,t),o=C("indices",e,n,t);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=C("axis",e,n,t),o=C("batchDims",e,n,t),i=C("x",e,n,t),a=C("indices",e,n,t);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=C("dims",e,n,t),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=C("x",e,n,t);return[r.reverse(i,o)]}case"ReverseV2":{const s=C("axis",e,n,t),o=C("x",e,n,t);return[r.reverse(o,s)]}case"Slice":{const s=C("begin",e,n,t),o=C("size",e,n,t);return[r.slice(C("x",e,n,t),s,o)]}case"StridedSlice":{const s=C("begin",e,n,t),o=C("end",e,n,t),i=C("strides",e,n,t),a=C("beginMask",e,n,t),l=C("endMask",e,n,t),u=C("ellipsisMask",e,n,t),c=C("newAxisMask",e,n,t),d=C("shrinkAxisMask",e,n,t),h=C("x",e,n,t);return[r.stridedSlice(h,s,o,i,a,l,u,c,d)]}case"Pack":return L(()=>{const s=C("axis",e,n,t),o=C("tensors",e,n,t),i=o[0].shape,a=r.squeeze(o[0]).shape,l=o.map(u=>{const c=wt(u.shape,i);if(!c&&!wt(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{const s=C("axis",e,n,t),o=C("tensor",e,n,t);return r.unstack(o,s)}case"Tile":{const s=C("reps",e,n,t);return[r.tile(C("x",e,n,t),s)]}case"Split":case"SplitV":{const s=C("axis",e,n,t),o=C("numOrSizeSplits",e,n,t),i=C("x",e,n,t);return r.split(i,o,s)}case"ScatterNd":{const s=C("indices",e,n,t),o=C("values",e,n,t),i=C("shape",e,n,t);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=C("x",e,n,t),o=C("indices",e,n,t);return[r.gatherND(s,o)]}case"SparseToDense":{const s=C("sparseIndices",e,n,t),o=C("outputShape",e,n,t),i=C("sparseValues",e,n,t),a=C("defaultValue",e,n,t);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{const s=C("indices",e,n,t),o=C("values",e,n,t),i=C("tensor",e,n,t);return[r.tensorScatterUpdate(i,s,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"sparse":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(C("indices",e,n,t),C("values",e,n,t),C("denseShape",e,n,t),C("defaultValue",e,n,t));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(C("inputIndices",e,n,t),C("inputShape",e,n,t),C("newShape",e,n,t));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(C("data",e,n,t),C("indices",e,n,t),C("segmentIds",e,n,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(C("data",e,n,t),C("indices",e,n,t),C("segmentIds",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"spectral":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"FFT":return[r.fft(C("x",e,n,t))];case"IFFT":return[r.ifft(C("x",e,n,t))];case"RFFT":return[r.rfft(C("x",e,n,t))];case"IRFFT":return[r.irfft(C("x",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"string":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(C("input",e,n,t),C("pattern",e,n,t),C("rewrite",e,n,t),C("replaceGlobal",e,n,t))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(C("data",e,n,t),C("dataSplits",e,n,t),C("separator",e,n,t),C("nGramWidths",e,n,t),C("leftPad",e,n,t),C("rightPad",e,n,t),C("padWidth",e,n,t),C("preserveShortSequences",e,n,t));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(C("input",e,n,t),C("delimiter",e,n,t),C("skipEmpty",e,n,t));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(C("input",e,n,t),C("numBuckets",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"transformation":return s(()=>((e,n,t,r=vt)=>{switch(e.op){case"Cast":return[r.cast(C("x",e,n,t),C("dtype",e,n,t))];case"ExpandDims":{const s=C("axis",e,n,t);return[r.expandDims(C("x",e,n,t),s)]}case"Squeeze":{const s=C("axis",e,n,t);return[r.squeeze(C("x",e,n,t),s)]}case"Reshape":return[r.reshape(C("x",e,n,t),C("shape",e,n,t))];case"EnsureShape":return[r.ensureShape(C("x",e,n,t),C("shape",e,n,t))];case"MirrorPad":return[r.mirrorPad(C("x",e,n,t),C("padding",e,n,t),C("mode",e,n,t))];case"PadV2":case"Pad":return[r.pad(C("x",e,n,t),C("padding",e,n,t),C("constantValue",e,n,t))];case"SpaceToBatchND":{const s=C("blockShape",e,n,t),o=C("paddings",e,n,t);return[r.spaceToBatchND(C("x",e,n,t),s,o)]}case"BatchToSpaceND":{const s=C("blockShape",e,n,t),o=C("crops",e,n,t);return[r.batchToSpaceND(C("x",e,n,t),s,o)]}case"DepthToSpace":{const s=C("blockSize",e,n,t),o=C("dataFormat",e,n,t).toUpperCase();return[r.depthToSpace(C("x",e,n,t),s,o)]}case"BroadcastTo":return[r.broadcastTo(C("x",e,n,t),C("shape",e,n,t))];case"BroadcastArgs":return[r.broadcastArgs(C("s0",e,n,t),C("s1",e,n,t))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(i,a,l));case"hash_table":return uEe(i,a,l,r);case"custom":const u=p6(i.op);if(u&&u.customExecutor)return u.customExecutor(new K_e(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,n,t);return Fa(o)?o.then(i=>[].concat(i)):[].concat(o)}class I6{constructor(n={},t={},r={},s={},o){this.weightMap=n,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(n,t){return{id:n,frameName:t,iterationId:0}}set currentContext(n){this.contexts!==n&&(this.contexts=n,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const n=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);n.push(this.contextIdforContexts(r))}n.push(""),this._currentContextIds=n}contextIdforContexts(n){return n?n.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(n){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,n)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const n=Object.assign({},this.contexts[this.contexts.length-1]);n.iterationId+=1,n.id=this.lastId,this.contexts.splice(-1,1,n),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(n){return this.weightMap[n]}addTensorArray(n){this.tensorArrayMap[n.id]=n}getTensorArray(n){return this.tensorArrayMap[n]}addTensorList(n){this.tensorListMap[n.id]=n}getTensorList(n){return this.tensorListMap[n]}dispose(n){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(n);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(n)}}function S6(e,n,t,r){const s=new Set,o=[];let i=null,a=null;const l=new Set,u=new Set(Object.keys(e).map(h=>Js(h)[0]));r=r||[];const c=new Set(r.map(h=>Js(h.name)[0])),d=[...n];for(;d.length>0;){const h=d.pop();if((Xc(h)||NEe(h)||TEe(h))&&null==i&&(i=h,a=i.children.map(f=>f.name).filter(f=>s.has(f))),s.add(h.name),null==t[h.name]&&!u.has(h.name)&&!c.has(h.name)){if(0===h.inputs.length){o.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:e,outputs:n,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}class HI extends Error{constructor(n){super(`NodesExecutionOrderError: ${n}`)}}const _Ee=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),EEe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),DEe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Xc(e){return _Ee.has(e.op)}function NEe(e){return EEe.has(e.op)}function TEe(e){return DEe.has(e.op)}class jI{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(n){const t=Object.keys(n).map(r=>n[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=n}set resourceManager(n){this._resourceManager=n}get inputs(){return this._inputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(n=>n.signatureKey||n.name)}get outputNodes(){return this._outputs.map(n=>{const t=n.signatureKey||n.name;return n.defaultOutput?`${t}:${n.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((n,t)=>(n[t]=this._functions[t].signature,n),{})}constructor(n,t){this.graph=n,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=n.outputs,this._inputs=n.inputs,this._initNodes=n.initNodes,this._signature=n.signature,this._functions=n.functions,null!=n.functions&&Object.keys(n.functions).forEach(r=>{this._functionExecutorMap[r]=new jI(n.functions[r],this)})}getCompilationKey(n,t){const r=n.map(o=>o.name).sort(),s=t.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(n,t){const r=S6(n,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(null!=o)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const u=t.map(d=>d.name),c=Object.keys(n);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}const a=function xEe(e,n){const{usedNodes:t,inputs:r}=n,i=g=>t.has("string"==typeof g?g:g.name);function a(g){return[...new Map(g.map(y=>[y.name,y])).values()]}const l=a([...Object.keys(r).map(g=>Js(g)[0]).map(g=>e.nodes[g]),...e.weights,...e.initNodes||[]]).filter(i),u=a([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(g=>[g.name,g])),d={};for(const g of u){d[g.name]=d[g.name]||0;for(const y of g.children)i(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}const h=Object.entries(d).filter(([,g])=>0===g).map(([g])=>g),f=[...h];for(;h.length>0;){const g=h.pop(),y=c.get(g);for(const v of y.children.filter(i))0==--d[v.name]&&(f.push(v.name),h.push(v.name))}const m=function CEe(e,n){const t=new Map(e.map(i=>[i.name,i])),r=n.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),a=t.get(i);for(const l of a.children)!t.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return e.filter(i=>s.has(i.name))}(f.map(g=>c.get(g)),l);return function IEe(e,n){const t=new Map(e.map((a,l)=>[a.name,l])),r=new Set(n.map(a=>a.name)),s=a=>r.has("string"==typeof a?a:a.name),o=new Set(e.map(a=>a.name)),i=a=>o.has("string"==typeof a?a:a.name);for(const a of e){for(const l of a.children.filter(i)){if(!t.has(l.name))throw new HI(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new HI(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!t.has(l.name))throw new HI(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new HI(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}(m,l),m}(this.graph,r),l=function SEe(e){const n=new Map(e.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,r=e.map((a,l)=>Xc(a)?t:l),s=a=>r[n.get(a.name)]??-1,o=e.map((a,l)=>a.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let a=0;a<e.length;++a){const l=o[a];if(l===t)continue;const u=e[a],c=e[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(n){if(null==n)return null;const t=n.clone();return ur(t),t}cloneTensorList(n){return n?n.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(n){return Object.fromEntries(Object.entries(n).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(n,t){this.disposeIntermediateTensors(),n=this.mapInputs(n);const r=Object.keys(n).sort();this.checkInputs(n),this.checkInputShapeAndType(n),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(h=>this.graph.nodes[Js(h)[0]]),o=t.map(h=>Js(h)[0]),i=new Set(o);let a=o.map(h=>this.graph.nodes[h]);0===a.length&&(a=this._outputs);const l=this.getCompilationKey(s,a);let u=this.compiledMap.get(l);null==u&&(u=this.compile(n,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const c={},d={};return L(()=>{const h=new I6(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(n).forEach(y=>{const[v,b]=Js(y,h),w=[];w[b]=n[y],f[v]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[v]=this.cloneTensorList(w))});const p=this.getFrozenTensorIds(f),{orderedNodes:m,nodeLiveUntilMap:g}=u;for(const y of m){if(f[y.name])continue;const v=C6(y,f,h,this._resourceManager);if(Fa(v))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);f[y.name]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(v)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,f,h,p,i,g.get(y.name))}return null==this.parent&&h.dispose(p),t.map(y=>Hr(y,f,h))})}getFrozenTensorIds(n){const t=[].concat.apply([],Object.keys(n).map(r=>n[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(n,t,r,s,o,i,a){if(!Xc(t)&&!i.has(n)){for(const l of r[n])null!=l&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(Xc(l))continue;const u=m6(l.name,r,s);if(null!=u)for(const c of u){if(!c||c.kept||o.has(c.id))continue;const d=a[c.id];1===d?(c.dispose(),delete a[c.id]):null!=d&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(n,t,r,s,o,i){function a(l){return Xc(l)||o.has(l.name)}if(!Xc(n)&&null!=i)for(const l of i){if(a(l))continue;const u=m6(l.name,t,r);for(const c of u)!c||c.kept||s.has(c.id)||c.dispose()}}executeAsync(n,t){var r=this;return F(function*(){return r._executeAsync(n,t)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(n=>{for(const t of n)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(n,t,r=!1,s={},o={}){var i=this;return F(function*(){i.disposeIntermediateTensors(),r||(n=i.mapInputs(n),i.checkInputs(n),i.checkInputShapeAndType(n),t=i.mapOutputs(t),i.checkOutputs(t));try{i.keepIntermediateTensors=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){i.keepIntermediateTensors=!1,console.warn(f.message)}const a=new I6(i.weightMap,s,o,i.functionExecutorMap,i.parseNodeNameCache);i.keepIntermediateTensors&&(i.clonedTensorsMap=i.cloneTensorMap(i.weightMap));const l=yield i.executeWithControlFlow(n,a,t,r),u=t.map(f=>Hr(f,l,a)),c=u.map(f=>f.id),d=Object.keys(n).map(f=>n[f].id),h=new Set([...c,...d,...i.weightIds]);return Object.values(l).forEach(f=>{f.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),null==i.parent&&a.dispose(h),u})()}executeFunctionAsync(n,t,r){var s=this;return F(function*(){const o=n.reduce((i,a,l)=>(i[s.inputs[l].name]=a,i),{});return s._executeAsync(o,s.outputNodes,!0,t,r)})()}executeWithControlFlow(n,t,r,s){var o=this;return F(function*(){const i=Object.keys(n),a=i.map(x=>o.graph.nodes[Js(x)[0]]),l=r.map(x=>Js(x)[0]),u=new Set(l);let c=l.map(x=>o.graph.nodes[x]);0===c.length&&(c=o._outputs);const{usedNodes:d,missingInputs:h,dynamicNode:f,syncInputs:p}=S6(n,c,o.weightMap,o._initNodes),m=[...a,...o.graph.weights,...o._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),g=Object.assign({},o.weightMap);Object.keys(n).forEach(x=>{const[I,_]=Js(x),D=[];D[_]=n[x],g[I]=D});const y={},v=o.getFrozenTensorIds(g),b={};for(;m.length>0;){const x=o.processStack(a,m,t,g,b,v,u,y,d);yield Promise.all(x)}null==f&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=c.filter(x=>!Xc(x)&&!Hr(x.name,g,t)).map(x=>x.name);if(w.length>0){let x="";throw null!=f&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${x}`)}return g})()}processStack(n,t,r,s,o,i,a,l,u){const c=[];for(;t.length>0;){const d=t.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&C("isConstant",d.node,s,r)&&([h]=Qa(d.node.name,r)),null==s[d.node.name]){const f=C6(d.node,s,r,this._resourceManager);h||([h]=Qa(d.node.name,r));const p=r.currentContext;Fa(f)?c.push(f.then(m=>(s[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,t,r,s,o,u),m))):(s[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),this.checkTensorForDisposal(h,d.node,s,r,i,a,l),this.processChildNodes(d.node,t,r,s,o,u))}else this.processChildNodes(d.node,t,r,s,o,u)}return c}processChildNodes(n,t,r,s,o,i){n.children.forEach(a=>{const[l]=Qa(a.name,r);o[l]||!i.has(a.name)||("Merge"===a.op?a.inputNames.some(u=>!!Hr(u,s,r))&&(o[l]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!Hr(u,s,r))&&(o[l]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(n=>this.weightMap[n].forEach(t=>t.dispose()))}checkInputShapeAndType(n){Object.keys(n).forEach(t=>{const r=n[t],[s]=Js(t),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value;S(i.length===r.shape.length&&r.shape.every((l,u)=>-1===i[u]||i[u]===l),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&S(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(n){var t,r;const s={};for(const o in n){const i=null===(r=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===r?void 0:r[o];null!=i?s[i.name]=n[o]:s[o]=n[o]}return s}checkInputs(n){const t=Object.keys(n).filter(r=>{const[s]=Js(r);return null==this.graph.nodes[s]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(n){return n.map(t=>{var r,s;const o=null===(s=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===s?void 0:s[t];return null!=o?o.name:t},{})}checkOutputs(n){n.forEach(t=>{const[r]=Js(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class kEe{constructor(n={},t={}){this.hashTableNameToHandle=n,this.hashTableMap=t}addHashTable(n,t){this.hashTableNameToHandle[n]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(n){return this.hashTableNameToHandle[n]}getHashTableById(n){return this.hashTableMap[n]}dispose(){for(const n in this.hashTableMap)this.hashTableMap[n].clearAndClose(),delete this.hashTableMap[n];for(const n in this.hashTableNameToHandle)this.hashTableNameToHandle[n].dispose(),delete this.hashTableNameToHandle[n]}}class _6{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(n,t={},r=Pe){this.modelUrl=n,this.loadOptions=t,this.version="n/a",this.io=r,null==t&&(this.loadOptions={}),this.resourceManager=new kEe}findIOHandler(){const n=this.modelUrl;if(null!=n.load)this.handler=n;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(n,this.loadOptions);else{const t=this.io.getLoadHandlers(n,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(n,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[n]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const n=this.handler.load();return Fa(n)?n.then(t=>null==t.getWeightStream?this.loadSync(t):this.loadStreaming(t)):this.loadSync(n)}loadSync(n){const t=this.io.decodeWeights(n.weightData,n.weightSpecs);return this.loadWithWeightMap(n,t)}loadStreaming(n){var t=this;return F(function*(){if(null==n.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const r=yield wH(n.getWeightStream(),n.weightSpecs);return t.loadWithWeightMap(n,r)})()}loadWithWeightMap(n,t){this.artifacts=n;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const o=this.artifacts.userDefinedMetadata;null!=o.signature&&(s=o.signature),null!=o.structuredOutputKeys&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new jI(g6.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=n.modelInitializer&&null!=n.modelInitializer.node){const o=g6.Instance.transformGraph(n.modelInitializer);this.initializer=new jI(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=n.initializerSignature}return!0}save(n,t){var r=this;return F(function*(){if("string"==typeof n){const s=r.io.getSaveHandlers(n);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${n}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${n}'`);n=s[0]}if(null==n.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return n.save(r.artifacts)})()}addStructuredOutputNames(n){if(this.structuredOutputKeys){const r={};return(n instanceof St?[n]:n).forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return n}predict(n,t){const r=this.execute(n,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(n,t){var r=this;return F(function*(){const s=yield r.executeAsync(n,r.outputNodes);return r.addStructuredOutputNames(s)})()}normalizeInputs(n){var t;if(!(n instanceof St||Array.isArray(n))){const o=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=o)for(const i in o){const a=o[i];null!=a.resourceId&&(n[i]=this.resourceIdToCapturedInput[a.resourceId])}return n}n=Array.isArray(n)?n:[n];const r=Object.keys(this.resourceIdToCapturedInput).length;if(n.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${n.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,i)=>{var a,l,u;const c=null===(u=null===(l=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===l?void 0:l[i])||void 0===u?void 0:u.resourceId;return o[i]=null!=c?this.resourceIdToCapturedInput[c]:n[s++],o},{})}normalizeOutputs(n){return n=n||this.outputNodes,Array.isArray(n)?n:[n]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var n=this;return F(function*(){return null==n.initializer?[]:n.initializer.executeAsync({},null==n.initializerSignature?[]:Object.keys(n.initializerSignature.outputs))})()}setResourceIdToCapturedInput(n){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let s=0;s<r.length;s++)this.resourceIdToCapturedInput[t[r[s]].resourceId]=n[s]}}execute(n,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),n=this.normalizeInputs(n),t=this.normalizeOutputs(t);const r=this.executor.execute(n,t);return r.length>1?r:r[0]}executeAsync(n,t){var r=this;return F(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),n=r.normalizeInputs(n),t=r.normalizeOutputs(t);const s=yield r.executor.executeAsync(n,t);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(n){return Object.keys(n).reduce((t,r)=>(t[r]=[n[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ot(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function E6(e){return CM.apply(this,arguments)}function CM(){return(CM=F(function*(e,n={},t=Pe){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==n&&(n={}),n.fromTFHub&&"string"==typeof e&&(e=function MEe(e){return e.endsWith("/")||(e+="/"),`${e}model.json?tfjs-format=file`}(e));const r=new _6(e,n,t);return yield r.load(),r})).apply(this,arguments)}function Te(e,n){Array.isArray(e)||(e=[e]),e.forEach(t=>{null!=t&&S("complex64"!==t.dtype,()=>`${n} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const pDe=iI;let mDe=(()=>{class e extends s0{nextDataId(){return e.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new N1(this,vo())}write(t,r,s){this.firstUse&&(this.firstUse=!1,V().get("IS_NODE")&&yo("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const o={id:this.nextDataId()};return this.data.set(o,{values:t,dtype:s,refCount:1}),o}makeTensorInfo(t,r,s){let o;if("string"===r&&null!=s&&s.length>0&&Gi(s[0])){const i=s.map(a=>qi(a));o=this.write(i,t,r)}else o=this.write(s,t,r);return{dataId:o,shape:t,dtype:r}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){this.data.get(t).refCount++}decRef(t){this.data.has(t)&&this.data.get(t).refCount--}move(t,r,s,o,i){this.data.set(t,{values:r,dtype:o,refCount:i})}numDataIds(){return this.data.numDataIds()}read(t){var r=this;return F(function*(){return r.readSync(t)})()}readSync(t){const{dtype:r,complexTensorInfos:s}=this.data.get(t);return"complex64"===r?Ka(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):V4(this.data.get(t).values,r)}bufferSync(t){const r=this.readSync(t.dataId);if("string"===t.dtype)try{const s=r.map(o=>Pa(o));return it(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return it(t.shape,t.dtype,r)}makeOutput(t,r,s){return vo().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,t),this)}disposeData(t,r=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!r&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(t);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}time(t){return F(function*(){const r=Vr();return t(),{kernelMs:Vr()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Te([t],"where");const r=this.readSync(t.dataId);return pDe(t.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return e.nextDataId=0,e})();function ua(e){return(n,t,r)=>{const s=On(t,n.length);for(let o=0;o<n.length;++o)s[o]=e(n[o],r);return s}}function Wt(e,n,t){return du(e,ua(n),t)}function du(e,n,t){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;Te(i,e);const a=o,l=a.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Xa(l)}else u=l;const c=t||i.dtype,d=n(u,c,s);return a.makeTensorInfo(i.shape,c,d)}}q1("cpu",()=>new mDe,1);const U6=Wt(Kh,e=>e>=0?e:Math.exp(e)-1),yDe={kernelName:Kh,backendName:"cpu",kernelFunc:U6};function ca(e){const{inputs:n,backend:t}=e,{x:r}=n;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const vDe={kernelName:nf,backendName:"cpu",kernelFunc:ca};function W6(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{alpha:o}=r;Te([s],"leakyRelu");const i=j(s.shape),a=t.data.get(s.dataId).values,l=Er("float32",i);for(let u=0;u<a.length;u++)l[u]=a[u]<0?o*a[u]:a[u];return t.makeTensorInfo(s.shape,"float32",l)}const bDe={kernelName:ey,backendName:"cpu",kernelFunc:W6};function qn(e){return(n,t,r,s,o)=>{const i=et(n,t),a=i.length,l=Oe(i),c=Er(o,j(i)),d=n.length,h=t.length,f=Oe(n),p=Oe(t),m=Rc(n,i),g=Rc(t,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const v=Cc(y,a,l),b=v.slice(-d);m.forEach(_=>b[_]=0);const w=hi(b,d,f),x=v.slice(-h);g.forEach(_=>x[_]=0);const I=hi(x,h,p);c[y]=e(r[w],s[I])}return[c,i]}}const wDe=qn((e,n)=>e<0?n*e:e);function H6(e){const{inputs:n,backend:t}=e,{x:r,alpha:s}=n;Te([r,s],"prelu");const o=t.data.get(r.dataId).values,i=t.data.get(s.dataId).values,[a,l]=wDe(r.shape,s.shape,o,i,"float32");return t.makeTensorInfo(l,"float32",a)}const xDe={kernelName:by,backendName:"cpu",kernelFunc:H6},j6=Wt(gf,e=>Math.max(0,e)),CDe={kernelName:gf,backendName:"cpu",kernelFunc:j6},G6=Wt(yf,e=>Math.min(Math.max(0,e),6)),IDe={kernelName:yf,backendName:"cpu",kernelFunc:G6},SDe=ua(e=>1/(1+Math.exp(-e))),q6=Wt(Sf,e=>1/(1+Math.exp(-e))),_De={kernelName:Sf,backendName:"cpu",kernelFunc:q6};function ZI(e,n,t,r,s){if("linear"===t)return ca({inputs:{x:n},backend:e});if("relu"===t)return j6({inputs:{x:n},backend:e});if("elu"===t)return U6({inputs:{x:n},backend:e});if("relu6"===t)return G6({inputs:{x:n},backend:e});if("prelu"===t)return H6({inputs:{x:n,alpha:r},backend:e});if("leakyrelu"===t)return W6({inputs:{x:n},backend:e,attrs:{alpha:s}});if("sigmoid"===t)return q6({inputs:{x:n},backend:e});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function eo(e){const{inputs:n,backend:t}=e,{real:r,imag:s}=n,o=t.data.get(r.dataId).values,i=t.data.get(s.dataId).values,a=t.makeTensorInfo(r.shape,"complex64");return t.data.get(a.dataId).complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",o),imag:t.makeTensorInfo(s.shape,"float32",i)},a}const EDe={kernelName:y0,backendName:"cpu",kernelFunc:eo};function QI(e,n,t="float32"){if("complex64"===t)return eo({inputs:{real:QI(e,n,"float32"),imag:QI(e,n,"float32")},backend:e});const r=Lr(j(n),t);return e.makeTensorInfo(n,t,r)}function Yc(e){const{inputs:n,backend:t}=e,{input:r}=n,s=t.data.get(r.dataId).complexTensorInfos.real,o=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,o)}const DDe={kernelName:Q0,backendName:"cpu",kernelFunc:Yc};function K6(e,n,t,r){if("int32"===r)return[n,"int32",Int32Array.from(e)];if("bool"===r){const s=Wl([0],t),[o,i]=qn((a,l)=>a!==l?1:0)(n,[],e,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function hu(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return ca({inputs:{x:s},backend:t});const c=QI(t,s.shape,s.dtype),d=hu({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),h=eo({inputs:{real:d,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const c=Yc({inputs:{input:s},backend:t}),d=hu({inputs:{x:c},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(c),d}if(!R1(s.dtype,o)){const c=ca({inputs:{x:s},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=t.data.get(s.dataId).values,[a,l,u]=K6(i,s.shape,s.dtype,o);return t.makeTensorInfo(a,l,u)}const NDe={kernelName:Uh,backendName:"cpu",kernelFunc:hu};function pr(e,n,t,r){return null==t?({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;Te([i,a],e);const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d="string"===i.dtype?Xa(u):u,h="string"===i.dtype?Xa(c):c,f=r||i.dtype,[p,m]=n(i.shape,a.shape,d,h,f);return l.makeTensorInfo(m,f,p)}:({inputs:s,backend:o})=>{const{a:i,b:a}=s,l=o;if("complex64"===i.dtype||"complex64"===a.dtype){const u=hu({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,f=l.data.get(c.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,m=hu({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),v=g.complexTensorInfos.imag,b=l.data.get(g.complexTensorInfos.real.dataId).values,w=l.data.get(v.dataId).values,[x,I,_]=t(i.shape,a.shape,f,p,b,w),D=l.makeTensorInfo(_,"float32",x),N=l.makeTensorInfo(_,"float32",I),T=eo({inputs:{real:D,imag:N},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(N),T}{const u=l.data.get(i.dataId).values,c=l.data.get(a.dataId).values,d=r||i.dtype,[h,f]=n(i.shape,a.shape,u,c,d);return l.makeTensorInfo(f,d,h)}}}function kM(e){return(n,t,r,s,o,i)=>{const a=et(n,t),l=j(a),u=a.length,c=Oe(a),d=Er("float32",l),h=Er("float32",l),f=Rc(n,a),p=Rc(t,a),m=Ka(r,s),g=Ka(o,i),y=n.length,v=Oe(n),b=t.length,w=Oe(t);if(f.length+p.length===0)for(let x=0;x<d.length;x++){const I=x%m.length,_=x%g.length,D=e(m[2*I],m[2*I+1],g[2*_],g[2*_+1]);d[x]=D.real,h[x]=D.imag}else for(let x=0;x<d.length;x++){const I=Cc(x,u,c),_=I.slice(-y);f.forEach(B=>_[B]=0);const D=hi(_,y,v),N=I.slice(-b);p.forEach(B=>N[B]=0);const T=hi(N,b,w),P=e(m[2*D],m[2*D+1],g[2*T],g[2*T+1]);d[x]=P.real,h[x]=P.imag}return[d,h,a]}}const X6=qn((e,n)=>e+n),TDe=kM((e,n,t,r)=>({real:e+t,imag:n+r})),ip=pr(Ic,X6,TDe),kDe={kernelName:Ic,backendName:"cpu",kernelFunc:ip};function an(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{shape:o}=r,i=j(s.shape),a=A1(o,i),l=j(a);S(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(s.dataId);const u=t.data.get(s.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const ADe={kernelName:xy,backendName:"cpu",kernelFunc:an};function Y6(e){const{inputs:n,backend:t,attrs:r}=e,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;Te([s,o],"matMul");const l=s.shape.length,u=o.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=a?o.shape[u-1]:o.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],f=a?o.shape[u-2]:o.shape[u-1],p=s.shape.slice(0,-2),m=o.shape.slice(0,-2),g=j(p),y=j(m),b=et(s.shape.slice(0,-2),o.shape.slice(0,-2)).concat([h,f]);S(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const x=a?[y,f,d]:[y,d,f],I=an({inputs:{x:s},backend:t,attrs:{shape:i?[g,c,h]:[g,h,c]}}),_=an({inputs:{x:o},backend:t,attrs:{shape:x}}),D=i?I.shape[1]:I.shape[2],N=i?I.shape[2]:I.shape[1],T=a?_.shape[1]:_.shape[2],P=Math.max(g,y),B=t.data.get(I.dataId).values,W=t.data.get(_.dataId).values,H=Oe(I.shape),G=Oe(_.shape),[Y,Q,q]=i?[H[0],1,H[1]]:[H[0],H[1],1],[J,ie,ue]=a?[1,G[1],G[0]]:[G[1],1,G[0]],me=N*T,de=it([P,N,T],I.dtype),xe=de.values,ge=t.blockSize;for(let Ie=0;Ie<P;Ie++){const Fe=Ie%g,Ue=Ie%y;for(let Be=0;Be<N;Be+=ge){const ut=Math.min(Be+ge,N);for(let mt=0;mt<T;mt+=ge){const Ht=Math.min(mt+ge,T);for(let ln=0;ln<D;ln+=ge){const Fn=Math.min(ln+ge,D);for(let un=Be;un<ut;un++)for(let Yt=mt;Yt<Ht;Yt++){let kn=0;for(let bn=ln;bn<Fn;bn++)kn+=B[Fe*Y+un*Q+bn*q]*W[bn*J+Yt*ie+Ue*ue];xe[Ie*me+(un*T+Yt)]+=kn}}}}}return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(b,de.dtype,de.values)}const RDe={kernelName:Lg,backendName:"cpu",kernelFunc:Y6},ODe={kernelName:Fy,backendName:"cpu",kernelFunc:function MDe(e){const{inputs:n,backend:t,attrs:r}=e,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,f,p;const m=[];h=Y6({inputs:{a:s,b:o},attrs:{transposeA:l,transposeB:u},backend:t}),i&&(f=ip({inputs:{a:h,b:i},backend:t}),m.push(h),h=f),c&&(p=ZI(t,h,c,a,d),m.push(h),h=p);for(const y of m)t.disposeIntermediateTensorInfo(y);return h}};function Z6(e){const n=new Float32Array(e.length);for(let t=0;t<e.length;++t)n[t]=Math.abs(e[t]);return n}const FDe={kernelName:Rg,backendName:"cpu",kernelFunc:e=>{const{x:n}=e.inputs,t=e.backend;Te(n,"abs");let r=new Float32Array(j(n.shape));return r=Z6(t.data.get(n.dataId).values),t.makeOutput(r,n.shape,n.dtype)}},$De=Wt(Fh,e=>Math.acos(e)),PDe={kernelName:Fh,backendName:"cpu",kernelFunc:$De},LDe=Wt($h,e=>Math.acosh(e)),VDe={kernelName:$h,backendName:"cpu",kernelFunc:LDe},zDe={kernelName:Mg,backendName:"cpu",kernelFunc:function BDe(e){const{inputs:n,backend:t}=e,r=n;Te(n,"addN");const s=r.map(a=>t.data.get(a.dataId).values),o=it(r[0].shape,r[0].dtype),i=o.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<i.length;u++)i[u]+=l[u]}return t.makeTensorInfo(o.shape,o.dtype,o.values)}};function AM(e,n,t,r,s){const o=n.length,i=j(n),a=Oe(n),l=Oe(s),u=Er(t,j(s));for(let c=0;c<i;++c){const d=Cc(c,o,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];u[hi(h,o,l)]=e[c]}return u}function Ps(e){const{inputs:n,attrs:t,backend:r}=e,{x:s}=n,{perm:o}=t;Te(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[o[d]];const u=AM(r.data.get(s.dataId).values,s.shape,s.dtype,o,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const UDe={kernelName:Sc,backendName:"cpu",kernelFunc:Ps},HDe={kernelName:d0,backendName:"cpu",kernelFunc:function WDe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r;Te(s,"all");const a=pt(o,s.shape);let l=a;const u=Dn(l,s.shape.length);let c=s;null!=u&&(c=Ps({inputs:{x:s},backend:t,attrs:{perm:u}}),l=Hn(l.length,s.shape.length)),Ur("all",l,c.shape.length);const[d,h]=kr(c.shape,l),f=j(h),p=Lr(j(d),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const v=y*f;let b=m[v];for(let w=0;w<f;++w)b=b&&m[v+w];p[y]=b}null!=u&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(d,c.dtype,p);if(i){const v=an({inputs:{x:g},backend:t,attrs:{shape:Wn(d,a)}});return t.disposeIntermediateTensorInfo(g),v}return g}},GDe={kernelName:h0,backendName:"cpu",kernelFunc:function jDe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r;Te(s,"any");const a=pt(o,s.shape);let l=a;const u=Dn(l,s.shape.length);let c=s;null!=u&&(c=Ps({inputs:{x:s},backend:t,attrs:{perm:u}}),l=Hn(l.length,s.shape.length)),Ur("any",l,c.shape.length);const[d,h]=kr(c.shape,l),f=j(h),p=Lr(j(d),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const v=y*f;let b=m[v];for(let w=0;w<f;++w)b=b||m[v+w];p[y]=b}null!=u&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(d,c.dtype,p);if(i){const v=an({inputs:{x:g},backend:t,attrs:{shape:Wn(d,a)}});return t.disposeIntermediateTensorInfo(g),v}return g}},KDe={kernelName:Og,backendName:"cpu",kernelFunc:function qDe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o}=r;Te(s,"argMax");let i=pt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Ps({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),i=Hn(i.length,l.shape.length)),i=[i[0]],Ur("argMax",i,l.shape.length);const[c,d]=kr(l.shape,i),f=Lr(j(c),"int32"),p=j(d),m=t.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let v=m[y],b=0;for(let w=0;w<p;++w){const x=m[y+w];x>v&&(v=x,b=w)}f[g]=b}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",f)}},YDe={kernelName:Fg,backendName:"cpu",kernelFunc:function XDe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o}=r;Te(s,"argMin");let i=pt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=Ps({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),i=Hn(i.length,l.shape.length)),i=[i[0]],Ur("argMin",i,l.shape.length);const[c,d]=kr(l.shape,i),f=Lr(j(c),"int32"),p=j(d),m=t.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let v=m[y],b=0;for(let w=0;w<p;++w){const x=m[y+w];x<v&&(v=x,b=w)}f[g]=b}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",f)}},ZDe=Wt(Ph,e=>Math.asin(e)),QDe={kernelName:Ph,backendName:"cpu",kernelFunc:ZDe},JDe=Wt(Lh,e=>Math.asinh(e)),eNe={kernelName:Lh,backendName:"cpu",kernelFunc:JDe},tNe=Wt(Vh,e=>Math.atan(e)),nNe={kernelName:Vh,backendName:"cpu",kernelFunc:tNe},rNe=qn((e,n)=>Math.atan2(e,n)),sNe=pr(zh,rNe),oNe={kernelName:zh,backendName:"cpu",kernelFunc:sNe},iNe=Wt(Bh,e=>Math.atanh(e)),aNe={kernelName:Bh,backendName:"cpu",kernelFunc:iNe};function RM(e,n,t,r,s,o){const i=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=it(s.outShape,t),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],v=s.outShape[2]*s.outShape[3],b=s.outShape[3];for(let w=0;w<s.batchSize;++w){const x=w*y,I=w*r[0];for(let _=0;_<s.inChannels;++_)for(let D=0;D<s.outHeight;++D){const N=D*i-h,T=Math.max(0,N),P=Math.min(s.inHeight,c+N),B=x+D*v;for(let W=0;W<s.outWidth;++W){const H=W*a-f,G=Math.max(0,H),Y=Math.min(s.inWidth,d+H);let Q=p,q=0,J=0;for(let ue=T;ue<P;ue+=l){const me=I+ue*r[1];for(let de=G;de<Y;de+=u){const ge=e[me+de*r[2]+_];"max"===o&&ge>Q?Q=ge:"avg"===o&&(q+=ge,J++)}if(isNaN(Q))break}g[B+W*b+_]="avg"===o?q/J:Q}}}return m}function Q6(e,n,t,r,s=!1,o=!1){const i=it(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=it(n,t,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let v=0;v<r.outHeight;++v){const b=v*a-f;let w=b;for(;w<0;)w+=u;const x=Math.min(r.inHeight,d+b);for(let I=0;I<r.outWidth;++I){const _=I*l-p;let D=_;for(;D<0;)D+=c;const N=Math.min(r.inWidth,h+_);let T=Number.NEGATIVE_INFINITY,P=-1;for(let B=w;B<x;B+=u){const W=B-b;for(let H=D;H<N;H+=c){const G=H-_,Y=m.get(g,B,H,y);Y>T&&(T=Y,P=s?o?((g*r.inHeight+B)*r.inWidth+H)*r.inChannels+y:(B*r.inWidth+H)*r.inChannels+y:W*h+G)}}i.set(P,g,v,I,y)}}return i}function J6(e,n,t,r,s,o){const i=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,v="max"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=it(s.outShape,t),w=b.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[2]*s.outShape[3]*s.outShape[4],_=s.outShape[3]*s.outShape[4],D=s.outShape[4];for(let N=0;N<s.batchSize;++N){const T=N*x,P=N*r[0];for(let B=0;B<s.inChannels;++B)for(let W=0;W<s.outDepth;++W){const H=W*i-m;let G=H;for(;G<0;)G+=u;const Y=Math.min(s.inDepth,h+H),Q=T+W*I;for(let q=0;q<s.outHeight;++q){const J=q*a-g;let ie=J;for(;ie<0;)ie+=c;const ue=Math.min(s.inHeight,f+J),me=Q+q*_;for(let de=0;de<s.outWidth;++de){const xe=de*l-y;let ge=xe;for(;ge<0;)ge+=d;const Ie=Math.min(s.inWidth,p+xe),Fe=me+de*D;let Ue=v,Be=0,ut=0;for(let Ht=G;Ht<Y;Ht+=u){const ln=P+Ht*r[1];for(let Fn=ie;Fn<ue;Fn+=c){const un=ln+Fn*r[2];for(let Yt=ge;Yt<Ie;Yt+=d){const bn=e[un+Yt*r[3]+B];if("max"===o&&bn>Ue?Ue=bn:"avg"===o&&(Be+=bn,ut++),isNaN(Ue))break}if(isNaN(Ue))break}if(isNaN(Ue))break}w[Fe+B]="avg"===o?Be/Math.max(ut,1):Ue}}}}return b}const cNe={kernelName:$g,backendName:"cpu",kernelFunc:function uNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n;Te(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(Br(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Wo(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))d=ca({inputs:{x:s},backend:t});else{const h=t.data.get(s.dataId).values,f=Oe(s.shape),p=RM(h,0,s.dtype,f,c,"avg");d=t.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},hNe={kernelName:Pg,backendName:"cpu",kernelFunc:function dNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Te(s,"avgPool3d");const c=za(s.shape,o,i,1,a,l,u),h=J6(t.data.get(s.dataId).values,0,s.dtype,Oe(s.shape),c,"avg");return t.makeTensorInfo(h.shape,"float32",h.values)}},pNe={kernelName:p0,backendName:"cpu",kernelFunc:function fNe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Te([s,o],"avgPool3DGrad");const c=za(o.shape,i,a,1,l,u),d=c.strideDepth,h=c.strideHeight,f=c.strideWidth,p=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,v=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,I=c.effectiveFilterWidth,_=w-1-c.padInfo.front,D=I-1-c.padInfo.left,N=x-1-c.padInfo.top,T=it(o.shape,"float32"),P=1/(p*m*g),B=t.bufferSync(s);for(let W=0;W<c.batchSize;++W)for(let H=0;H<c.inChannels;++H)for(let G=0;G<c.inDepth;++G)for(let Y=0;Y<c.inHeight;++Y)for(let Q=0;Q<c.inWidth;++Q){const q=G-_,J=Y-N,ie=Q-D;let ue=0;for(let me=0;me<w;me+=y){const de=(q+me)/d;if(!(de<0||de>=c.outDepth||Math.floor(de)!==de))for(let xe=0;xe<x;xe+=v){const ge=(J+xe)/h;if(!(ge<0||ge>=c.outHeight||Math.floor(ge)!==ge))for(let Ie=0;Ie<I;Ie+=b){const Fe=(ie+Ie)/f;Fe<0||Fe>=c.outWidth||Math.floor(Fe)!==Fe||(ue+=B.get(W,de,ge,Fe,H))}}}T.set(ue*P,W,G,Y,Q,H)}return t.makeTensorInfo(T.shape,T.dtype,T.values)}},gNe={kernelName:f0,backendName:"cpu",kernelFunc:function mNe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o}=n,i=o;Te([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Wo(i.shape,a,l,1,u),d=c.strideHeight,h=c.strideWidth,f=c.filterHeight,p=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,v=c.effectiveFilterWidth,b=v-1-c.padInfo.left,w=y-1-c.padInfo.top,x=it(i.shape,"float32"),I=1/(f*p),_=t.data.get(s.dataId).values,D=it(s.shape,"float32",_);for(let N=0;N<c.batchSize;++N)for(let T=0;T<c.inChannels;++T)for(let P=0;P<c.inHeight;++P)for(let B=0;B<c.inWidth;++B){const W=P-w,H=B-b;let G=0;for(let Y=0;Y<y;Y+=m){const Q=(W+Y)/d;if(!(Q<0||Q>=c.outHeight||Math.floor(Q)!==Q))for(let q=0;q<v;q+=g){const J=(H+q)/h;J<0||J>=c.outWidth||Math.floor(J)!==J||(G+=D.get(N,Q,J,T))}}x.set(G*I,N,P,B,T)}return t.makeTensorInfo(x.shape,x.dtype,x.values)}},vNe={kernelName:Zg,backendName:"cpu",kernelFunc:function yNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,scale:o,offset:i,mean:a,variance:l}=n;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Te([s,a,l,o,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=t.data.get(s.dataId).values,d=t.data.get(a.dataId).values,h=t.data.get(l.dataId).values,f=o?t.data.get(o.dataId).values:new Float32Array([1]),p=i?t.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=p.length,y=f.length,v=h.length,b=d.length;let w=0,x=0,I=0,_=0;for(let D=0;D<c.length;++D)m[D]=p[w++]+(c[D]-d[x++])*f[I++]/Math.sqrt(h[_++]+u),w>=g&&(w=0),x>=b&&(x=0),I>=y&&(I=0),_>=v&&(_=0);return t.makeTensorInfo(s.shape,s.dtype,m)}};function e5(e,n,t,r,s){const o=Ok(r,n,t),i=j(t),a=Oe(r);if(o){const d=Fk(n,a);return"string"===s?e.slice(d,d+i):e.subarray(d,d+i)}const u=it(r,s,"string"===s?Xa(e):e),c=it(t,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),f=h.map((p,m)=>p+n[m]);c.set(u.get(...f),...h)}return"string"===s?RG(c.values):c.values}function Zc(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{begin:o,size:i}=r;Te(s,"slice");const[a,l]=OC(s,o,i);Rk(s,a,l);const c=e5(t.data.get(s.dataId).values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,c)}const bNe={kernelName:Ey,backendName:"cpu",kernelFunc:Zc},xNe={kernelName:Vg,backendName:"cpu",kernelFunc:function wNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{blockShape:o,crops:i}=r;Te([s],"batchToSpaceND");const a=o.reduce((y,v)=>y*v),l=gv(s.shape,o,a),u=yv(l.length,o.length),c=vv(s.shape,o,a),d=nR(i,o.length),h=rR(c,i,o.length),f=an({inputs:{x:s},backend:t,attrs:{shape:l}}),p=Ps({inputs:{x:f},backend:t,attrs:{perm:u}}),m=an({inputs:{x:p},backend:t,attrs:{shape:c}}),g=Zc({inputs:{x:m},backend:t,attrs:{begin:d,size:h}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}};function MM(e,n,t,r,s){const o=j(r),i=Lr(s,t);for(let a=0;a<e.length;a++){const l=e[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i[l]+=o>0?n[a]:1)}return i}function t5(e,n,t,r=!1){const s=e.shape[0],o=e.shape[1],i=it([s,t],n.dtype);for(let a=0;a<s;a++)for(let l=0;l<o;l++){const u=e.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||i.set(r?1:n.size>0?i.get(a,u)+n.get(a,l):i.get(a,u)+1,a,u)}return i}const INe={kernelName:m0,backendName:"cpu",kernelFunc:function CNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,weights:o}=n,{size:i}=r,u=MM(t.data.get(s.dataId).values,t.data.get(o.dataId).values,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}},n5=qn((e,n)=>e&n),SNe=pr(Bg,n5),_Ne={kernelName:Bg,backendName:"cpu",kernelFunc:SNe},DNe={kernelName:g0,backendName:"cpu",kernelFunc:function ENe(e){const{inputs:n,backend:t}=e,{s0:r,s1:s}=n,o=t.data.get(r.dataId).values,i=t.data.get(s.dataId).values,a=et(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},r5=ua(e=>Math.ceil(e)),NNe=du(Wh,r5),TNe={kernelName:Wh,backendName:"cpu",kernelFunc:NNe},kNe=Wt(Hh,(e,n)=>e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e),ANe={kernelName:Hh,backendName:"cpu",kernelFunc:kNe},RNe={kernelName:zg,backendName:"cpu",kernelFunc:e=>{const{x:n}=e.inputs,t=e.backend,r=new Float32Array(j(n.shape)),s=t.data.get(n.dataId),i=s.complexTensorInfos.imag,a=t.data.get(s.complexTensorInfos.real.dataId).values,l=t.data.get(i.dataId).values;for(let u=0;u<a.length;u++)r[u]=Math.hypot(a[u],l[u]);return t.makeOutput(r,n.shape,"float32")}};function s5(e,n,t,r){const s=On(t,j(n));if(r&&"string"!==t){let o=0;e.forEach(i=>{const a=j(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;e.forEach(i=>{const a="string"===t?Xa(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*n[1]+o;for(let d=0;d<i.shape[1];++d)s[c+d]=a[l++]}o+=i.shape[1]})}return s}function ap(e){const{inputs:n,backend:t}=e,{input:r}=n,s=t.data.get(r.dataId).complexTensorInfos.imag,o=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,o)}const MNe={kernelName:L0,backendName:"cpu",kernelFunc:ap};function lp(e){const{inputs:n,backend:t,attrs:r}=e,{axis:s}=r,o=pt(s,n[0].shape)[0];JA(n.map(m=>m.shape),o);let a=ta(n.map(m=>m.shape),o);if(0===j(a))return t.makeTensorInfo(a,n[0].dtype,[]);const l=n.filter(m=>j(m.shape)>0);if(1===l.length)return ca({inputs:{x:l[0]},backend:t});if("complex64"===l[0].dtype){const m=l.map(w=>Yc({inputs:{input:w},backend:t})),g=l.map(w=>ap({inputs:{input:w},backend:t})),y=lp({inputs:m,backend:t,attrs:{axis:o}}),v=lp({inputs:g,backend:t,attrs:{axis:o}}),b=eo({inputs:{real:y,imag:v},backend:t});return m.forEach(w=>t.disposeIntermediateTensorInfo(w)),g.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(v),b}const u=l.map(m=>{const y=[-1,j(m.shape.slice(o))];return an({inputs:{x:m},backend:t,attrs:{shape:y}})}),c=u.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));a=ta(u.map(m=>m.shape),1);const h=s5(c,a,n[0].dtype,1===u[0].shape[0]),f=ta(l.map(m=>m.shape),o),p=t.makeTensorInfo(f,n[0].dtype,h);return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}const ONe={kernelName:Ug,backendName:"cpu",kernelFunc:lp};function o5(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Te([s,o],"conv2d");const d=Ua(l),h=Tr(s.shape,o.shape,i,u,a,c,!1,d),f=h.filterHeight,p=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,v=h.padInfo.top,b="channelsLast"===h.dataFormat,w=new Qn(h.outShape,s.dtype),x=Oe(s.shape),I=Oe(o.shape),_=x[0],D=b?x[1]:x[2],N=b?x[2]:1,T=b?1:x[1],P=w.strides[0],B=b?w.strides[1]:w.strides[2],W=b?w.strides[2]:1,H=b?1:w.strides[1],G=t.data.get(s.dataId).values,Y=t.data.get(o.dataId).values,Q=w.values;for(let q=0;q<h.batchSize;++q){const J=q*_,ie=q*P;for(let ue=0;ue<h.outHeight;++ue){const me=ie+ue*B,de=ue*h.strideHeight-v;for(let xe=0;xe<f;++xe){const ge=de+xe*m;if(ge<0||ge>=h.inHeight)continue;const Ie=xe*I[0],Fe=J+ge*D;for(let Ue=0;Ue<h.outWidth;++Ue){const Be=me+Ue*W,ut=Ue*h.strideWidth-y;for(let mt=0;mt<p;++mt){const Ht=ut+mt*g;if(Ht<0||Ht>=h.inWidth)continue;const Fn=Fe+Ht*N;let un=Ie+mt*I[1];for(let Yt=0;Yt<h.inChannels;++Yt){const kn=G[Fn+Yt*T];for(let bn=0;bn<h.outChannels;++bn)Q[Be+bn*H]+=kn*Y[un+bn];un+=h.outChannels}}}}}}return t.makeTensorInfo(w.shape,w.dtype,Q)}const FNe={kernelName:Wg,backendName:"cpu",kernelFunc:o5},PNe={kernelName:v0,backendName:"cpu",kernelFunc:function $Ne(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Te([s,o],"conv2dBackpropFilter");const d=Ua(l),h=Tr(s.shape,c,i,1,a,u,!1,d),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,v=new Qn(h.filterShape,"float32"),b=h.padInfo.left,w=h.padInfo.top,x=t.data.get(s.dataId).values,I=t.data.get(o.dataId).values,_=new Qn(s.shape,s.dtype,x),D=new Qn(o.shape,o.dtype,I);for(let N=0;N<m;++N){const T=Math.max(0,Math.ceil((w-N)/f)),P=Math.min(h.outHeight,(h.inHeight+w-N)/f);for(let B=0;B<g;++B){const W=Math.max(0,Math.ceil((b-B)/p)),H=Math.min(h.outWidth,(h.inWidth+b-B)/p);for(let G=0;G<h.inChannels;++G)for(let Y=0;Y<h.outChannels;++Y){let Q=0;for(let q=0;q<h.batchSize;++q)for(let J=T;J<P;++J){const ie=N+J*f-w;for(let ue=W;ue<H;++ue){const me=B+ue*p-b;Q+=y?_.get(q,ie,me,G)*D.get(q,J,ue,Y):_.get(q,G,ie,me)*D.get(q,Y,J,ue)}}v.set(Q,N,B,G,Y)}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}},VNe={kernelName:Hg,backendName:"cpu",kernelFunc:function LNe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Te([s,o],"conv2dBackpropInput");const d=Oe(o.shape),h=Oe(s.shape);let f=Ua(u);const p=Tr(i,o.shape,a,1,l,c,!1,f),m=new Qn(p.inShape,"float32"),g=m.values,y=t.data.get(s.dataId).values,v=t.data.get(o.dataId).values,[b,w,x]=d,{batchSize:I,filterHeight:_,filterWidth:D,inChannels:N,inHeight:T,inWidth:P,outChannels:B,outHeight:W,outWidth:H,strideHeight:G,strideWidth:Y}=p;f=p.dataFormat;const Q=_-1-p.padInfo.top,q=D-1-p.padInfo.left,J="channelsLast"===f,ie=m.strides[0],ue=J?m.strides[1]:m.strides[2],me=J?m.strides[2]:1,de=J?1:m.strides[1],xe=h[0],ge=J?h[1]:h[2],Ie=J?h[2]:1,Fe=J?1:h[1];for(let Ue=0;Ue<I;++Ue)for(let Be=0;Be<N;++Be)for(let ut=0;ut<T;++ut){const mt=ut-Q,Ht=Math.max(0,Math.ceil(mt/G)),ln=Math.min(W,(_+mt)/G);for(let Fn=0;Fn<P;++Fn){const un=Fn-q,Yt=Math.max(0,Math.ceil(un/Y)),kn=Math.min(H,(D+un)/Y);let bn=0;for(let Gr=Ht;Gr<ln;++Gr){const yu=Gr*G-mt;for(let ko=Yt;ko<kn;++ko){const Ei=xe*Ue+ge*Gr+Ie*ko,rl=b*(_-1-yu)+w*(D-1-(ko*Y-un))+x*Be;for(let vu=0;vu<B;++vu)bn+=y[Ei+Fe*vu]*v[rl+vu]}}g[ie*Ue+ue*ut+me*Fn+de*Be]=bn}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}},zNe={kernelName:jg,backendName:"cpu",kernelFunc:function BNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r;Te([s,o],"conv3d");const u=Xl(s.shape,o.shape,i,l,a),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:m,padInfo:g}=u,y=g.front,v=g.left,b=g.top,w=new Qn(u.outShape,s.dtype),x=t.data.get(s.dataId).values,I=t.data.get(o.dataId).values,_=w.values,D=Oe(s.shape),N=Oe(o.shape);for(let T=0;T<u.batchSize;++T){const P=T*D[0],B=T*w.strides[0];for(let W=0;W<u.outDepth;++W){const H=B+W*w.strides[1],G=W*u.strideDepth-y;for(let Y=0;Y<c;++Y){const Q=G+Y*f;if(Q<0||Q>=u.inDepth)continue;const q=Y*N[0],J=P+Q*D[1];for(let ie=0;ie<u.outHeight;++ie){const ue=H+ie*w.strides[2],me=ie*u.strideHeight-b;for(let de=0;de<d;++de){const xe=me+de*p;if(xe<0||xe>=u.inHeight)continue;const ge=q+de*N[1],Ie=J+xe*D[2];for(let Fe=0;Fe<u.outWidth;++Fe){const Ue=ue+Fe*u.outChannels,Be=Fe*u.strideWidth-v;for(let ut=0;ut<h;++ut){const mt=Be+ut*m;if(mt<0||mt>=u.inWidth)continue;const ln=Ie+mt*u.inChannels;let Fn=ge+ut*N[2];for(let un=0;un<u.inChannels;++un){const Yt=x[ln+un];for(let kn=0;kn<u.outChannels;++kn)_[Ue+kn]+=Yt*I[Fn+kn];Fn+=u.outChannels}}}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}},WNe={kernelName:b0,backendName:"cpu",kernelFunc:function UNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r;Te([s,o],"conv3dBackpropFilterV2");const u=Oe(s.shape),c=Oe(o.shape),d=Xl(s.shape,l,i,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,v=new Qn(d.filterShape,"float32"),b=v.values,[w,x,I,_]=v.strides,D=t.data.get(o.dataId).values,[N,T,P,B]=c,W=t.data.get(s.dataId).values,[H,G,Y,Q]=u,q=d.padInfo.front,J=d.padInfo.left,ie=d.padInfo.top;for(let ue=0;ue<m;++ue){const me=Math.max(0,Math.ceil((q-ue)/h)),de=Math.min(d.outDepth,(d.inDepth+q-ue)/h),xe=ue*w;for(let ge=0;ge<g;++ge){const Ie=Math.max(0,Math.ceil((ie-ge)/f)),Fe=Math.min(d.outHeight,(d.inHeight+ie-ge)/f),Ue=ge*x+xe;for(let Be=0;Be<y;++Be){const ut=Math.max(0,Math.ceil((J-Be)/p)),mt=Math.min(d.outWidth,(d.inWidth+J-Be)/p),Ht=Be*I+Ue;for(let ln=0;ln<d.inChannels;++ln){const Fn=ln*_+Ht;for(let un=0;un<d.outChannels;++un){let Yt=0;for(let kn=0;kn<d.batchSize;++kn){const bn=kn*H,nl=kn*N;for(let Gr=me;Gr<de;++Gr){const ko=(ue+Gr*h-q)*G+bn,od=Gr*T+nl;for(let Ei=Ie;Ei<Fe;++Ei){const vu=(ge+Ei*f-ie)*Y+ko,bu=Ei*P+od;for(let wu=ut;wu<mt;++wu)Yt+=W[(Be+wu*p-J)*Q+vu+ln]*D[wu*B+bu+un]}}}b[Fn+un]=Yt}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}},jNe={kernelName:w0,backendName:"cpu",kernelFunc:function HNe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r;Te([s],"conv3dBackpropInputV2");const u=Oe(s.shape),c=Oe(o.shape),d=Xl(l,o.shape,a,1,i),h=new Qn(d.inShape,"float32"),f=h.values,[p,m,g,y]=h.strides,v=t.data.get(s.dataId).values,[b,w,x,I]=u,_=t.data.get(o.dataId).values,[D,N,T,P]=c,{batchSize:B,filterDepth:W,filterHeight:H,filterWidth:G,inChannels:Y,inDepth:Q,inHeight:q,inWidth:J,outChannels:ie,outDepth:ue,outHeight:me,outWidth:de,strideDepth:xe,strideHeight:ge,strideWidth:Ie}=d,Fe=W-1-d.padInfo.front,Ue=H-1-d.padInfo.top,Be=G-1-d.padInfo.left;for(let ut=0;ut<B;++ut)for(let mt=0;mt<Y;++mt)for(let Ht=0;Ht<Q;++Ht){const ln=Ht-Fe,Fn=Math.max(0,Math.ceil(ln/xe)),un=Math.min(ue,(W+ln)/xe);for(let Yt=0;Yt<q;++Yt){const kn=Yt-Ue,bn=Math.max(0,Math.ceil(kn/ge)),nl=Math.min(me,(H+kn)/ge);for(let Gr=0;Gr<J;++Gr){const yu=Gr-Be,ko=Math.max(0,Math.ceil(yu/Ie)),od=Math.min(de,(G+yu)/Ie);let Ei=0;for(let rl=Fn;rl<un;++rl){const vu=rl*xe-ln;for(let bu=bn;bu<nl;++bu){const wu=bu*ge-kn;for(let jv=ko;jv<od;++jv){const hO=b*ut+w*rl+x*bu+I*jv,GUe=D*(W-1-vu)+N*(H-1-wu)+T*(G-1-(jv*Ie-yu))+P*mt;for(let VS=0;VS<ie;++VS)Ei+=v[hO+VS]*_[GUe+VS]}}}f[p*ut+m*Ht+g*Yt+y*Gr+mt]=Ei}}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}},GNe=Wt(jh,e=>Math.cos(e)),qNe={kernelName:jh,backendName:"cpu",kernelFunc:GNe},KNe=Wt(Gh,e=>Math.cosh(e)),XNe={kernelName:Gh,backendName:"cpu",kernelFunc:KNe},ZNe={kernelName:C0,backendName:"cpu",kernelFunc:function YNe(e){const{inputs:n,backend:t,attrs:r}=e,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,[c,d,h,f]=s.shape,p=o.shape[0],[m,g]=a,y=it([p,m,g,f],"float32"),v=t.data.get(o.dataId).values,b=t.data.get(i.dataId).values,w=t.data.get(s.dataId).values,x=Oe(s.shape),I=Oe(y.shape);for(let _=0;_<p;_++){const D=4*_,N=v[D],T=v[D+1],P=v[D+2],B=v[D+3],W=b[_];if(W>=c)continue;const H=m>1?(P-N)*(d-1)/(m-1):0,G=g>1?(B-T)*(h-1)/(g-1):0;for(let Y=0;Y<m;Y++){const Q=m>1?N*(d-1)+Y*H:.5*(N+P)*(d-1);if(Q<0||Q>d-1)for(let q=0;q<g;q++)for(let J=0;J<f;J++)y.values[J+q*I[2]+Y*I[1]+_*I[0]]=u;else if("bilinear"===l){const q=Math.floor(Q),J=Math.ceil(Q),ie=Q-q;for(let ue=0;ue<g;ue++){const me=g>1?T*(h-1)+ue*G:.5*(T+B)*(h-1);if(me<0||me>h-1){for(let Ie=0;Ie<f;Ie++)y.values[Ie+ue*I[2]+Y*I[1]+_*I[0]]=u;continue}const de=Math.floor(me),xe=Math.ceil(me),ge=me-de;for(let Ie=0;Ie<f;Ie++){let Fe=Ie+de*x[2]+q*x[1]+W*x[0];const Ue=w[Fe];Fe=Ie+xe*x[2]+q*x[1]+W*x[0];const Be=w[Fe];Fe=Ie+de*x[2]+J*x[1]+W*x[0];const ut=w[Fe];Fe=Ie+xe*x[2]+J*x[1]+W*x[0];const mt=w[Fe],Ht=Ue+(Be-Ue)*ge;Fe=Ie+ue*I[2]+Y*I[1]+_*I[0],y.values[Fe]=Ht+(ut+(mt-ut)*ge-Ht)*ie}}}else for(let q=0;q<g;++q){const J=g>1?T*(h-1)+q*G:.5*(T+B)*(h-1);if(J<0||J>h-1){for(let me=0;me<f;me++)y.values[me+q*I[2]+Y*I[1]+_*I[0]]=u;continue}const ie=Math.round(J),ue=Math.round(Q);for(let me=0;me<f;me++)y.values[me+q*I[2]+Y*I[1]+_*I[0]]=w[me+ie*x[2]+ue*x[1]+W*x[0]]}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}},JNe={kernelName:x0,backendName:"cpu",kernelFunc:function QNe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;Te(s,"cumprod");const l=Dn([o],s.shape.length);let u=s;null!=l&&(u=Ps({inputs:{x:s},backend:t,attrs:{perm:l}}));const c=Hn(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ts(u.dtype,"int32"),h=c0(j(u.shape),d),f=t.data.get(u.dataId).values,p=u.shape[u.shape.length-1],m=a?(y,v)=>y+p-v-1:(y,v)=>y+v;for(let y=0;y<f.length;y+=p)for(let v=0;v<p;v++){const b=m(y,v);if(0===v)h[b]=i?1:f[b];else{const w=m(y,v-1);h[b]=i?f[w]*h[w]:f[b]*h[w]}}const g=t.makeTensorInfo(u.shape,d,h);if(null!=l){const v=Ps({inputs:{x:g},backend:t,attrs:{perm:Ql(l)}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),v}return g}},tTe={kernelName:Gg,backendName:"cpu",kernelFunc:function eTe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;Te(s,"cumsum");const l=Dn([o],s.shape.length);let u=s;null!=l&&(u=Ps({inputs:{x:s},backend:t,attrs:{perm:l}}));const c=Hn(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ts(u.dtype,"int32"),h=Lr(j(u.shape),d),f=t.data.get(u.dataId).values,p=u.shape[u.shape.length-1],m=a?(y,v)=>y+p-v-1:(y,v)=>y+v;for(let y=0;y<f.length;y+=p)for(let v=0;v<p;v++){const b=m(y,v);if(0===v)h[b]=i?0:f[b];else{const w=m(y,v-1);h[b]=i?f[w]+h[w]:f[b]+h[w]}}const g=t.makeTensorInfo(u.shape,d,h);if(null!=l){const v=Ps({inputs:{x:g},backend:t,attrs:{perm:Ql(l)}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),v}return g}},rTe={kernelName:I0,backendName:"cpu",kernelFunc:function nTe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const c=MM(t.data.get(s.dataId).values,t.data.get(o.dataId).values,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const c=t5(t.bufferSync(s),t.bufferSync(o),i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},oTe={kernelName:S0,backendName:"cpu",kernelFunc:function sTe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{blockSize:o,dataFormat:i}=r;S("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*o,h=u*o,f=c/(o*o),p=t.data.get(s.dataId).values,m=new Float32Array(a*d*h*f);let g=0;for(let y=0;y<a;++y)for(let v=0;v<d;++v){const b=Math.floor(v/o),w=v%o;for(let x=0;x<h;++x){const I=Math.floor(x/o),D=(w*o+x%o)*f;for(let N=0;N<f;++N)m[g++]=p[N+D+c*(I+u*(b+l*y))]}}return t.makeTensorInfo([a,d,h,f],s.dtype,m)}};function i5(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;Te([s,o],"depthwiseConv2DNative");const c=Oe(s.shape),d=Oe(o.shape);let h=l;null==h&&(h=[1,1]),S(Br(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const f=Tr(s.shape,o.shape,i,h,a,u,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:v}=f,b=v.left,w=v.top,x=f.outChannels/f.inChannels,I=new Qn(f.outShape,s.dtype),_=t.data.get(s.dataId).values,D=t.data.get(o.dataId).values,N=I.values;for(let T=0;T<f.batchSize;++T){const P=T*c[0],B=T*I.strides[0];for(let W=0;W<f.outHeight;++W){const H=B+W*I.strides[1],G=W*f.strideHeight-w;for(let Y=0;Y<p;++Y){const Q=G+Y*g;if(Q<0||Q>=f.inHeight)continue;const q=Y*d[0],J=P+Q*c[1];for(let ie=0;ie<f.outWidth;++ie){const ue=H+ie*I.strides[2],me=ie*f.strideWidth-b;for(let de=0;de<m;++de){const xe=me+de*y;if(xe<0||xe>=f.inWidth)continue;const Ie=J+xe*f.inChannels;let Fe=ue,Ue=q+de*d[1];for(let Be=0;Be<f.inChannels;++Be){const ut=_[Ie+Be];for(let mt=0;mt<x;++mt)N[Fe+mt]+=ut*D[Ue+mt];Fe+=x,Ue+=x}}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const iTe={kernelName:qg,backendName:"cpu",kernelFunc:i5},lTe={kernelName:_0,backendName:"cpu",kernelFunc:function aTe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Te([s,o],"depthwiseConv2dNativeBackpropFilter");const d=Tr(s.shape,c,i,a,l,u,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:m}=d,g=new Qn(d.filterShape,"float32"),y=d.padInfo.left,v=d.padInfo.top,b=d.outChannels/d.inChannels,w=t.data.get(s.dataId).values,x=new Qn(s.shape,s.dtype,w),I=t.data.get(o.dataId).values,_=new Qn(o.shape,o.dtype,I);for(let D=0;D<p;++D){const N=Math.max(0,Math.ceil((v-D)/h)),T=Math.min(d.outHeight,(d.inHeight+v-D)/h);for(let P=0;P<m;++P){const B=Math.max(0,Math.ceil((y-P)/f)),W=Math.min(d.outWidth,(d.inWidth+y-P)/f);for(let H=0;H<d.outChannels;++H){const G=Math.trunc(H/b),Y=H%b;let Q=0;for(let q=0;q<d.batchSize;++q)for(let J=N;J<T;++J){const ie=D+J*h-v;for(let ue=B;ue<W;++ue)Q+=x.get(q,ie,P+ue*f-y,G)*_.get(q,J,ue,H)}g.set(Q,D,P,G,Y)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}},cTe={kernelName:E0,backendName:"cpu",kernelFunc:function uTe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Te([s,o],"depthwiseConv2DNativeBackpropInput");const d=Oe(s.shape),h=Oe(o.shape),f=Tr(c,o.shape,i,a,l,u,!0),p=new Qn(f.inShape,"float32"),m=p.values,[g,y,v]=p.strides,b=t.data.get(s.dataId).values,[w,x,I]=d,_=t.data.get(o.dataId).values,[D,N,T]=h,{batchSize:P,filterHeight:B,filterWidth:W,inChannels:H,inHeight:G,inWidth:Y,outChannels:Q,outHeight:q,outWidth:J,strideHeight:ie,strideWidth:ue}=f,me=B-1-f.padInfo.top,de=W-1-f.padInfo.left,xe=Q/H;for(let ge=0;ge<P;++ge)for(let Ie=0;Ie<H;++Ie)for(let Fe=0;Fe<G;++Fe){const Ue=Fe-me,Be=Math.max(0,Math.ceil(Ue/ie)),ut=Math.min(q,(B+Ue)/ie);for(let mt=0;mt<Y;++mt){const Ht=mt-de,ln=Math.max(0,Math.ceil(Ht/ue)),Fn=Math.min(J,(W+Ht)/ue);let un=0;for(let Yt=Be;Yt<ut;++Yt){const kn=Yt*ie-Ue;for(let bn=ln;bn<Fn;++bn){const Gr=w*ge+x*Yt+I*bn,yu=D*(B-1-kn)+N*(W-1-(bn*ue-Ht))+T*Ie;for(let ko=0;ko<xe;++ko)un+=b[Gr+(Ie*xe+ko)]*_[yu+ko]}}m[g*ge+y*Fe+v*mt+Ie]=un}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}},hTe={kernelName:D0,backendName:"cpu",kernelFunc:function dTe(e){const{inputs:n,backend:t}=e,{x:r}=n,s=j(r.shape),o=t.data.get(r.dataId).values,i=it([s,s],r.dtype),a=i.values;for(let u=0;u<o.length;u++)a[u*s+u]=o[u];const l=[...r.shape,...r.shape];return t.makeTensorInfo(l,i.dtype,i.values)}},fTe={kernelName:Kg,backendName:"cpu",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:r,filter:s}=e,{strides:o,pad:i,dilations:a}=t,l=n,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:v,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:I,filterWidth:_,dilationHeight:D,dilationWidth:N,outShape:T}=Yy(r.shape,s.shape,o,i,"NHWC",a),P=j(T),B=T.length,W=On(r.dtype,P);for(let G=0;G<f;++G)for(let Y=0;Y<y;++Y){const Q=Y*w-b.top;for(let q=0;q<v;++q){const J=q*x-b.left;for(let ie=0;ie<g;++ie){let ue=Number.MIN_SAFE_INTEGER;for(let de=0;de<I;++de){const xe=Q+de*D;if(xe>=0&&xe<p)for(let ge=0;ge<_;++ge){const Ie=J+ge*N;if(Ie>=0&&Ie<m){const Fe=hi([G,xe,Ie,ie],c,Oe(r.shape)),Ue=hi([de,ge,ie],h,Oe(s.shape)),Be=u[Fe]+d[Ue];Be>ue&&(ue=Be)}}}W[hi([G,Y,q,ie],B,Oe(T))]=ue}}}return{dataId:l.write(Wl(W,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},pTe={kernelName:T0,backendName:"cpu",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:r,filter:s,dy:o}=e,{strides:i,pad:a,dilations:l}=t,u=n,c=go(r.shape,u.data.get(r.dataId).values),d=go(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:b,strideWidth:w,filterHeight:x,filterWidth:I,dilationHeight:_,dilationWidth:D,outShape:N}=Yy(r.shape,s.shape,i,a,"NHWC",l);S(o.rank===N.length,()=>`Error in ${T0}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);const T=go(N,u.data.get(o.dataId).values),P=M1(s.shape,s.dtype);for(let W=0;W<h;++W)for(let H=0;H<g;++H){const G=H*b-v.top;for(let Y=0;Y<y;++Y){const Q=Y*w-v.left;for(let q=0;q<m;++q){let J=Number.MIN_SAFE_INTEGER,ie=0,ue=0;for(let me=0;me<x;++me){const de=G+me*_;if(de>=0&&de<f)for(let xe=0;xe<I;++xe){const ge=Q+xe*D;if(ge>=0&&ge<p){const Ie=c[W][de][ge][q]+d[me][xe][q];Ie>J&&(J=Ie,ie=me,ue=xe)}}}P[ie][ue][q]+=T[W][H][Y][q]}}}return{dataId:u.write(Wl(P,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},mTe={kernelName:N0,backendName:"cpu",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:r,filter:s,dy:o}=e,{strides:i,pad:a,dilations:l}=t,u=n,c=go(r.shape,u.data.get(r.dataId).values),d=go(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:v,strideHeight:b,strideWidth:w,filterHeight:x,filterWidth:I,dilationHeight:_,dilationWidth:D,outShape:N}=Yy(r.shape,s.shape,i,a,"NHWC",l);S(o.rank===N.length,()=>`Error in ${N0}, dy must have the same rank as output ${N.length}, but got ${o.rank}`);const T=go(N,u.data.get(o.dataId).values),P=M1(r.shape,r.dtype);for(let W=0;W<h;++W)for(let H=0;H<g;++H){const G=H*b-v.top;for(let Y=0;Y<y;++Y){const Q=Y*w-v.left;for(let q=0;q<m;++q){let J=Number.MIN_SAFE_INTEGER,ie=G<0?0:G,ue=Q<0?0:Q;for(let me=0;me<x;++me){const de=G+me*_;if(de>=0&&de<f)for(let xe=0;xe<I;++xe){const ge=Q+xe*D;if(ge>=0&&ge<p){const Ie=c[W][de][ge][q]+d[me][xe][q];Ie>J&&(J=Ie,ie=de,ue=ge)}}}P[W][ie][ue][q]+=T[W][H][Y][q]}}}return{dataId:u.write(Wl(P,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yTe={kernelName:k0,backendName:"cpu",kernelFunc:function gTe(e){const{inputs:n,backend:t,attrs:r}=e,{image:s}=n,{canvas:o,options:i}=r,{contextOptions:a,imageOptions:l}=i||{},u=l?.alpha||1,c=a?.contextType||"2d";if("2d"!==c)throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const d=o.getContext(c,a?.contextAttributes||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,f]=s.shape.slice(0,2),p=2===s.shape.length?1:s.shape[2],m=t.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(f*h*4);for(let b=0;b<h*f;++b){const w=[0,0,0,255*u];for(let I=0;I<p;I++){const _=m[b*p+I];if("float32"===s.dtype){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if("int32"===s.dtype&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);1===p?(w[0]=_*g,w[1]=_*g,w[2]=_*g):w[I]=_*g}const x=4*b;y[x+0]=Math.round(w[0]),y[x+1]=Math.round(w[1]),y[x+2]=Math.round(w[2]),y[x+3]=Math.round(w[3])}o.width=f,o.height=h;const v=new ImageData(y,f,h);return d.putImageData(v,0,0),s}},OM=qn((e,n)=>e*n),vTe=kM((e,n,t,r)=>({real:e*t-n*r,imag:e*r+n*t})),JI=pr(ff,OM,vTe),bTe={kernelName:ff,backendName:"cpu",kernelFunc:JI};function Mv(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r;let a;Te(s,"sum"),a="bool"===s.dtype?hu({inputs:{x:s},backend:t,attrs:{dtype:"int32"}}):ca({inputs:{x:s},backend:t});const l=a.shape.length,u=pt(o,a.shape),c=Dn(u,l);let d=u,h=a;null!=c&&(h=Ps({inputs:{x:a},backend:t,attrs:{perm:c}}),d=Hn(d.length,l)),Ur("sum",d,h.shape.length);const[f,p]=kr(h.shape,d);let g=QI(t,f,Ts(h.dtype,"int32"));const y=j(p),v=t.data.get(g.dataId).values,b=t.data.get(h.dataId).values;for(let w=0;w<v.length;++w){const x=w*y;let I=0;for(let _=0;_<y;++_)I+=b[x+_];v[w]=I}if(i){const x=g;g=an({inputs:{x:g},backend:t,attrs:{shape:Wn(g.shape,u)}}),t.disposeIntermediateTensorInfo(x)}return t.disposeIntermediateTensorInfo(a),null!=c&&t.disposeIntermediateTensorInfo(h),g}const wTe={kernelName:Dy,backendName:"cpu",kernelFunc:Mv},CTe={kernelName:A0,backendName:"cpu",kernelFunc:function xTe(e){const{inputs:n,backend:t,attrs:r}=e,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:l}=hR(s,o.length);pR(i.length,l,o);const{path:u,steps:c}=mR(a,l),d=c.length;let h=null,f=i.length;const p=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:v}=fR(f,l[g]);let b;gR(y)?b=o[g]:(b=Ps({inputs:{x:o[g]},backend:t,attrs:{perm:y}}),p.push(b));const w=b.shape.slice();for(let x=0;x<v.length;++x)w.splice(v[x],0,1);wt(b.shape,w)||(b=an({inputs:{x:b},backend:t,attrs:{shape:w}}),p.push(b)),null===h?h=b:(h=JI({inputs:{a:b,b:h},backend:t}),p.push(h))}m<d-1&&(u[m]>=0&&(h=Mv({inputs:{x:h},backend:t,attrs:{axis:u[m]-(i.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&t.disposeIntermediateTensorInfo(m);return h}},STe={kernelName:R0,backendName:"cpu",kernelFunc:function ITe(e){const{inputs:n,backend:t}=e,{dy:r,y:s}=n;Te([r,s],"eluGrad");const o=new Float32Array(j(s.shape)),i=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];o[l]=u>=0?a[l]:a[l]*(u+1)}return t.makeTensorInfo(s.shape,"float32",o)}},a5=qn((e,n)=>e===n?1:0),l5=pr(Xg,a5,null,"bool"),_Te={kernelName:Xg,backendName:"cpu",kernelFunc:l5},ETe=sR,DTe=oR,NTe=iR,TTe=aR,kTe=lR,ATe=uR,RTe=Wt(Xh,e=>{const n=Math.sign(e),t=Math.abs(e),r=1/(1+ETe*t);return n*(1-((((ATe*r+kTe)*r+TTe)*r+NTe)*r+DTe)*r*Math.exp(-t*t))}),MTe={kernelName:Xh,backendName:"cpu",kernelFunc:RTe},u5=ua(e=>Math.exp(e)),c5=du(Yh,u5,"float32"),OTe={kernelName:Yh,backendName:"cpu",kernelFunc:c5};function eS(e){const{inputs:n,backend:t,attrs:r}=e,{input:s}=n,{dim:o}=r,i=s.shape.length,a=s.shape.slice();let l=o;return o<0&&(S(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),an({inputs:{x:s},backend:t,attrs:{shape:a}})}const FTe={kernelName:Yg,backendName:"cpu",kernelFunc:eS},d5=ua(e=>Math.expm1(e)),$Te=du(Zh,d5),PTe={kernelName:Zh,backendName:"cpu",kernelFunc:$Te},LTe=qn((e,n)=>e/n),FM=pr(qh,LTe),$M={kernelName:qh,backendName:"cpu",kernelFunc:FM},h5=qn((e,n)=>e-n),VTe=kM((e,n,t,r)=>({real:e-t,imag:n-r})),PM=pr(Nf,h5,VTe),BTe={kernelName:Nf,backendName:"cpu",kernelFunc:PM};function f5(e,n,t){const r=e.shape,s=r[0],o=r[1],i=t.data.get(e.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,o],c=j(u),d=Er("float32",c),h=Er("float32",c);for(let g=0;g<s;g++){const y=Zc({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,o]}}),v=Zc({inputs:{x:l},backend:t,attrs:{begin:[g,0],size:[1,o]}}),b=eo({inputs:{real:y,imag:v},backend:t}),{real:w,imag:x}=zTe(b,n,t),I=Ka(w,x);for(let _=0;_<o;_++){const D=cR(I,_);d[g*o+_]=D.real,h[g*o+_]=D.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(b)}const f=t.makeTensorInfo(u,"float32",d),p=t.makeTensorInfo(u,"float32",h),m=eo({inputs:{real:f,imag:p},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),m}function zTe(e,n,t){const r=j(e.shape),s=t.data.get(e.dataId),o=t.data.get(s.complexTensorInfos.real.dataId).values,i=t.data.get(s.complexTensorInfos.imag.dataId).values;if(function UTe(e){return!(e&e-1)}(r)){const a=LM(o,i,r,n,t),l=[e.shape[0],e.shape[1]];if(n){const u=t.makeTensorInfo(l,"float32",a.real),c=t.makeTensorInfo(l,"float32",a.imag),d=t.makeTensorInfo([],"float32",$a(r,"float32")),h=ca({inputs:{x:d},backend:t}),f=$M.kernelFunc({inputs:{a:u,b:d},backend:t}),p=$M.kernelFunc({inputs:{a:c,b:h},backend:t}),m=t.data.get(f.dataId).values,g=t.data.get(p.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}{const l=function WTe(e,n,t){const r=new Float32Array(2*n);for(let s=0;s<n;s++){let o=0,i=0;for(let a=0;a<n;a++){const l=gG(s*a,n,t),u=cR(e,a);o+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}t&&(o/=n,i/=n),pG(r,o,i,s)}return r}(Ka(o,i),r,n);return dG(l)}}function LM(e,n,t,r,s){if(1===t)return{real:e,imag:n};const o=Ka(e,n),i=t/2,a=hG(o),l=a.real,u=a.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),f=eo({inputs:{real:d,imag:h},backend:s}),p=fG(o),m=p.real,g=p.imag,y=[m.length],v=s.makeTensorInfo(y,"float32",m),b=s.makeTensorInfo(y,"float32",g),w=eo({inputs:{real:v,imag:b},backend:s}),x=LM(l,u,i,r,s),I=x.real,_=x.imag,D=[I.length],N=s.makeTensorInfo(D,"float32",I),T=s.makeTensorInfo(D,"float32",_),P=eo({inputs:{real:N,imag:T},backend:s}),B=LM(m,g,i,r,s),W=B.real,H=B.imag,G=[W.length],Y=s.makeTensorInfo(G,"float32",W),Q=s.makeTensorInfo(G,"float32",H),q=eo({inputs:{real:Y,imag:Q},backend:s}),J=mG(t,r),ie=[J.real.length],ue=s.makeTensorInfo(ie,"float32",J.real),me=s.makeTensorInfo(ie,"float32",J.imag),de=eo({inputs:{real:ue,imag:me},backend:s}),xe=JI({inputs:{a:de,b:q},backend:s}),ge=ip({inputs:{a:P,b:xe},backend:s}),Ie=PM({inputs:{a:P,b:xe},backend:s}),Fe=Yc({inputs:{input:ge},backend:s}),Ue=Yc({inputs:{input:Ie},backend:s}),Be=ap({inputs:{input:ge},backend:s}),ut=ap({inputs:{input:Ie},backend:s}),mt=lp({inputs:[Fe,Ue],backend:s,attrs:{axis:0}}),Ht=lp({inputs:[Be,ut],backend:s,attrs:{axis:0}}),ln=s.data.get(mt.dataId).values,Fn=s.data.get(Ht.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(Y),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(me),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(xe),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(Ie),s.disposeIntermediateTensorInfo(Fe),s.disposeIntermediateTensorInfo(Be),s.disposeIntermediateTensorInfo(Ue),s.disposeIntermediateTensorInfo(ut),s.disposeIntermediateTensorInfo(mt),s.disposeIntermediateTensorInfo(Ht),{real:ln,imag:Fn}}const jTe={kernelName:M0,backendName:"cpu",kernelFunc:function HTe(e){const{inputs:n,backend:t}=e,{input:r}=n,s=j(r.shape),o=r.shape[r.shape.length-1],a=an({inputs:{x:r},backend:t,attrs:{shape:[s/o,o]}}),l=f5(a,!1,t),u=an({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}};function VM(e){const{backend:n,attrs:t}=e,{shape:r,value:s,dtype:o}=t,i=o||xc(s),a=On(i,j(r));return function qTe(e,n){e.fill(n)}(a,s),n.makeTensorInfo(r,i,a)}const GTe={kernelName:O0,backendName:"cpu",kernelFunc:VM},KTe={kernelName:F0,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{image:r}=e,s=t,o=Er(r.dtype,j(r.shape)),[i,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const f=h*l*a*u;for(let p=0;p<a;p++){const m=p*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let v=0;v<u;v++){const b=Math.round(l-g-1),w=f+m+y+v;let x=c[w];b>=0&&b<l&&(x=c[f+m+b*u+v]),o[w]=x}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},p5=ua(e=>Math.floor(e)),XTe=du(Qh,p5),YTe={kernelName:Qh,backendName:"cpu",kernelFunc:XTe},ZTe=qn((e,n)=>Math.floor(e/n)),QTe=pr(Jh,ZTe,null,"int32"),JTe={kernelName:Jh,backendName:"cpu",kernelFunc:QTe},t1e={kernelName:$y,backendName:"cpu",kernelFunc:function e1e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=o5({inputs:{x:s,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const y=an({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});m=ip({inputs:{a:m,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else m=ip({inputs:{a:m,b:i},backend:t});t.disposeIntermediateTensorInfo(g)}if(f){const g=m;if("NCHW"===c&&"prelu"===f&&1===a.shape.length&&1!==a.shape[0]){const y=an({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});m=ZI(t,m,f,y,p),t.disposeIntermediateTensorInfo(y)}else m=ZI(t,m,f,a,p);t.disposeIntermediateTensorInfo(g)}return m}},r1e={kernelName:Py,backendName:"cpu",kernelFunc:function n1e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=i5({inputs:{x:s,filter:o},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=ip({inputs:{a:m,b:i},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=ZI(t,m,f,a,p),t.disposeIntermediateTensorInfo(g)}return m}};function m5(e,n,t,r,s,o,i,a,l){const u=it([r,o],t);for(let c=0;c<r;c++){const d=[];let h=0;for(let f=0;f<s;f++){const p=e[c*s+f];h+=p*i[f],d.push(p)}if(h<0||h>=l/o)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let f=0;f<o;f++)u.values[c*o+f]=n.get(...n.indexToLoc(h*o+f))}return u}const o1e={kernelName:$0,backendName:"cpu",kernelFunc:function s1e(e){const{inputs:n,backend:t}=e,{params:r,indices:s}=n,o=j(r.shape),i=s.shape,a=i[i.length-1],[l,u,c,d]=RC(r,s);if(0===u)return t.makeTensorInfo(l,r.dtype,[]);const p=m5(t.data.get(s.dataId).values,t.bufferSync(r),r.dtype,u,a,c,d,r.shape,o);return t.makeTensorInfo(l,r.dtype,p.values)}};function g5(e,n,t){const r=it(t,e.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),u=n.locToIndex([i[0],i[2]]);i[2]=n.values[u];const c=e.locToIndex(i);0<=c&&c<e.values.length&&(r.values[s]=e.values[c])}return r}const a1e={kernelName:Qg,backendName:"cpu",kernelFunc:function i1e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,indices:o}=n,{axis:i,batchDims:a}=r;Te([s,o],"gatherV2");const l=pt(i,s.shape)[0],u=t.data.get(o.dataId).values,c=s.shape[l];for(let w=0;w<u.length;++w){const x=u[w];S(x<=c-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${c-1}]`)}let d=a;null==a&&(d=0);const h=j(o.shape),f=bR(s,o,l,d),p=an({inputs:{x:s},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),m=an({inputs:{x:o},backend:t,attrs:{shape:[f.batchSize,h/f.batchSize]}}),g=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],y=t.bufferSync(m),b=g5(t.bufferSync(p),y,g);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(f.outputShape,b.dtype,b.values)}},y5=qn((e,n)=>e>n?1:0),l1e=pr(Jg,y5,null,"bool"),u1e={kernelName:Jg,backendName:"cpu",kernelFunc:l1e},v5=qn((e,n)=>e>=n?1:0),c1e=pr(ef,v5,null,"bool"),d1e={kernelName:ef,backendName:"cpu",kernelFunc:c1e},f1e={kernelName:P0,backendName:"cpu",kernelFunc:function h1e(e){const{inputs:n,backend:t}=e,{input:r}=n,s=j(r.shape),o=r.shape[r.shape.length-1],a=an({inputs:{x:r},backend:t,attrs:{shape:[s/o,o]}}),l=f5(a,!0,t),u=an({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}},p1e=Wt(rf,e=>Number.isFinite(e)?1:0,"bool"),m1e={kernelName:rf,backendName:"cpu",kernelFunc:p1e},g1e=Wt(sf,e=>Math.abs(e)===1/0?1:0,"bool"),y1e={kernelName:sf,backendName:"cpu",kernelFunc:g1e},v1e=Wt(af,e=>Number.isNaN(e)?1:0,"bool"),b1e={kernelName:af,backendName:"cpu",kernelFunc:v1e},b5=qn((e,n)=>e<n?1:0),w1e=pr(ty,b5,null,"bool"),x1e={kernelName:ty,backendName:"cpu",kernelFunc:w1e},w5=qn((e,n)=>e<=n?1:0),C1e=pr(ny,w5,null,"bool"),I1e={kernelName:ny,backendName:"cpu",kernelFunc:C1e};function x5(e,n,t){const r=(n-e)/(t-1),s=Lr(t,"float32");s[0]=e;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const _1e={kernelName:V0,backendName:"cpu",kernelFunc:function S1e(e){const{backend:n,attrs:t}=e,{start:r,stop:s,num:o}=t,i=x5(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},C5=ua(e=>Math.log(e)),E1e=du(lf,C5),D1e={kernelName:lf,backendName:"cpu",kernelFunc:E1e},N1e=Wt(uf,e=>Math.log1p(e)),T1e={kernelName:uf,backendName:"cpu",kernelFunc:N1e},k1e=qn((e,n)=>e&&n),A1e=pr(ry,k1e,null,"bool"),R1e={kernelName:ry,backendName:"cpu",kernelFunc:A1e},M1e=Wt(sy,e=>e?0:1,"bool"),O1e={kernelName:sy,backendName:"cpu",kernelFunc:M1e},F1e=qn((e,n)=>e||n),$1e=pr(oy,F1e,null,"bool"),P1e={kernelName:oy,backendName:"cpu",kernelFunc:$1e},V1e={kernelName:iy,backendName:"cpu",kernelFunc:function L1e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r;Te(s,"LRN");const u=s.shape[3],c=u-1,d=t.data.get(s.dataId).values,h=j(s.shape),f=new Float32Array(h);function p(m){const g=m%u;let y=m-g+Math.max(0,g-o);const v=m-g+Math.min(g+o,c);let b=0;for(;y<=v;y++){const w=d[y];b+=w*w}return b}for(let m=0;m<h;m++){const g=p(m),y=d[m]*Math.pow(i+a*g,-l);f[m]=y}return t.makeTensorInfo(s.shape,s.dtype,f)}},z1e={kernelName:B0,backendName:"cpu",kernelFunc:function B1e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Te(i,"LRNGrad");const d=j(i.shape),h=i.shape[3],f=t.data.get(i.dataId).values,p=t.data.get(s.dataId).values,m=t.data.get(o.dataId).values,g=new Float32Array(d),y=d;for(let v=0;v<y;v++){const b=v%h,w=v-b+Math.max(0,b-a),x=v-b+Math.min(h,b+a+1);let I=0;for(let _=w;_<x;_++)I+=Math.pow(p[_],2);I=u*I+l;for(let _=w;_<x;_++){let D=-2*u*c*p[_]*m[v]/I;v===_&&(D+=Math.pow(I,-c)),D*=f[v],g[_]+=D}}return t.makeTensorInfo(i.shape,s.dtype,g)}};function I5(e,n,t,r){const s=Er(r,j(t));for(let o=0;o<s.length;++o){const i=o*n;let a=e[i];for(let l=0;l<n;++l){const u=e[i+l];(Number.isNaN(u)||u>a)&&(a=u)}s[o]=a}return s}function S5(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=t;let l=s.shape;const u=l.length,c=pt(o,l);let d=c;const h=Dn(d,u);let f=a.data.get(s.dataId).values;if(null!=h){const w=new Array(u);for(let x=0;x<w.length;x++)w[x]=l[h[x]];f=AM(f,l,s.dtype,h,w),d=Hn(d.length,u),l=w}Te(s,"max"),Ur("max",d,u);const[p,m]=kr(l,d),y=I5(f,j(m),p,s.dtype),v=a.write(y,p,s.dtype);let b=p;return i&&(b=Wn(p,c)),{dataId:v,shape:b,dtype:s.dtype}}const U1e={kernelName:ay,backendName:"cpu",kernelFunc:S5},_5=qn((e,n)=>Math.max(e,n)),W1e=pr(cf,_5),H1e={kernelName:cf,backendName:"cpu",kernelFunc:W1e},G1e={kernelName:ly,backendName:"cpu",kernelFunc:function j1e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n;Te(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(Br(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Wo(s.shape,o,i,1,a,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))d=ca({inputs:{x:s},backend:t});else{const h=t.data.get(s.dataId).values,f=Oe(s.shape),p=RM(h,0,s.dtype,f,c,"max");d=t.makeTensorInfo(c.outShape,s.dtype,p.values)}return d}},K1e={kernelName:uy,backendName:"cpu",kernelFunc:function q1e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r;Te(s,"maxPool3d");const c=za(s.shape,o,i,1,a,l,u),h=J6(t.data.get(s.dataId).values,0,s.dtype,Oe(s.shape),c,"max");return t.makeTensorInfo(h.shape,"float32",h.values)}},Y1e={kernelName:U0,backendName:"cpu",kernelFunc:function X1e(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:u}=r;Te([s,o],"maxPool3DGrad");const c=za(o.shape,i,a,1,l,u),h=function lNe(e,n){const t=it(n.outShape,"int32"),r=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterDepth,c=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=n.padInfo.front,f=n.padInfo.top,p=n.padInfo.left;for(let m=0;m<n.batchSize;++m)for(let g=0;g<n.inChannels;++g)for(let y=0;y<n.outDepth;++y){const v=y*r-h;let b=v;for(;b<0;)b+=i;const w=Math.min(n.inDepth,u+v);for(let x=0;x<n.outHeight;++x){const I=x*s-f;let _=I;for(;_<0;)_+=a;const D=Math.min(n.inHeight,c+I);for(let N=0;N<n.outWidth;++N){const T=N*o-p;let P=T;for(;P<0;)P+=l;const B=Math.min(n.inWidth,d+T);let W=Number.NEGATIVE_INFINITY,H=-1;for(let G=b;G<w;G+=i){const Y=G-v;for(let Q=_;Q<D;Q+=a){const q=Q-I;for(let J=P;J<B;J+=l){const ie=J-T,ue=e.get(m,G,Q,J,g);ue>=W&&(W=ue,H=Y*c*d+q*c+ie)}}}t.set(H,m,y,x,N,g)}}}return t}(t.bufferSync(o),c),f=c.strideDepth,p=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,v=c.dilationWidth,b=c.effectiveFilterDepth,w=c.effectiveFilterHeight,x=c.effectiveFilterWidth,I=b-1-c.padInfo.front,_=x-1-c.padInfo.left,D=w-1-c.padInfo.top,N=it(o.shape,"float32"),T=t.bufferSync(s);for(let P=0;P<c.batchSize;++P)for(let B=0;B<c.inChannels;++B)for(let W=0;W<c.inDepth;++W)for(let H=0;H<c.inHeight;++H)for(let G=0;G<c.inWidth;++G){const Y=W-I,Q=H-D,q=G-_;let J=0;for(let ie=0;ie<b;ie+=g){const ue=(Y+ie)/f;if(!(ue<0||ue>=c.outDepth||Math.floor(ue)!==ue))for(let me=0;me<w;me+=y){const de=(Q+me)/p;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let xe=0;xe<x;xe+=v){const ge=(q+xe)/m;if(ge<0||ge>=c.outWidth||Math.floor(ge)!==ge)continue;const Ue=b*w*x-1-h.get(P,ue,de,ge,B)===ie*w*x+me*x+xe?1:0;0!==Ue&&(J+=T.get(P,ue,de,ge,B)*Ue)}}}N.set(J,P,W,H,G,B)}return t.makeTensorInfo(N.shape,N.dtype,N.values)}},Q1e={kernelName:z0,backendName:"cpu",kernelFunc:function Z1e(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o,output:i}=n,a=o;Te([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Wo(a.shape,l,u,1,c,d),f=t.data.get(a.dataId).values,p=it(h.outShape,a.dtype,Q6(f,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,v=h.dilationWidth,b=h.effectiveFilterHeight,w=h.effectiveFilterWidth,x=w-1-h.padInfo.left,I=b-1-h.padInfo.top,_=it(a.shape,"float32"),D=t.data.get(s.dataId).values,N=it(s.shape,"float32",D);for(let T=0;T<h.batchSize;++T)for(let P=0;P<h.inChannels;++P)for(let B=0;B<h.inHeight;++B)for(let W=0;W<h.inWidth;++W){const H=B-I,G=W-x;let Y=0;for(let Q=0;Q<b;Q+=y){const q=(H+Q)/m;if(!(q<0||q>=h.outHeight||Math.floor(q)!==q))for(let J=0;J<w;J+=v){const ie=(G+J)/g;if(ie<0||ie>=h.outWidth||Math.floor(ie)!==ie)continue;const de=b*w-1-p.get(T,q,ie,P)===Q*w+J?1:0;0!==de&&(Y+=N.get(T,q,ie,P)*de)}}_.set(Y,T,B,W,P)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}},eke={kernelName:W0,backendName:"cpu",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{x:r}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=t;Te(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=Wo(r.shape,s,o,[1,1],i),[d,h]=function J1e(e,n,t,r,s){const i=RM(e,0,t,Oe(n),s,"max"),a=Q6(e,n,t,s,!0,r);return[i.values,a.values]}(u,r.shape,r.dtype,a,c),f=l.write(d,c.outShape,r.dtype),p=l.write(h,c.outShape,r.dtype);return[{dataId:f,shape:c.outShape,dtype:r.dtype},{dataId:p,shape:c.outShape,dtype:"int32"}]}},nke={kernelName:cy,backendName:"cpu",kernelFunc:function tke(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r,a=pt(o,s.shape),c=j(kr(s.shape,a)[1]),d=[],h=t.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const f=hu({inputs:{x:s},backend:t,attrs:{dtype:"float32"}});d.push(f);const p=FM({inputs:{a:f,b:h},backend:t});d.push(p);const m=Mv({inputs:{x:p},backend:t,attrs:{axis:o,keepDims:i}});return d.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}},ske={kernelName:dy,backendName:"cpu",kernelFunc:function rke(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r;Te(s,"min");const a=pt(o,s.shape);let l=a;const u=Dn(l,s.shape.length);let c=s;null!=u&&(c=Ps({inputs:{x:s},backend:t,attrs:{perm:u}}),l=Hn(l.length,s.shape.length)),Ur("min",l,c.shape.length);const[d,h]=kr(c.shape,l),f=j(h),p=Lr(j(d),c.dtype),m=t.data.get(c.dataId).values;for(let y=0;y<p.length;++y){const v=y*f;let b=m[v];for(let w=0;w<f;++w){const x=m[v+w];(Number.isNaN(x)||x<b)&&(b=x)}p[y]=b}null!=u&&t.disposeIntermediateTensorInfo(c);const g=t.makeTensorInfo(d,c.dtype,p);if(i){const v=an({inputs:{x:g},backend:t,attrs:{shape:Wn(d,a)}});return t.disposeIntermediateTensorInfo(g),v}return g}},E5=qn((e,n)=>Math.min(e,n)),oke=pr(df,E5),ike={kernelName:df,backendName:"cpu",kernelFunc:oke},lke={kernelName:hy,backendName:"cpu",kernelFunc:function ake(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{paddings:o,mode:i}=r;Te(s,"mirrorPad");const a=o.map((b,w)=>b[0]+s.shape[w]+b[1]),l=o.map(b=>b[0]),u=o.map((b,w)=>b[0]+s.shape[w]),c="reflect"===i?0:1,d=t.data.get(s.dataId).values,h=s.shape.length,f=Oe(s.shape),p=j(a),m=a.length,g=Oe(a),y=Er(s.dtype,p);for(let b=0;b<p;b++){let w=Cc(b,m,g);for(let I=0;I<m;I++)w[I]<l[I]?w[I]=2*l[I]-w[I]-c:w[I]>=u[I]&&(w[I]=2*(u[I]-1)-w[I]+c);w=w.map((I,_)=>I-l[_]);const x=hi(w,h,f);y[b]=d[x]}return{dataId:t.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},uke=qn((e,n)=>{const t=e%n;return e<0&&n<0||e>=0&&n>=0?t:(t+n)%n}),cke=pr(hf,uke),dke={kernelName:hf,backendName:"cpu",kernelFunc:cke};function D5(e){const{inputs:n,backend:t,attrs:r}=e,{logits:s}=n,{dim:o}=r,i=s.shape.length;let a=o;if(-1===a&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const l=pt([a],s.shape),u=S5({inputs:{x:s},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=Wn(u.shape,l),d=an({inputs:{x:u},backend:t,attrs:{shape:c}}),h=PM({inputs:{a:s,b:d},backend:t}),f=c5({inputs:{x:h},backend:t}),p=Mv({inputs:{x:f},backend:t,attrs:{axis:l,keepDims:!1}}),m=an({inputs:{x:p},backend:t,attrs:{shape:c}}),g=FM({inputs:{a:f,b:m},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}const hke={kernelName:ky,backendName:"cpu",kernelFunc:D5},pke={kernelName:H0,backendName:"cpu",kernelFunc:function fke(e){const{inputs:n,backend:t,attrs:r}=e,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r;Te(s,"multinomial");const l=a?s:D5({inputs:{logits:s},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=t.data.get(l.dataId).values,h=[u,o],f=Lr(j(h),"int32");for(let p=0;p<u;++p){const m=p*c,g=new Float32Array(c-1);g[0]=d[m];for(let b=1;b<g.length;++b)g[b]=g[b-1]+d[m+b];const y=Xf.alea(i.toString()),v=p*o;for(let b=0;b<o;++b){const w=y();f[v+b]=g.length;for(let x=0;x<g.length;x++)if(w<g[x]){f[v+b]=x;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(h,"int32",f)}};function N5(e,n,t){const r=$a(-1,t);return OM([],n,r,e,t)}const gke={kernelName:fy,backendName:"cpu",kernelFunc:function mke(e){const{inputs:n,backend:t}=e,{x:r}=n;Te(r,"neg");const s=t.data.get(r.dataId).values,[o,i]=N5(s,r.shape,r.dtype);return t.makeTensorInfo(i,r.dtype,o)}},yke=hI,bke={kernelName:j0,backendName:"cpu",kernelFunc:function vke(e){const{inputs:n,backend:t,attrs:r}=e,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;Te(s,"NonMaxSuppression");const u=t.data.get(s.dataId).values,c=t.data.get(o.dataId).values,{selectedIndices:d}=yke(u,c,i,a,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}},wke=fI,Cke={kernelName:G0,backendName:"cpu",kernelFunc:function xke(e){const{inputs:n,backend:t,attrs:r}=e,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Te(s,"NonMaxSuppressionPadded");const c=t.data.get(s.dataId).values,d=t.data.get(o.dataId).values,{selectedIndices:h,validOutputs:f}=wke(c,d,i,a,l,u);return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}},Ike=pI,_ke={kernelName:q0,backendName:"cpu",kernelFunc:function Ske(e){const{inputs:n,backend:t,attrs:r}=e,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Te(s,"NonMaxSuppressionWithScore");const c=t.data.get(s.dataId).values,d=t.data.get(o.dataId).values,h=i,f=a,p=l,m=u,{selectedIndices:g,selectedScores:y}=Ike(c,d,h,f,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},T5=qn((e,n)=>e!==n?1:0),Eke=pr(py,T5,null,"bool"),Dke={kernelName:py,backendName:"cpu",kernelFunc:Eke},Tke={kernelName:gy,backendName:"cpu",kernelFunc:function Nke(e){const{inputs:n,backend:t,attrs:r}=e,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:l}=r;Te(s,"oneHot");const u=j(s.shape),c=new Float32Array(u*i);c.fill(l);const d=t.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=a);return t.makeTensorInfo([...s.shape,i],o,c)}};function tS(e){const{inputs:n,backend:t}=e,{x:r}=n;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Yc({inputs:{input:r},backend:t}),o=tS({inputs:{x:s},backend:t}),i=ap({inputs:{input:r},backend:t}),a=tS({inputs:{x:i},backend:t}),l=eo({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}return VM({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const kke={kernelName:Oy,backendName:"cpu",kernelFunc:tS},Ake={kernelName:my,backendName:"cpu",kernelFunc:function k5(e){const{inputs:n,backend:t}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Yc({inputs:{input:r},backend:t}),o=k5({inputs:{x:s},backend:t}),i=ap({inputs:{input:r},backend:t}),a=tS({inputs:{x:i},backend:t}),l=eo({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}return VM({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function A5(e){const{inputs:n,backend:t,attrs:r}=e,{axis:s}=r;if(1===n.length)return eS({inputs:{input:n[0]},backend:t,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{Pr(o,c.shape,"All tensors passed to stack must have matching shapes"),S(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=lp({inputs:n.map(c=>{const d=eS({inputs:{input:c},backend:t,attrs:{dim:s}});return a.push(d),d}),backend:t,attrs:{axis:s}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const Rke={kernelName:yy,backendName:"cpu",kernelFunc:A5},R5={kernelName:vy,backendName:"cpu",kernelFunc:function Mke(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{paddings:o,constantValue:i}=r;Te(s,"pad");const a=o.map((v,b)=>v[0]+s.shape[b]+v[1]),l=o.map(v=>v[0]),u=t.data.get(s.dataId).values,c=j(s.shape),d=s.shape.length,h=Oe(s.shape),f=j(a),p=a.length,m=Oe(a),g=Er(s.dtype,f);0!==i&&g.fill(i);for(let v=0;v<c;v++)g[hi(Cc(v,d,h).map((I,_)=>I+l[_]),p,m)]=u[v];return{dataId:t.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},Oke=qn((e,n)=>Math.pow(e,n)),Fke=pr(pf,Oke),$ke={kernelName:pf,backendName:"cpu",kernelFunc:Fke};function M5(e,n,t,r){const[s,o]=kr(e,r),i=Ts(n,"int32"),a=Lr(j(s),i),l=j(o);for(let u=0;u<a.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=t[c+h];a[u]=d}return{outVals:a,outShape:s,outDtype:i}}const Lke={kernelName:wy,backendName:"cpu",kernelFunc:function Pke(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r;Te(s,"prod");const a=s.shape.length,l=pt(o,s.shape),u=Dn(l,a);let c=l,d=s;const h=[];null!=u&&(d=Ps({inputs:{x:s},backend:t,attrs:{perm:u}}),h.push(d),c=Hn(c.length,a));const f=t.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=M5(d.shape,d.dtype,f,c);let y=m;return i&&(y=Wn(m,l)),h.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(y,g,p)}};function O5(e,n){const t=e.slice(0,n);for(;t.length<n;)t.push(1);for(let r=n;r<e.length;r++)t[n-1]*=e[r];return t}function F5(e,n,t,r,s,o,i,a){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(function Vke(e,n,t){e.forEach((r,s)=>{if(r<0||r>=t){const o=Cc(s,n.length,Oe(n)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${t})`)}})}(o,i,n[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:h}=function zke(e,n,t,r){const s=[];let o=0;const a=new Array(n.length-1+t.length).fill(null).map(()=>[0]);!function Bke(e,n){for(let t=0;t<e.length;++t){const r=e[t],s=t===e.length-1?n:e[t+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}(t,r);let l=1;for(let u=0;u<n.length-1;++u){l*=n[u];const c=n[u+1];for(let d=1;d<l+1;++d)a[u].push(d*c)}for(let u=0;u<e.length;++u){let c=e[u],d=e[u]+1;for(let h=0;h<t.length;++h){const f=t[h],p=h+n.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-f[c];for(let y=c;y<d;++y)a[p].push(f[y+1]+g)}c=f[c],d=f[d]}d!==c&&(s.push([c,d]),o+=d-c)}return{outSplits:a,valueSlices:s,numValues:o}}(o,i,e,u),f=function Uke(e){const n=[];for(let t=0;t<e.length;++t){const s=On("int32",e[t].length);n.push(s),e[t].forEach((o,i)=>s[i]=o)}return n}(c),p=function Hke(e,n,t,r,s){const o=n.slice();o[0]=s;const i=On(t,j(o)),a=e.length;return function Wke(e,n,t,r,s,o){const i=O5(n,2)[1],a=O5(o,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*a+d]=e[c*i+d];++l}}(e,n,r,0===a?0:a/n[0],i,o),[i,o]}(t,r,s,d,h);return[f,p[0],p[1]]}const Gke={kernelName:K0,backendName:"cpu",kernelFunc:function jke(e){const{inputs:n,backend:t,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,l=s.map(y=>t.data.get(y.dataId).values),u=s.map(y=>y.shape),c=t.data.get(o.dataId).values,d=t.data.get(i.dataId).values,[h,f,p]=F5(l,u,c,o.shape,o.dtype,d,i.shape),m=h.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(p,o.dtype,f);return m.concat([g])}},$5=2147483647;function P5(e,n,t,r,s,o,i){if(n.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=0===n.length,l=0===s.length,u=0===i.length,c=[];a||c.push(n[0]),l||c.push(s[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=On("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=a?e[0]:e[g],v=l?r[0]:r[g],b=u?o[0]:o[g];if(0===b)throw new Error("Requires delta != 0");let w;if(b>0&&v<y||b<0&&v>y)w=0;else if(w=Math.ceil(Math.abs((v-y)/b)),w>$5)throw new Error(`Requires ((limit - start) / delta) <= ${$5}`);h[g+1]=h[g]+w}const p=On(t,h[d]);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let v=a?e[0]:e[g];const b=u?o[0]:o[g];for(let w=0;w<y;++w)p[m++]=v,v+=b}return[h,p]}const Kke={kernelName:X0,backendName:"cpu",kernelFunc:function qke(e){const{inputs:n,backend:t}=e,{starts:r,limits:s,deltas:o}=n,i=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values,[u,c]=P5(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[t.makeTensorInfo([u.length],"int32",u),t.makeTensorInfo([c.length],r.dtype,c)]}};var Xo=na;class nS{constructor(n,t,r,s,o,i,a,l,u,c){this.shape=n,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=lG(c),this.raggedRank=uG(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===Xo.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===Xo.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){const t=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case Xo.VALUE_ROWIDS:return nS.getMaxWidthValueRowID(t);case Xo.ROW_SPLITS:return nS.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Xo[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){const t=n.length;if(0===t||1===t)return 0;let r=0;for(let s=0;s<t-1;++s){const o=n[s+1]-n[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(n){const t=n.length;if(0===t)return 0;let r=0,s=n[0],o=0;for(let i=1;i<t;++i){const a=n[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(t-r,o)}tensorShapeFromTensor(n,t,r=!0){if(0===t.length){if(-1===n[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return V5(n,r)}calculateOutputSize(n){const t=this.valuesShape;cG(this.defaultValueShape,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=aG(this.raggedRank,s,t);i[0]<0&&(i[0]=n);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(n,t,r){const s=Math.min(n,r),o=[];let i=0;for(let a=0;a<s;++a,i+=t)o.push(i);for(let a=s;a<n;++a)o.push(-1);return S(o.length===n,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(n,t,r,s){const o=n.length,i=[];for(let a=0;a<o-1;++a){const l=n[a+1]-n[a];let u=Math.min(s,l),c=t[a];-1===c&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(o>0&&i.length!==n[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(n,t,r,s){const o=n.length,i=[];if(0===o)return[];let a=0,l=n[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];i.push(u);for(let c=1;c<o;++c){const d=n[c];if(d===l)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,l=d,d>=t.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${t.length}`);u=t[d]}i.push(u)}if(i.length!==n.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(n,t,r,s){const o=this.getRowPartitionTensor(n),i=this.getRowPartitionTypeByDimension(n);switch(i){case Xo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,r,s);case Xo.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,r,s);default:throw new Error(`Unsupported partition type: ${Xo[i]}`)}}getFirstDimensionSize(){const n=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Xo.FIRST_DIM_SIZE:return n[0];case Xo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Xo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Xo[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const o=V5(r,!1),i=On(this.valuesDType,j(o));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(n,t,r,s){if(0===r.length)return;const o=this.values,i=r;let a=s.slice();a=a.slice(n+1);const l=j(a),u=t.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const p=this.defaultValueShape;L(()=>{const m=O(c,p);c=$c(m,a).dataSync()})}let d=0,h=0,f=0;for(let p=0;p<=u;++p){let m=p<u?t[p]:-1;if(m!==f){if(h<f){const g=o.subarray(d*l);L5(i.subarray(h*l),g,(f-h)*l)}if(p>=u&&(m=Math.floor(r.length/l)),m>f)if(1===this.defaultValue.length)i.subarray(f*l,m*l).fill(this.defaultValue[0]),f=m;else for(;m>f;)L5(i.slice(f*l),c,l),++f;m<0?(d=p+1,h=f):(d=p,h=f,f=h+1)}else++f}}}function L5(e,n,t){for(let r=0;r<t;r++)e[r]=n[r]}function V5(e,n){const t=[];for(let r of e){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function B5(e,n,t,r,s,o,i,a,l,u){return new nS(e,n,t,r,s,o,i,a,l,u).compute()}const Yke={kernelName:Y0,backendName:"cpu",kernelFunc:function Xke(e){const{inputs:n,backend:t,attrs:r}=e,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=t.data.get(s.dataId).values,c=t.data.get(o.dataId).values,d=t.data.get(i.dataId).values,h=a.map(g=>t.data.get(g.dataId).values),f=a.map(g=>g.shape),[p,m]=B5(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,f,l);return t.makeTensorInfo(p,o.dtype,m)}};function z5(e,n,t,r){if(e===n||e<n&&t<0||n<e&&t>1)return Lr(0,r);const l=Lr(Math.abs(Math.ceil((n-e)/t)),r);n<e&&1===t&&(t=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}const Qke={kernelName:Z0,backendName:"cpu",kernelFunc:function Zke(e){const{backend:n,attrs:t}=e,{start:r,stop:s,dtype:o,step:i}=t,a=z5(r,s,i,o);return n.makeTensorInfo([a.length],o,a)}},Jke=Wt(mf,e=>1/e),eAe={kernelName:mf,backendName:"cpu",kernelFunc:Jke},nAe={kernelName:Iy,backendName:"cpu",kernelFunc:function tAe(e){const{inputs:n,backend:t,attrs:r}=e,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Te(s,"resizeBilinear");const l=Oe(s.shape),[u,c]=a,[d,h,f,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(j([d,u,c,p])),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],v=[o&&u>1?u-1:u,o&&c>1?c-1:c];let b=0;const w=y[0]/v[0],x=y[1]/v[1];for(let I=0;I<d;I++)for(let _=0;_<u;_++){let D;D=i?w*(_+.5)-.5:w*_;const N=Math.max(0,Math.floor(D)),T=D-N,P=Math.min(h-1,Math.ceil(D)),B=I*l[0]+N*l[1],W=I*l[0]+P*l[1];for(let H=0;H<c;H++){let G;G=i?x*(H+.5)-.5:x*H;const Y=Math.max(0,Math.floor(G)),Q=G-Y,q=Math.min(f-1,Math.ceil(G)),J=B+Y*l[2],ie=W+Y*l[2],ue=B+q*l[2],me=W+q*l[2];for(let de=0;de<p;de++){const xe=m[J+de],ge=m[ie+de],Ue=xe+(m[ue+de]-xe)*Q;g[b++]=Ue+(ge+(m[me+de]-ge)*Q-Ue)*T}}}return t.makeTensorInfo([d,u,c,p],"float32",g)}},sAe={kernelName:eC,backendName:"cpu",kernelFunc:function rAe(e){const{inputs:n,backend:t,attrs:r}=e,{images:s,dy:o}=n,{alignCorners:i}=r;Te([o,s],"resizeBilinearGrad");const a=Oe(s.shape),[l,u,c,d]=s.shape,[,h,f]=o.shape,p=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&f>1?c-1:c],g=[i&&h>1?h-1:h,i&&f>1?f-1:f],y=m[0]/g[0],v=m[1]/g[1],b=t.data.get(o.dataId).values;let w=0;for(let x=0;x<l;x++){const I=x*a[0];for(let _=0;_<h;_++){const D=_*y,N=Math.floor(D),T=Math.min(Math.ceil(D),u-1),P=I+N*a[1],B=I+T*a[1],W=D-N,H=1-W;for(let G=0;G<f;G++){const Y=G*v,Q=Math.floor(Y),q=Math.min(Math.ceil(Y),c-1),J=Y-Q,ie=1-J,ue=P+Q*a[2],me=P+q*a[2],de=B+Q*a[2],xe=B+q*a[2],ge=H*ie,Ie=H*J,Fe=W*ie,Ue=W*J;for(let Be=0;Be<d;Be++){const ut=b[w++];p[ue+Be]+=ut*ge,p[me+Be]+=ut*Ie,p[de+Be]+=ut*Fe,p[xe+Be]+=ut*Ue}}}}return t.makeTensorInfo([l,c,u,d],"float32",p)}},iAe={kernelName:Cy,backendName:"cpu",kernelFunc:function oAe(e){const{inputs:n,backend:t,attrs:r}=e,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r;Te(s,"resizeNearestNeighbor");const l=Oe(s.shape),[u,c]=a,[d,h,f,p]=s.shape,m=t.data.get(s.dataId).values,g=new Float32Array(d*u*c*p),y=[o&&u>1?h-1:h,o&&c>1?f-1:f],v=[o&&u>1?u-1:u,o&&c>1?c-1:c],b=y[0]/v[0],w=y[1]/v[1];let x=0;for(let I=0;I<d;I++){const _=I*l[0];for(let D=0;D<u;D++){const N=i?b*(D+.5):b*D;let T=Math.min(h-1,o?Math.round(N):Math.floor(N));i&&(T=Math.max(0,T));const P=_+T*l[1];for(let B=0;B<c;B++){const W=i?w*(B+.5):w*B;let H=Math.min(f-1,o?Math.round(W):Math.floor(W));i&&(H=Math.max(0,H));const G=P+H*l[2];for(let Y=0;Y<p;Y++)g[x++]=m[G+Y]}}}return t.makeTensorInfo([d,u,c,p],s.dtype,g)}},lAe={kernelName:J0,backendName:"cpu",kernelFunc:function aAe(e){const{inputs:n,backend:t,attrs:r}=e,{images:s,dy:o}=n,{alignCorners:i}=r;Te([o,s],"resizeNearestNeighborGrad");const a=Oe(s.shape),l=Oe(o.shape),[u,c,d,h]=s.shape,[,f,p]=o.shape,m=new Float32Array(u*c*d*h),g=t.data.get(o.dataId).values,y=[i&&f>1?c-1:c,i&&p>1?d-1:d],v=[i&&f>1?f-1:f,i&&p>1?p-1:p],b=y[0]/v[0],w=y[1]/v[1],x=1/b,I=1/w,_=2*Math.ceil(x)+2,D=2*Math.ceil(I)+2;for(let N=0;N<u;N++){const T=N*a[0];for(let P=0;P<c;P++){const B=T+P*a[1],W=Math.floor(P*x),H=Math.floor(W-_/2);for(let G=0;G<d;G++){const Y=B+G*a[2],Q=Math.floor(G*I),q=Math.floor(Q-D/2);for(let J=0;J<h;J++){let ie=0;for(let ue=0;ue<_;ue++){const me=ue+H;if(me<0||me>=f)continue;const de=T+me*l[1],xe=me*b;if(P===Math.min(c-1,i?Math.round(xe):Math.floor(xe)))for(let Ie=0;Ie<D;Ie++){const Fe=Ie+q;if(Fe<0||Fe>=p)continue;const Ue=de+Fe*l[2],Be=Fe*w;G===Math.min(d-1,i?Math.round(Be):Math.floor(Be))&&(ie+=g[Ue+J])}}m[Y+J]=ie}}}}return t.makeTensorInfo(s.shape,s.dtype,m)}},cAe={kernelName:Sy,backendName:"cpu",kernelFunc:function uAe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{dims:o}=r;Te(s,"reverse");const i=s.shape.length,a=pt(o,s.shape);if(0===i)return ca({inputs:{x:s},backend:t});const l=new Qn(s.shape,s.dtype),u=t.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(u.get(...h),...d)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}},dAe={kernelName:vC,backendName:"cpu",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{image:r}=e,{radians:s,fillValue:o,center:i}=n,a=t,l=Er(r.dtype,j(r.shape)),[u,c,d,h]=r.shape,[f,p]=tR(i,c,d),g=Math.sin(s),y=Math.cos(s),v=a.data.get(r.dataId).values;for(let w=0;w<u;w++){const x=w*d*c*h;for(let I=0;I<c;I++){const _=I*(d*h);for(let D=0;D<d;D++){const N=D*h;for(let T=0;T<h;T++){const P=[u,I,D,T],B=P[2],W=P[1];let H=(B-f)*y-(W-p)*g,G=(B-f)*g+(W-p)*y;H=Math.round(H+f),G=Math.round(G+p);let Y=o;"number"!=typeof o&&(Y=3===T?255:o[T]),H>=0&&H<d&&G>=0&&G<c&&(Y=v[x+G*(d*h)+H*h+T]),l[x+_+N+T]=Y}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},hAe=Wt(vf,e=>{const n=Math.floor(e);return e-n<.5?Math.floor(e):e-n>.5?Math.ceil(e):n%2==0?n:n+1}),fAe={kernelName:vf,backendName:"cpu",kernelFunc:hAe},U5=ua(e=>1/Math.sqrt(e)),pAe=du(bf,U5),mAe={kernelName:bf,backendName:"cpu",kernelFunc:pAe};function Qc(e,n,t,r,s,o,i,a,l,u){const c=[r/s,s],d=e.values,h=n.values;if(0===r)return it(t,n.dtype);const f=l instanceof Qn?l:it(c,n.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let p=0;p<o;p++){const m=[];let g=0;for(let y=0;y<i;y++){const v=d[p*i+y];m.push(v),g+=v*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<s;y++)u?f.values[g*s+y]+=h[p*s+y]:f.values[g*s+y]=0===n.rank?h[0]:h[p*s+y]}return f}const yAe={kernelName:tC,backendName:"cpu",kernelFunc:function gAe(e){const{inputs:n,backend:t,attrs:r}=e,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ql(0,s,i),m=Qc(t.bufferSync(s),t.bufferSync(o),i,d,u,l,a,c,0,!0);return t.makeTensorInfo(i,m.dtype,m.values)}};function vAe(e,n){let t=0,r=e.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),e[s]<n?t=s+1:r=s;return r}function bAe(e,n){let t=0,r=e.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),e[s]<=n?t=s+1:r=s;return r}const CAe={kernelName:rC,backendName:"cpu",kernelFunc:function xAe(e){const{inputs:n,backend:t,attrs:r}=e,{sortedSequence:s,values:o}=n,{side:i}=r,u=function wAe(e,n,t,r,s,o){const i=On("int32",t*s);for(let a=0;a<t;++a){const l=e.slice(a*r,(a+1)*r),u=a*s;for(let c=0;c<s;++c)i[u+c]="left"===o?vAe(l,n[c+u]):bAe(l,n[c+u])}return i}(t.data.get(s.dataId).values,t.data.get(o.dataId).values,s.shape[0],s.shape[1],o.shape[1],i);return t.makeTensorInfo(o.shape,"int32",u)}},SAe={kernelName:_y,backendName:"cpu",kernelFunc:function IAe(e){const{inputs:n,backend:t}=e,{condition:r,t:s,e:o}=n;Te([r,s,o],"select");const i=r.shape.length,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,u=t.data.get(o.dataId).values,c=Ts(s.dtype,o.dtype),d=Lr(j(s.shape),c);let h=0;const f=0===i||i>1||1===s.shape.length?1:j(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<f;m++)d[h++]=1===a[p]?l[p]:u[p];return t.makeTensorInfo(s.shape,c,d)}},_Ae=gI,EAe=yI,DAe=Wt(wf,e=>e>=0?EAe*e:_Ae*(Math.exp(e)-1)),NAe={kernelName:wf,backendName:"cpu",kernelFunc:DAe},TAe=Wt(If,e=>e<0?-1:e>0?1:0),kAe={kernelName:If,backendName:"cpu",kernelFunc:TAe},AAe=Wt(xf,e=>Math.sin(e)),RAe={kernelName:xf,backendName:"cpu",kernelFunc:AAe},MAe=Wt(Cf,e=>Math.sinh(e)),OAe={kernelName:Cf,backendName:"cpu",kernelFunc:MAe},W5=Math.log(1.1920928955078125e-7)+2,FAe=Wt(_f,e=>{const n=e>-W5,t=e<W5,r=Math.exp(e);let s;return s=t?r:n?e:Math.log(1+r),s}),$Ae={kernelName:_f,backendName:"cpu",kernelFunc:FAe},LAe={kernelName:Ny,backendName:"cpu",kernelFunc:function PAe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{blockShape:o,paddings:i}=r;Te([s],"spaceToBatchND");const a=j(o),l=[[0,0]];l.push(...i);for(let I=1+o.length;I<s.shape.length;++I)l.push([0,0]);const u=R5.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),c=gv(u.shape,o,a,!1),d=yv(c.length,o.length,!1),h=vv(u.shape,o,a,!1),m=an({inputs:{x:u},backend:t,attrs:{shape:c}}),v=Ps({inputs:{x:m},backend:t,attrs:{perm:d}}),x=an({inputs:{x:v},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(v),x}};function H5(e,n,t,r,s,o,i){const a=n[0],l=o[0],u=new Array(l),c=new Array(a),d=n[1];if(0===l){if(0!==a)throw new Error(bG(a));return[On(t,0),[0,d],On(s,0),u,c]}let h=!0,f=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=e[g*d];if(y<0)throw new Error(wG(g,y));if(y>=l)throw new Error(xG(g,y,l));++p[y],h=h&&y>=f,f=y}let m=!0;for(let g=0;g<l;++g){const y=0===p[g];u[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&h){const g=e,y=r;for(let v=0;v<a;++v)c[v]=v;return[g,[a,d],y,u,c]}{const g=p[l-1],y=On(t,g*d),v=On(s,g),b=new Array(l).fill(0);for(let w=0;w<a;++w){const x=e[w*d],_=(0===x?0:p[x-1])+b[x];b[x]++;for(let D=0;D<d;++D)y[_*d+D]=e[w*d+D];v[_]=r[w],c[w]=_}for(let w=0;w<l;++w)if(0===b[w]){const I=0===w?0:p[w-1];y[I*d+0]=w;for(let _=1;_<d;++_)y[I*d+_]=0;v[I]=i}return[y,[g,d],v,u,c]}}const BAe={kernelName:sC,backendName:"cpu",kernelFunc:function VAe(e){const{inputs:n,backend:t}=e,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,u=t.data.get(o.dataId).values,c=t.data.get(i.dataId).values[0],[d,h,f,p,m]=H5(a,r.shape,r.dtype,l,s.dtype,u,c);return[t.makeTensorInfo(h,r.dtype,d),t.makeTensorInfo([h[0]],s.dtype,f),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function j5(e,n,t,r,s){const o=j(r),i=n[0],a=s.length,l=[];let u=1,c=-1;for(let g=0;g<a;++g){const y=s[g];if(-1===y){if(-1!==c)throw new Error(CG(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(IG(g,y));u*=y,l.push(y)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(o/u);if(u*g!==o)throw new Error(_G(r,l));l[c]=g}if(j(l)!==o)throw new Error(EG(r,l));const h=r.length,f=[];if(h>0){f[h-1]=1;for(let g=h-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=On(t,i*a);for(let g=0;g<i;++g){let y=0;for(let v=0;v<h;++v)y+=e[g*h+v]*f[v];for(let v=0;v<a;++v)m[g*a+v]=Math.trunc(y/p[v]),y%=p[v]}return[m,[i,a],l]}const UAe={kernelName:oC,backendName:"cpu",kernelFunc:function zAe(e){const{inputs:n,backend:t}=e,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.data.get(s.dataId).values),a=t.data.get(r.dataId).values,l=Array.from(t.data.get(o.dataId).values),[u,c,d]=j5(a,r.shape,r.dtype,i,l);return[t.makeTensorInfo(c,r.dtype,u),t.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function BM(e,n,t,r,s,o=!1,i=0){const a=r.length,l=[n[0],e.length/n[0]],u=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=n.slice();h[0]=d;const p=On(t,h.reduce((b,w)=>b*w,1));if(0===a)return d>0&&p.fill(i),[p,h];if(d<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,y=0,v=s[m];for(;;){let b=0;if(g<a){if(b=s[g],v===b){++g;continue}if(v>=b)throw new Error("segment ids are not increasing")}if(v<0||v>=d)throw new Error(NG(v,d));v>y&&p.fill(i,y*u,v*u);for(let w=m;w<g;++w){const x=r[w];if(x<0||x>=l[0])throw new Error(TG(w,r[w],l[0]));for(let I=0;I<u;I++)p[v*u+I]+=e[x*u+I]}if(o)for(let w=0;w<u;w++)p[v*u+w]/=g-m;if(m=g,++g,y=v+1,v=b,g>a)break}return y<d&&p.fill(i,y*u,d*u),[p,h]}const HAe={kernelName:iC,backendName:"cpu",kernelFunc:function WAe(e){const{inputs:n,backend:t}=e,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values,[u,c]=BM(i,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(c,r.dtype,u)}},GAe={kernelName:aC,backendName:"cpu",kernelFunc:function jAe(e){const{inputs:n,backend:t}=e,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values,[u,c]=BM(i,r.shape,r.dtype,a,l);return t.makeTensorInfo(c,r.dtype,u)}},KAe={kernelName:lC,backendName:"cpu",kernelFunc:function qAe(e){const{inputs:n,backend:t,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ql(0,s,a),f=!1,p=t.bufferSync(s);let m;switch(o.dtype){case"bool":m=Qc(p,t.bufferSync(o),a,h,c,u,l,d,!!t.data.get(i.dataId).values[0],f);break;case"float32":case"int32":m=Qc(p,t.bufferSync(o),a,h,c,u,l,d,t.data.get(i.dataId).values[0],f);break;case"string":m=Qc(p,t.bufferSync(o),a,h,c,u,l,d,Pa(t.data.get(i.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${o.dtype}`)}return t.makeTensorInfo(a,m.dtype,m.values)}},YAe={kernelName:Ty,backendName:"cpu",kernelFunc:function XAe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=pt(i,s.shape)[0],l=yR(s,o,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[a]=d;const f=Zc({inputs:{x:s},backend:t,attrs:{begin:u,size:h}});return u[a]+=d,f})}},ZAe=ua(e=>Math.sqrt(e)),QAe=Wt(Ef,e=>Math.sqrt(e)),JAe={kernelName:Ef,backendName:"cpu",kernelFunc:QAe},eRe={kernelName:uC,backendName:"cpu",kernelFunc:({inputs:e,backend:n})=>{const{x:t}=e,r=n;Te(t,"square");const s=r.data.get(t.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];o[a]=l*l}return{dataId:r.write(o,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}},tRe=qn((e,n)=>{const t=e-n;return t*t}),nRe=pr(Df,tRe),rRe={kernelName:Df,backendName:"cpu",kernelFunc:nRe},G5=ua((e,n)=>{const{pattern:t,replaceGlobal:r,rewrite:s}=n;return e.replace(new RegExp(t,r?"g":""),s)}),sRe=du(Ay,G5),oRe={kernelName:Ay,backendName:"cpu",kernelFunc:sRe},iRe=Wt(Rf,(e,n)=>{const t=n;return isNaN(e)?NaN:e>0?1:t.alpha}),aRe={kernelName:Rf,backendName:"cpu",kernelFunc:iRe};function q5(e,n,t,r){const s=it(e,n.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*t[l]+r[l];s.set(n.get(...a),...i)}return s}const uRe={kernelName:cC,backendName:"cpu",kernelFunc:function lRe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;Te(s,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:b,strides:w}=$k(s.shape,o,i,a,l,u,c,d,h);let x;if(m)x=an({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=Mk(v,b,w),_=Zc({inputs:{x:s},backend:t,attrs:{begin:v,size:I}});x=an({inputs:{x:_},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(_)}else{const _=q5(f,t.bufferSync(s),w,v);x=t.makeTensorInfo(p,_.dtype,_.values)}return x}};class cRe{constructor(n,t,r,s,o,i){this.separator=qi(n),this.nGramWidths=t,this.leftPad=qi(r),this.rightPad=qi(s),this.padWidth=o,this.preserveShort=i}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,t){const r=this.getPadWidth(t);return Math.max(0,n+2*r-t+1)}createNGrams(n,t,r,s,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i),u=Math.max(0,l-a),c=Math.max(0,l-(o-(a+1))),d=i-(u+c),h=t+(u>0?0:a-l);let f=0;f+=u*this.leftPad.length;for(let v=0;v<d;++v)f+=n[h+v].length;f+=c*this.rightPad.length,f+=(u+c+d-1)*this.separator.length,r[s+a]=new Uint8Array(f);const m=r[s+a];let g=0;const y=v=>v.forEach(b=>m[g++]=b);for(let v=0;v<u;++v)y(this.leftPad),y(this.separator);for(let v=0;v<d-1;++v)y(n[h+v]),y(this.separator);if(d>0){y(n[h+d-1]);for(let v=0;v<c;++v)y(this.separator),y(this.rightPad)}else{for(let v=0;v<c-1;++v)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(n,t){const r=n.length,s=t.length;if(s>0){let l=t[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=t[u]>=l;if(c=c&&t[u]<=r,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${r}]`);l=t[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const o=s-1,i=On("int32",s);if(0===r||0===s){const l=new Array(r);for(let u=0;u<=o;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&0===c&&(c=1),i[l]=i[l-1]+c}const a=new Array(i[o]);for(let l=0;l<o;++l){const u=t[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const f=this.getNumNGrams(t[l+1]-t[l],d);this.createNGrams(n,u,a,c,f,d),c+=f}),this.preserveShort&&c===i[l]){const d=t[l+1]-t[l];if(0===d)continue;this.createNGrams(n,u,a,c,1,d+2*this.padWidth)}}return[a,i]}}function K5(e,n,t,r,s,o,i,a){return new cRe(t,r,s,o,i,a).compute(e,n)}const hRe={kernelName:dC,backendName:"cpu",kernelFunc:function dRe(e){const{inputs:n,backend:t,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=n,h=t.data.get(c.dataId).values,f=t.data.get(d.dataId).values,[p,m]=K5(h,f,s,o,i,a,l,u);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(d.shape,"int32",m)]}};function fRe(e,n,t,r){if(!e.length)return;if(0===n.length){for(let o=0;o<e.length;++o)r.push(e.subarray(o,o+1));return}if(1===n.length){const o=n[0];let i=e.indexOf(o);for(;-1!==i;){const a=e.subarray(0,i);(!t||0!==a.length)&&r.push(a),i=(e=e.subarray(i+1)).indexOf(o)}return void((!t||0!==e.length)&&r.push(e))}let s=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==n.indexOf(e[o])){const i=e.subarray(s,o);(!t||0!==i.length)&&r.push(i),s=o+1}}function X5(e,n,t){const r=e.length,s=[];let o=0,i=0;const a=new Array(r);for(let h=0;h<r;++h){const f=s.length;fRe(e[h],n,t,s);const p=s.length-f;a[h]=p,o+=p,i=Math.max(i,p)}const l=On("int32",2*o),u=new Array(o),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let f=0;f<a[h];++f)l[2*d]=h,l[2*d+1]=f,u[d]=s[d],++d;return[l,u,c]}const mRe={kernelName:hC,backendName:"cpu",kernelFunc:function pRe(e){const{inputs:n,backend:t,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.data.get(o.dataId).values,l=t.data.get(i.dataId).values[0],[u,c,d]=X5(a,l,s),h=c.length;return[t.makeTensorInfo([h,2],"int32",u),t.makeTensorInfo([h],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(d))]}};function Y5(e,n){const t=On("int32",e.length);for(let r=0;r<e.length;++r)t[r]=Z4(e[r]).modulo(n).getLowBitsUnsigned();return t}const yRe={kernelName:fC,backendName:"cpu",kernelFunc:function gRe(e){const{inputs:n,backend:t,attrs:r}=e,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=Y5(t.data.get(o.dataId).values,s);return t.makeTensorInfo(o.shape,"int32",a)}},vRe=Wt(Tf,e=>Math.tan(e)),bRe={kernelName:Tf,backendName:"cpu",kernelFunc:vRe},wRe=Wt(kf,e=>Math.tanh(e));function Z5(e,n){const t=new Array(e.rank);for(let s=0;s<t.length;s++)t[s]=e.shape[s]*n[s];const r=it(t,e.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=o[l]%e.shape[l];const a=e.locToIndex(i);r.values[s]=e.values[a]}return r}const Ov=(e,n)=>{const t=n.value-e.value;return 0===t?e.index-n.index:t};function Q5(e,n,t=0,r=e.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,l=n-t+1,u=Math.log(a),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2);Q5(e,n,Math.max(t,Math.floor(n-l*c/a+d)),Math.min(r,Math.floor(n+(a-l)*c/a+d)))}const s=e[n];let o=t,i=r;for(Ma(e,t,n),Ov(e[r],s)>0&&Ma(e,t,r);o<i;){for(Ma(e,o,i),o++,i--;Ov(e[o],s)<0;)o+=1;for(;Ov(e[i],s)>0;)i-=1}0===Ov(e[t],s)?Ma(e,t,i):(i+=1,Ma(e,i,r)),i<=n&&(t=i+1),n<=i&&(r=i-1)}}function J5(e,n,t,r,s){const o=n[n.length-1],[i,a]=[e.length/o,o],l=Er(t,i*r),u=Er("int32",i*r);for(let d=0;d<i;d++){const h=d*a,f=e.subarray(h,h+a);let p=new Array(f.length);f.forEach((v,b)=>p[b]={value:v,index:b}),r<p.length&&(Q5(p,r),p=p.slice(0,r)),s&&p.sort(Ov);const m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let v=0;v<r;v++)g[v]=p[v].value,y[v]=p[v].index}const c=n.slice();return c[c.length-1]=r,[it(c,t,l),it(c,"int32",u)]}function e8(e,n,t){switch(t){case"reflect":return function kRe(e,n){let t=e;if(t<0)if(n<=1)t=0;else{const r=2*n;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-n?t+r:-t-1}else if(t>n-1)if(n<=1)t=0;else{const r=2*n;t-=r*Math.trunc(t/r),t>=n&&(t=r-t-1)}return Bl(0,t,n-1)}(e,n);case"wrap":return function ARe(e,n){let t=e;return t<0?n<=1?t=0:t+=n*(Math.trunc(-t/(n-1))+1):t>n-1&&(n<=1?t=0:t-=n*Math.trunc(t/(n-1))),Bl(0,t,n-1)}(e,n);case"nearest":return function MRe(e,n){return Bl(0,e,n-1)}(e,n);default:return function RRe(e){return e}(e)}}function Fv(e,n,t,r,s,o,i,a,l,u,c){return 0<=a&&a<n&&0<=l&&l<t?e[i*r+a*s+l*o+u]:c}function ORe(e,n,t,r,s,o,i,a,l,u,c){return Fv(e,n,t,r,s,o,i,Math.round(a),Math.round(l),u,c)}function FRe(e,n,t,r,s,o,i,a,l,u,c){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*Fv(e,n,t,r,s,o,i,d,h,u,c)+(l-h)*Fv(e,n,t,r,s,o,i,d,p,u,c))+(a-d)*((p-l)*Fv(e,n,t,r,s,o,i,f,h,u,c)+(l-h)*Fv(e,n,t,r,s,o,i,f,p,u,c))}function t8(e,n,t,r){const s=pt(n,t)[0],o=[1,t[0],1];for(let p=0;p<s;p++)o[0]*=t[p];o[1]=t[s];for(let p=s+1;p<t.length;p++)o[2]*=t[p];const i=new Map,a=new Int32Array(t[s]),l=new Qn(o,r,e),u=[],c=1===o[0]&&1===o[2];for(let p=0;p<t[s];p++){let m;if(c)m=e[p].toString();else{const y=[];for(let v=0;v<o[0];v++)for(let b=0;b<o[2];b++)y.push(l.get(v,p,b));m=y.join(",")}const g=i.get(m);if(null!=g)a[p]=g;else{const y=i.size;i.set(m,y),a[p]=y,u.push(p)}}const d=o.slice();d[1]=i.size;const h=new Qn(d,r);u.forEach((p,m)=>{for(let g=0;g<o[0];g++)for(let y=0;y<o[2];y++)h.set(l.get(g,p,y),g,m,y)});const f=t.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const URe=[ODe,FDe,PDe,VDe,kDe,zDe,HDe,GDe,KDe,YDe,QDe,eNe,nNe,oNe,aNe,cNe,hNe,pNe,gNe,RDe,vNe,xNe,INe,_Ne,DNe,NDe,TNe,ANe,EDe,RNe,ONe,FNe,PNe,VNe,zNe,WNe,jNe,qNe,XNe,ZNe,JNe,tTe,rTe,oTe,iTe,lTe,cTe,hTe,fTe,pTe,mTe,yTe,CTe,yDe,STe,_Te,MTe,OTe,FTe,PTe,jTe,GTe,KTe,YTe,JTe,t1e,r1e,o1e,a1e,u1e,d1e,vDe,f1e,MNe,m1e,y1e,b1e,bDe,x1e,I1e,_1e,D1e,T1e,R1e,O1e,P1e,V1e,z1e,U1e,H1e,G1e,K1e,Y1e,Q1e,eke,nke,ske,ike,lke,dke,pke,bTe,gke,bke,Cke,_ke,Dke,Tke,Ake,Rke,R5,$ke,xDe,Lke,Gke,Kke,Yke,Qke,DDe,$M,eAe,CDe,IDe,ADe,nAe,sAe,iAe,lAe,cAe,dAe,fAe,mAe,yAe,CAe,SAe,NAe,_De,kAe,RAe,OAe,bNe,hke,$Ae,LAe,BAe,UAe,HAe,GAe,KAe,YAe,JAe,eRe,rRe,oRe,aRe,uRe,hRe,mRe,yRe,BTe,wTe,bRe,{kernelName:kf,backendName:"cpu",kernelFunc:wRe},{kernelName:nC,backendName:"cpu",kernelFunc:function CRe(e){const{inputs:n,backend:t}=e,{tensor:r,indices:s,updates:o}=n,{sliceRank:i,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=ql(0,s,r.shape),h=t.bufferSync(s),f=t.bufferSync(o),p=t.bufferSync(r),m=Qc(h,f,r.shape,c,l,a,i,u,p,!1);return t.makeTensorInfo(r.shape,m.dtype,m.values)}},{kernelName:Af,backendName:"cpu",kernelFunc:function SRe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{reps:o}=r;Te(s,"tile");const i=Z5(t.bufferSync(s),o);return t.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:pC,backendName:"cpu",kernelFunc:function ERe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{k:o,sorted:i}=r;Te(s,"topk");const a=t.data.get(s.dataId).values,[l,u]=J5(a,s.shape,s.dtype,o,i);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:mC,backendName:"cpu",kernelFunc:function NRe(e){const{inputs:n,attrs:t,backend:r}=e,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=t,[c,d,h,f]=s.shape,[p,m]=u??[d,h],g=[c,p,m,f],y=Oe(s.shape),v=y[0],b=y[1],w=y[2],x=Oe(g),I=x[0],_=x[1],D=x[2],N=Er(s.dtype,j(g));N.fill(l);const T=r.data.get(s.dataId).values,P=r.data.get(o.dataId).values;for(let W=0;W<c;++W){const H=1===o.shape[0]?P:P.subarray(8*W,8*W+8);for(let G=0;G<p;++G)for(let Y=0;Y<m;++Y)for(let Q=0;Q<f;++Q){let q;const J=H[6]*Y+H[7]*G+1;if(0===J)continue;const ue=(H[3]*Y+H[4]*G+H[5])/J,me=e8((H[0]*Y+H[1]*G+H[2])/J,h,a),de=e8(ue,d,a);switch(i){case"nearest":q=ORe(T,d,h,v,b,w,W,de,me,Q,l);break;case"bilinear":q=FRe(T,d,h,v,b,w,W,de,me,Q,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}N[W*I+G*_+Y*D+Q]=q}return r.makeTensorInfo(g,s.dtype,N)}return{dataId:r.write(N,g,s.dtype),shape:s.shape,dtype:s.dtype}}},UDe,{kernelName:gC,backendName:"cpu",kernelFunc:function $Re(e){const{inputs:n,attrs:t,backend:r}=e,{axis:s}=t,{x:o}=n;Te(o,"unique");const i=r.data.get(o.dataId).values,{outputValues:a,outputShape:l,indices:u}=t8(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},{kernelName:Ry,backendName:"cpu",kernelFunc:function LRe(e){const{inputs:n,backend:t,attrs:r}=e,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s.shape.length,a=s.shape[o],l=new Array(i-1);let u=0;for(let f=0;f<i;f++)f!==o&&(l[u++]=s.shape[f]);const c=new Array(i).fill(0),d=s.shape.slice();d[o]=1;const h=new Array(a);for(let f=0;f<h.length;f++){c[o]=f;const p=Zc({inputs:{x:s},backend:t,attrs:{begin:c,size:d}});h[f]=an({inputs:{x:p},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(p)}return h}},{kernelName:My,backendName:"cpu",kernelFunc:function BRe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,segmentIds:o}=n,{numSegments:i}=r;Te(s,"unsortedSegmentSum");const u=[],c=[],d=s.shape.length-o.shape.length;let h=o;for(let p=0;p<d;++p){const m=eS({inputs:{input:h},backend:t,attrs:{dim:p+1}});h=m,c.push(m)}for(let p=0;p<i;++p){const m=$a(p,"int32"),g=t.makeTensorInfo([],"int32",m),y=l5({inputs:{a:g,b:h},backend:t}),v=hu({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),b=JI({inputs:{a:v,b:s},backend:t}),w=Mv({inputs:{x:b},backend:t,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(g),c.push(y),c.push(v),c.push(b),c.push(w)}const f=A5({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(p=>t.disposeIntermediateTensorInfo(p)),f}},kke];for(const e of URe)wC(e);const fu={},rS={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ii(e,n){if(!(e in fu)||null!=n){const r=function jRe(e,n){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=n??function HRe(e){if(!V().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===e)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete fu[e]},!1),V().getBool("SOFTWARE_WEBGL_ENABLED")&&(rS.failIfMajorPerformanceCaveat=!1),1===e?t.getContext("webgl",rS)||t.getContext("experimental-webgl",rS):t.getContext("webgl2",rS)}(e,n);if(null===r)return console.log("Could not get context for WebGL version",e),null;fu[e]=r}const t=fu[e];return null==t||t.isContextLost()?(delete fu[e],Ii(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),fu[e])}var sS=function(e){return e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH",e}(sS||{}),Yo=function(e){return e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD",e}(Yo||{}),es=function(e){return e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",e}(es||{});function $v(e,n){return[n,e]}function oS(e){const n=j(e);return a0(Math.ceil(n/4))}function up(e,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(e/2))]}function zM(e,n){const t=e;let r,s,o,i,a,l,u,c,d,h;return 2===V().getNumber("WEBGL_VERSION")?(r=t.R32F,s=t.R16F,o=t.RGBA16F,i=t.RGBA32F,a=t.RED,u=4,c=1,d=t.HALF_FLOAT,h=t.FLOAT,l=t.RGBA8):(r=e.RGBA,s=e.RGBA,o=e.RGBA,i=t.RGBA,a=e.RGBA,u=4,c=4,d=null!=n?n.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function be(e,n){const t=n();return V().getBool("DEBUG")&&function KRe(e){const n=e.getError();if(n!==e.NO_ERROR)throw new Error("WebGL Error: "+function QRe(e,n){switch(n){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}(e,n))}(e),t}function ZRe(e){return!!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function iS(e,n){return el(e,()=>e.getExtension(n),'Extension "'+n+'" not supported on this browser.')}const tMe=/ERROR: [0-9]+:([0-9]+):/g;function n8(e,n){const t=tMe.exec(n);if(null==t)return console.log(`Couldn't parse line number in error: ${n}`),void console.log(e);const r=+t[1],s=e.split("\n"),o=s.length.toString().length+2,i=s.map((d,h)=>wc((h+1).toString(),o)+d);let a=0;for(let d=0;d<i.length;d++)a=Math.max(i[d].length,a);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log(`%c ${wc(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function UM(e,n){if(be(e,()=>e.validateProgram(n)),!1===e.getProgramParameter(n,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function r8(e,n,t,r,s,o,i){const a=e.getAttribLocation(n,t);return-1!==a&&(be(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),be(e,()=>e.vertexAttribPointer(a,s,e.FLOAT,!1,o,i)),be(e,()=>e.enableVertexAttribArray(a)),!0)}function hMe(e,n,t,r){be(e,()=>function uMe(e,n,t){(function o8(e,n){const t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+e.TEXTURE0;if(r<e.TEXTURE0||r>t)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${t}].`)})(e,t),be(e,()=>e.activeTexture(e.TEXTURE0+t)),be(e,()=>e.bindTexture(e.TEXTURE_2D,n))}(e,n,r)),be(e,()=>e.uniform1i(t,r))}function WM(e,n,t){be(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),be(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0))}function s8(e,n){be(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),be(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function aS(e){const n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function fMe(e,n){switch(n){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}(e,n))}function el(e,n,t){const r=be(e,()=>n());if(null==r)throw new Error(t);return r}function cp(e,n=2){return j(e.slice(0,e.length-n))}function dp(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function lS(e){let n=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(n=[cp(e),...dp(e)]),n}function uS(e){return e%2==0}function cS(e,n){if(wt(e=e.slice(-2),n=n.slice(-2))||!e.length||!n.length||0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){const t=e[e.length-1],r=n[n.length-1];if(t===r||uS(t)&&uS(r)&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&uS(e[0])&&uS(n[0])}let dS,hS;function Zo(e,n){return null!=e.getExtension(n)}function i8(e){try{if(null!=Ii(e))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function HM(e){const n=zM(e),t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(o),i}function Pv(e,n){Array.isArray(e)||(e=[e]),e.forEach(t=>{null!=t&&S("complex64"!==t.dtype,()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}const Ae=V();function gs(){let e,n,t,r,s,o,i,a,l,u;return 2===V().getNumber("WEBGL_VERSION")?(e="#version 300 es",n="in",t="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a=V().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",n="attribute",t="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:n,varyingVs:t,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}function Jc(e,n,t="index"){const r=Oe(n);return r.map((s,o)=>`int ${e[o]} = ${t} / ${s}; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * ${s}`:`index -= ${e[o]} * ${s}`};`).join("")}function fS(e,n,t="index"){const r=Oe(n);return r.map((s,o)=>`int ${e[o]} = ${t} / outShapeStrides[${o}]; ${o===r.length-1?`int ${e[o+1]} = ${t} - ${e[o]} * outShapeStrides[${o}]`:`index -= ${e[o]} * outShapeStrides[${o}]`};`).join("")}function jM(e){const n=Oe(e).map(t=>t.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}Ae.registerFlag("HAS_WEBGL",()=>Ae.getNumber("WEBGL_VERSION")>0),Ae.registerFlag("WEBGL_VERSION",()=>i8(2)?2:i8(1)?1:0),Ae.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Ae.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Ae.get("WEBGL_VERSION")),Ae.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Ae.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Ae.registerFlag("WEBGL_PACK",()=>Ae.getBool("HAS_WEBGL")),Ae.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_CLIP",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_REDUCE",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_CONV_IM2COL",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ae.getBool("WEBGL_PACK")),Ae.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function mMe(e){if(null==dS){const n=Ii(e);dS=n.getParameter(n.MAX_TEXTURE_SIZE)}return dS}(Ae.getNumber("WEBGL_VERSION"))),Ae.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function gMe(e){if(null==hS){const n=Ii(e);hS=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,hS)}(Ae.getNumber("WEBGL_VERSION"))),Ae.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=Ae.getNumber("WEBGL_VERSION");return 0===e?0:function yMe(e){if(0===e)return 0;let n;const t=Ii(e);return n=Zo(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:Zo(t,"EXT_disjoint_timer_query")?1:0,n}(e)}),Ae.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ae.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!W1()),Ae.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function vMe(e){if(0===e)return!1;const n=Ii(e);if(1===e){if(!Zo(n,"OES_texture_float"))return!1}else if(!Zo(n,"EXT_color_buffer_float"))return!1;return HM(n)}(Ae.getNumber("WEBGL_VERSION"))),Ae.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Ae.getBool("WEBGL_FORCE_F16_TEXTURES")&&Ae.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Ae.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function bMe(e){if(0===e)return!1;const n=Ii(e);if(1!==e){if(Zo(n,"EXT_color_buffer_float"))return HM(n);const r="EXT_color_buffer_half_float";if(Zo(n,r)){const s=n.getExtension(r);return function wMe(e,n){const t=zM(e,n),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),a}(n,s)}return!1}return!(!Zo(n,"OES_texture_float")||!Zo(n,"WEBGL_color_buffer_float"))&&HM(n)}(Ae.getNumber("WEBGL_VERSION"))),Ae.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function xMe(e){return 2===e&&null!=Ii(e).fenceSync}(Ae.getNumber("WEBGL_VERSION"))),Ae.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ae.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Ae.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),Ae.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>W1()?1:-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),Ae.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Ae.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Ae.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Ae.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Ae.registerFlag("WEBGL_EXP_CONV",()=>!1),Ae.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ae.getBool("IS_TEST")),Ae.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Ae.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Ae.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Ae.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const a8="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:l8}=Me;function SMe(e,n,t){const r=[];if(e.forEach(f=>{const p=j(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){const{uniformShape:m}=qM(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`)}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const s=r.join("\n"),o=e.map(f=>function _Me(e,n,t=!1,r){let s="";s+=t?u8(e,r):hp(e,r);return e.shapeInfo.logicalShape.length<=n.logicalShape.length&&(s+=t?function sOe(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=l8(e.shapeInfo.logicalShape,n.logicalShape),l=Xt(i),u=i-o;let c;const d=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(v=>`coords.${d[v+u]} = 0;`).join("\n");let h="";h=i<2&&o>0?"coords":e.shapeInfo.logicalShape.map((v,b)=>`coords.${d[b+u]}`).join(", ");let f="return outputValue;";const m=1===j(e.shapeInfo.logicalShape),y=1===j(n.logicalShape);if(1!==o||m||y){if(m&&!y)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const v=o-2,b=o-1;a.indexOf(v)>-1&&a.indexOf(b)>-1?f="return vec4(outputValue.x);":a.indexOf(v)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(b)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(e,n):function oOe(e,n){const t=e.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!e.shapeInfo.isUniform&&a===l&&null==e.shapeInfo.flatOffset&&wt(e.shapeInfo.texShape,n.texShape))return`\n      float ${s}() {\n        return sampleTexture(${t}, resultUV);\n      }\n    `;const u=Xt(l),c=l8(e.shapeInfo.logicalShape,n.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&c.length>=1?"coords = 0;":c.map(m=>`coords.${f[m+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":e.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(e,n)),s}(f,n,t.packedInputs,t.enableShapeUniforms)).join("\n"),i=n.texShape,a=gs(),l=function NMe(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let u,c,d=function AMe(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${RMe}\n    ${MMe}\n    ${OMe}\n  `}(a);return n.isPacked?(u=function EMe(e,n,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function $Me(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,t);case 2:return function HMe(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(wt(e,n))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return t?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function LMe(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(e[2]/2),o=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,n,t);default:return function BMe(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],s=Math.ceil(e[e.length-1]/2),o=s*Math.ceil(e[e.length-2]/2);let i=o,a="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],a=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+a,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,n,t)}}(n.logicalShape,i,t.enableShapeUniforms),c=function kMe(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(a)):(u=function DMe(e,n,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function PMe(e,n,t){return 1===n[0]?t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,t);case 2:return function jMe(e,n,t){return wt(e,n)?t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `:1===e[1]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:t?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function VMe(e,n,t){if(t)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${fS(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=Jc(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,n,t);case 4:return function zMe(e,n,t){if(t)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${fS(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Jc(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,n,t);case 5:return function UMe(e,n){const t=Jc(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,n);case 6:return function WMe(e,n){const t=Jc(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(n.logicalShape,i,t.enableShapeUniforms),c=function TMe(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),t.packedInputs&&(d+=FMe),[d,l,c,s,u,o,t.userCode].join("\n")}function hp(e,n=!1){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function qMe(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,o]=e.shapeInfo.texShape;if(1===s&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const i=ed(t);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[a,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 1:return function XMe(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${fp(e)}\n      }\n    `;const s=e.shapeInfo.texShape,o=s[0],i=s[1];if(1===i&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=ed(t);return 1===i?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===o?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 2:return function ZMe(e,n){const t=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape;if(null!=o&&wt(t,o))return n?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${o[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:i,keptDims:a}=Oa(t);if(i.length<t.length){const f=["row","col"];return`\n      ${hp(pp(e,i),n)}\n      float ${s}(int row, int col) {\n        return ${s}(${mp(f,a)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${fp(e)}\n      }\n    `;const u=o[0],c=o[1],d=ed(r);return 1===c?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?n?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:n?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,n);case 3:return function JMe(e,n){const t=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[1]*t[2],i=t[2],{newShape:a,keptDims:l}=Oa(t);if(a.length<t.length){const g=["row","col","depth"];return`\n        ${hp(pp(e,a),n)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${mp(g,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${o}, ${i}, 1)));\n        ${fp(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],f=e.shapeInfo.flatOffset;if(h===o&&null==f)return n?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==f)return n?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const p=ed(r);return n?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${o} + col * ${i} + depth + ${p};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,n);case 4:return function tOe(e,n){const t=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[3],i=t[2]*o,a=t[1]*i,{newShape:l,keptDims:u}=Oa(t);if(l.length<t.length){const b=["row","col","depth","depth2"];return`\n      ${hp(pp(e,l),n)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${mp(b,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${i}, ${o}, 1)));\n        ${fp(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],f=d[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&null==c)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===o&&null==c)return n?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=ed(r);return n?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} +\n          depth * ${o} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,n);case 5:return function nOe(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n[4],o=n[3]*s,i=n[2]*o,a=n[1]*i,{newShape:l,keptDims:u}=Oa(n);if(l.length<n.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${hp(pp(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${mp(g,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${fp(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(f===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${ed(t)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 6:return function rOe(e){const n=e.shapeInfo.logicalShape,t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:o}=Oa(n);if(s.length<n.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${hp(pp(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${mp(y,o)});\n      }\n    `}const i=n[5],a=n[4]*i,l=n[3]*a,u=n[2]*l,c=n[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${fp(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,f=h[0],p=h[1];if(p===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(p===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${ed(t)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function u8(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return function GMe(e){const n=e.name;return`\n    vec4 ${"get"+n.charAt(0).toUpperCase()+n.slice(1)}() {\n      return ${gs().texture2D}(${n}, halfCR);\n    }\n  `}(e);case 1:return function KMe(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e.shapeInfo.texShape,o=gs();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e,n);case 2:return function YMe(e,n){const t=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=o[0],a=o[1],l=gs();if(null!=o&&wt(t,o))return n?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(n)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,n);case 3:return function QMe(e,n){const t=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(1===t[0]){const f=[1,2],m=["b","row","col"];return`\n        ${u8(pp(e,t.slice(1)),n)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${mp(m,f)});\n        }\n      `}const a=gs();if(n)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(t[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(t[1]/2)}, ${c}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(e,n);default:return function eOe(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=gs();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${t}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);\n    }\n  `;const o=e.shapeInfo.logicalShape,i=o.length,a=e.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],d=Math.ceil(o[i-1]/2);let h=d*Math.ceil(o[i-2]/2),f="int b, int row, int col",p=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)f=`int b${m}, `+f,h*=o[i-m-1],p=`b${m} * ${h} + `+p;return`\n    vec4 ${r}(${f}) {\n      int index = ${p};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${t}, uv);\n    }\n  `}(e,n)}}const RMe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",MMe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",OMe="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",FMe="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function ed(e){return`offset${e}`}function fp(e){const n=e.name,t=j(e.shapeInfo.logicalShape);return t<2?`return ${n};`:`\n    for (int i = 0; i < ${t}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function Xt(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function qM(e,n,t){const{newShape:r,keptDims:s}=Oa(n),o=n.length,i=e&&3===o&&1===n[0],a=i?n.slice(1):r,l=!e&&o>1&&!wt(n,t)&&r.length<o||i;return{useSqueezeShape:l,uniformShape:l?a:n,keptDims:s}}function pp(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function mp(e,n){return n.map(t=>e[t]).join(", ")}function d8(e,n,t){const r=[],s=[];let o,i,a,l=null,u=null;u=e.getUniformLocation(t,"NAN",!1),1===V().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const d of n.variableNames){const h={name:d,uniform:e.getUniformLocation(t,d,c),offset:e.getUniformLocation(t,`offset${d}`,c)};n.enableShapeUniforms&&(h.shape=e.getUniformLocation(t,`${d}Shape`,c),h.texShape=e.getUniformLocation(t,`${d}TexShape`,c)),r.push(h)}if(n.enableShapeUniforms&&(o=e.getUniformLocation(t,"outShape",c),a=e.getUniformLocation(t,"outShapeStrides",c),i=e.getUniformLocation(t,"outTexShape",c)),n.customUniforms)for(const d of n.customUniforms)s.push(e.getUniformLocation(t,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function h8(e,n){if(e.length!==n.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${n.length} inputs`);e.forEach((t,r)=>{const s=t.logicalShape,o=n[r],i=o.shape;if(!wt(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(t.isUniform&&o.isUniform)return;const a=t.texShape,l=o.isUniform?null:o.texData.texShape;if(!wt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function ts(e){return V().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class uOe{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=sS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=gs();this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?fS(["r","c","d"],n):Jc(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class cOe{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=sS.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=gs();this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?fS(["r","c","d"],n):Jc(["r","c","d"],n)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class dOe{constructor(n){this.variableNames=["A"],this.outTexUsage=Yo.DOWNLOAD;const t=gs();this.outputShape=n,this.userCode=`\n      ${a8}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class hOe{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Yo.DOWNLOAD;const t=gs();this.outputShape=n,this.userCode=`\n      ${a8}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const fOe={R:0,G:1,B:2,A:3};class f8{constructor(n,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=gs();this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++)i+=`\n          if(offset == ${a}) {\n            result = values[${fOe[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":jM(n)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${i}\n        }\n        ${s.output} = vec4(${o}, 0., 0., 0.);\n      }\n    `}}class pOe{constructor(n,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=gs();this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length);let s="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const l=2*i+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":jM(n)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${o};\n        }\n    `}}function Lv(e,n,t,r,s,o){!function aMe(e,n){const t=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0)throw new Error(`Requested texture size [${e}x${n}] is invalid.`);if(e>t||n>t)throw new Error(`Requested texture size [${e}x${n}] greater than WebGL maximum on this browser / GPU [${t}x${t}].`)}(n,t);const i=function iMe(e){return el(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),a=e.TEXTURE_2D;return be(e,()=>e.bindTexture(a,i)),be(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),be(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),be(e,()=>e.texParameteri(a,e.TEXTURE_MIN_FILTER,e.NEAREST)),be(e,()=>e.texParameteri(a,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===V().getNumber("WEBGL_VERSION")?be(e,()=>e.texImage2D(a,0,r,n,t,0,s,o,null)):be(e,()=>e.texStorage2D(a,1,r,n,t)),be(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[t,n]}}function p8(e){return e.internalFormatFloat}function m8(e){return e.internalFormatHalfFloat}function g8(e){return e.downloadTextureFormat}function y8(e){return e.internalFormatPackedFloat}function v8(e){return e.internalFormatPackedHalfFloat}class KM{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=V().getNumber("WEBGL_VERSION");if(null!=n?(this.gl=n,function WRe(e,n){fu[e]=n}(t,n)):this.gl=Ii(t),n=this.gl,2===V().getNumber("WEBGL_VERSION")){const o=n;this.createVertexArray=()=>be(o,()=>o.createVertexArray()),this.bindVertexArray=i=>be(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>be(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>be(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(null!=n){const o=n.getExtension("OES_vertex_array_object");if(null==o)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>be(n,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>be(n,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>be(n,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>be(n,()=>n.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===V().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=iS(this.gl,"OES_texture_float"),Zo(this.gl,i))this.textureHalfFloatExtension=iS(this.gl,i);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Zo(this.gl,s))this.colorBufferHalfFloatExtension=iS(this.gl,s);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Zo(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Zo(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function gOe(e){return function sMe(e,n){const t=el(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return be(e,()=>e.bindBuffer(e.ARRAY_BUFFER,t)),be(e,()=>e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW)),t}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function yOe(e){return function oMe(e,n){const t=el(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return be(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t)),be(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW)),t}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function lMe(e){return el(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=zM(this.gl,this.textureHalfFloatExtension)}get debug(){return V().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const n=this.gl;be(n,()=>n.finish()),be(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),be(n,()=>n.deleteFramebuffer(this.framebuffer)),be(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),be(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),be(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,t){return this.throwIfDisposed(),function vOe(e,n,t,r){const[s,o]=$v(n,t);return Lv(e,s,o,p8(r),r.textureFormatFloat,e.FLOAT)}(this.gl,n,t,this.textureConfig)}createFloat16MatrixTexture(n,t){return this.throwIfDisposed(),function bOe(e,n,t,r){const[s,o]=$v(n,t);return Lv(e,s,o,m8(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,n,t,this.textureConfig)}createUnsignedBytesMatrixTexture(n,t){return this.throwIfDisposed(),function wOe(e,n,t,r){const[s,o]=$v(n,t);return Lv(e,s,o,g8(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,n,t,this.textureConfig)}uploadPixelDataToTexture(n,t){this.throwIfDisposed(),function _Oe(e,n,t){be(e,()=>e.bindTexture(e.TEXTURE_2D,n)),t.data instanceof Uint8Array?2===V().getNumber("WEBGL_VERSION")?be(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,t.width,t.height,e.RGBA,e.UNSIGNED_BYTE,t.data)):be(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t.width,t.height,0,e.RGBA,e.UNSIGNED_BYTE,t.data)):2===V().getNumber("WEBGL_VERSION")?be(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,t)):be(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t)),be(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,n,t)}uploadDenseMatrixToTexture(n,t,r,s){this.throwIfDisposed(),function SOe(e,n,t,r,s,o){let i,a,l;be(e,()=>e.bindTexture(e.TEXTURE_2D,n)),s instanceof Uint8Array?(i=new Uint8Array(t*r*4),a=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(t*r*4),a=e.FLOAT,l=o.internalFormatPackedFloat),i.set(s),2===V().getNumber("WEBGL_VERSION")?be(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,t,r,e.RGBA,a,i)):be(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,t,r,0,e.RGBA,a,i)),be(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,n,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(n,t){return this.throwIfDisposed(),function COe(e,n,t,r){const[s,o]=up(n,t);return Lv(e,s,o,v8(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,n,t,this.textureConfig)}createPackedMatrixTexture(n,t){return this.throwIfDisposed(),function xOe(e,n,t,r){const[s,o]=up(n,t);return Lv(e,s,o,y8(r),e.RGBA,e.FLOAT)}(this.gl,n,t,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(s8(this.gl,this.framebuffer),this.outputTexture=null),be(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,t,r){return this.downloadMatrixDriver(n,()=>function NOe(e,n,t,r){const[s,o]=$v(n,t),a=new Uint8Array(function GRe(e,n){return e*n}(n*t,4));return be(e,()=>e.readPixels(0,0,s,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,t,r,s,o,i){return function TOe(e,n,t,r,s,o,i,a){const l=e,u=new Float32Array(function qRe(e,n){const[t,r]=up(e,n);return t*r*4}(o,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,n),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,n,0,0,0,o,i)}downloadFloat32MatrixFromBuffer(n,t){return function DOe(e,n,t){const r=e,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,n,t)}createBufferFromTexture(n,t,r){this.bindTextureToFrameBuffer(n);const s=function EOe(e,n,t){const s=e.createBuffer();be(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const a=16*n*t;return be(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),be(e,()=>e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,0)),be(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}(this.gl,t,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let t,r;if(V().getBool("WEBGL_FENCE_API_ENABLED")){const s=n,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{const i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},t=o}else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(n,t,r){return this.downloadMatrixDriver(n,()=>function kOe(e,n,t){const r=new Float32Array(n*t*4);return be(e,()=>e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,r)),r}(this.gl,t,r))}createProgram(n){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=function mOe(e){const n=gs();return function JRe(e,n){const t=el(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(be(e,()=>e.shaderSource(t,n)),be(e,()=>e.compileShader(t)),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}(e,`${n.version}\n    precision highp float;\n    ${n.attribute} vec3 clipSpacePos;\n    ${n.attribute} vec2 uv;\n    ${n.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const r=function nMe(e){return el(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);be(t,()=>t.attachShader(r,this.vertexShader)),be(t,()=>t.attachShader(r,n)),function rMe(e,n){if(be(e,()=>e.linkProgram(n)),!V().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(t,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&UM(t,s),s}buildVao(n){this.setProgram(n),this.bindVertexArray(n.vao);const t=this.gl;be(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function IOe(e,n,t){be(e,()=>e.bindBuffer(e.ARRAY_BUFFER,t)),r8(e,n,"clipSpacePos",t,3,20,0)&&r8(e,n,"uv",t,2,20,12)}(t,n,this.vertexBuffer)}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),null!=n&&(be(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,null!=this.program&&this.debug&&UM(this.gl,this.program),be(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,t,r=!0){return this.throwIfDisposed(),r?function cMe(e,n,t){return el(e,()=>e.getUniformLocation(n,t),'uniform "'+t+'" not present in program.')}(this.gl,n,t):function dMe(e,n,t){return e.getUniformLocation(n,t)}(this.gl,n,t)}getAttributeLocation(n,t){return this.throwIfDisposed(),be(this.gl,()=>this.gl.getAttribLocation(n,t))}getUniformLocationNoThrow(n,t){return this.throwIfDisposed(),this.gl.getUniformLocation(n,t)}setInputMatrixTexture(n,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),hMe(this.gl,n,t,r)}setOutputMatrixTexture(n,t,r){this.setOutputMatrixTextureDriver(n,r,t)}setOutputPackedMatrixTexture(n,t,r){this.throwIfDisposed();const[s,o]=up(t,r);this.setOutputMatrixTextureDriver(n,s,o)}setOutputMatrixWriteRegion(n,t,r,s){this.setOutputMatrixWriteRegionDriver(r,n,s,t)}setOutputPackedMatrixWriteRegion(n,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&UM(this.gl,this.program),aS(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const n=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}be(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),be(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=iS(this.gl,2===V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const n=this.getQueryTimerExtensionWebGL1(),t=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();return void t.endQuery(r.TIME_ELAPSED_EXT)}const n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){var t=this;return F(function*(){return yield k1(()=>t.disposed||t.isQueryAvailable(n,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(n,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(n,t){if(0===t)return null;if(2===t){const r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,t){if(0===t)return!0;if(2===t){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(n){return new Promise(t=>{this.addItemToPoll(()=>n.isFencePassed(),()=>t())})}pollItems(){const n=function AOe(e){let n=0;for(;n<e.length&&e[n]();++n);return n-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=n;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,t){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in V().platform&&(r=V().platform.setTimeoutCustom.bind(V().platform)),k1(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),WM(this.gl,n,this.framebuffer),this.debug&&aS(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(WM(this.gl,this.outputTexture,this.framebuffer),this.debug&&aS(this.gl)):s8(this.gl,this.framebuffer)}downloadMatrixDriver(n,t){this.bindTextureToFrameBuffer(n);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,t,r){this.throwIfDisposed();const s=this.gl;WM(s,n,this.framebuffer),this.debug&&aS(s),this.outputTexture=n,be(s,()=>s.viewport(0,0,t,r)),be(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(n,t,r,s){this.throwIfDisposed(),be(this.gl,()=>this.gl.scissor(n,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:ROe,XI:b8,Nk:MOe,f6:OOe,ct:FOe,YG:$Oe,hH:POe,z3:LOe,sG:VOe,uM:BOe,vS:zOe,qB:UOe,GG:WOe,rq:HOe,lg:jOe,WR:GOe,cu:qOe,GE:KOe,px:XOe,jC:YOe,He:ZOe,hE:QOe,BF:JOe,Dk:e2e,cl:t2e,_B:n2e,ub:r2e,_f:s2e,Ku:o2e,qy:i2e,Zy:a2e,bu:l2e,zv:u2e,dH:w8,HS:c2e,yH:d2e,l3:h2e,z9:x8,x6:f2e,_m:p2e,eW:m2e,GK:g2e,SP:y2e,yr:v2e,dl:b2e,Dw:w2e,xT:x2e,_X:XM,wz:C2e}=qr;function C8(e,n){return["x","y","z","w","u","v"].slice(0,n).map(t=>`${e}.${t}`)}function ys(e,n){return 1===n?[e]:C8(e,n)}class S2e{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=ts(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=ys("rc",this.rank),r=Xt(this.rank),s=this.getOutOfBoundsCondition(t),o=this.getSetup(t),i=this.getOutput(t);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(n){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${n[n.length-1-i]},`+o;t.push(o)}return t}getOutOfBoundsCondition(n){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(n){if(1===this.rank)return"";const t=n.slice(-2);return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(n){const t=this.getSourceCoordsArr(n);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class I8{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length);let r="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),r+=`\n        ${o}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function _2e(e,n){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n?function IMe(e,n,t="index"){const s=function CMe(e,n){const t=e.length,r=e.map(o=>`${n}[${o}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let o=t-3;o>=0;--o)s[o]=`(${s[o+1]} * ${r[o+1]})`;return s}(e.map((o,i)=>i),n);return s.map((o,i)=>`int ${e[i]} = ${t} / ${s[i]}; ${i===s.length-1?`int ${e[i+1]} = ${t} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`};`).join("")}(["r","c","d"],"inputShape"):Jc(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":jM(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class E2e{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,t,r){const s=_8(t,r),o=E8(n,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=S8(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[o].pop();return this.usedTextures[o].push(l),l}let a;return s===es.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):s===es.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):s===es.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):s===es.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):s===es.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,t,r,s){if(null==this.freeTextures)return;const o=_8(r,s),i=E8(t,o,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=S8(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=V().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(n);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const n in this.freeTextures)this.freeTextures[n].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const n in this.usedTextures)this.usedTextures[n].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function S8(e,n,t,r,s){const o=function N2e(e,n){switch(e){case es.PACKED_2X2_FLOAT32:return y8(n);case es.PACKED_2X2_FLOAT16:return v8(n);case es.UNPACKED_FLOAT32:return p8(n);case es.UNPACKED_FLOAT16:return m8(n);case es.PACKED_4X1_UNSIGNED_BYTE:return g8(n);default:throw new Error(`Unknown physical texture type ${e}`)}}(n,r);let i;if(s){const[l,u]=up(e[0],e[1]);i=l*u}else{const[l,u]=$v(e[0],e[1]);i=l*u}const a=function D2e(e,n){if(n===e.R32F)return 4;if(n===e.R16F)return 2;if(n===e.RGBA32F)return 16;if(n===e.RGBA)return 16;if(n===e.RGBA16F)return 8;if(n===e.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}(t,o);return i*a}function _8(e,n){if(e===Yo.UPLOAD)return es.PACKED_2X2_FLOAT32;if(e===Yo.RENDER||null==e)return function T2e(e){return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?es.PACKED_2X2_FLOAT32:es.UNPACKED_FLOAT32:e?es.PACKED_2X2_FLOAT16:es.UNPACKED_FLOAT16}(n);if(e===Yo.DOWNLOAD||e===Yo.PIXELS)return es.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function E8(e,n,t){return`${e[0]}_${e[1]}_${n}_${t}`}class da{constructor(n,t){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const To="if (isnan(x)) return x;",D8="return abs(x);",R2e=To+"\n  return (x < 0.0) ? 0.0 : x;\n",M2e=To+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",pu="return x;";class mu{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class B2e{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length);const t=n.length,r=ys("rc",t),s=Xt(t),o=function I2e(e,n){if(1===e)return"rc";let t="";for(let r=0;r<e;r++)t+=n[r],r<e-1&&(t+=",");return t}(t,r),i=r.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const z2e=iI,mS={},j2e=V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let K2e=(()=>{class e extends s0{nextDataId(){return e.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!V().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=t){if(t instanceof KM)r=t;else{const s=Ii(V().getNumber("WEBGL_VERSION"),t);r=new KM(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Ii(V().getNumber("WEBGL_VERSION"));r=new KM(s),this.binaryCache=function H2e(e){return e in mS||(mS[e]={}),mS[e]}(V().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new E2e(this.gpgpu),this.numMBBeforeWarning=function q2e(){return null==V().global.screen?1024:V().global.screen.height*V().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new N1(this,vo())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,r,s,o,i,a){const l=this.makeTensorInfo(r,s),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[o,i]},u.texShape=[o,i];const c=lS(r),d=new f8(c,!1,a),h=this.runWebGLProgram(d,[l],s,[[o,i]]);return h.shape=r,u.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(t,r,s){if((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||V().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===s&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:r,dtype:s,values:t,usage:Yo.UPLOAD,refCount:1}),o}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){this.texData.get(t).refCount++}decRef(t){this.texData.has(t)&&this.texData.get(t).refCount--}move(t,r,s,o,i){if(V().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:s,dtype:o,values:r,usage:Yo.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const r=this.texData.get(t),{values:s,dtype:o,complexTensorInfos:i,slice:a,shape:l,isPacked:u}=r;if(null!=a){let f;f=u?new mu(l,pu):new da(l,pu);const p=this.runWebGLProgram(f,[{dataId:t,shape:l,dtype:o}],o),m=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),m}if(null!=s)return this.convertAndCacheOnCPU(t);if("string"===o)return s;const c=null!=this.activeTimers;let d,h;return c&&(d=Vr()),h="complex64"===o?Ka(this.readSync(i.real.dataId),this.readSync(i.imag.dataId)):this.getValuesFromTexture(t),c&&(this.downloadWaitMs+=Vr()-d),this.convertAndCacheOnCPU(t,h)}read(t){var r=this;return F(function*(){if(r.pendingRead.has(t)){const g=r.pendingRead.get(t);return new Promise(y=>g.push(y))}const s=r.texData.get(t),{values:o,shape:i,slice:a,dtype:l,complexTensorInfos:u,isPacked:c}=s;if(null!=a){let g;g=c?new mu(i,pu):new da(i,pu);const y=r.runWebGLProgram(g,[{dataId:t,shape:i,dtype:l}],l),v=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),v}if(null!=o)return r.convertAndCacheOnCPU(t);if(V().getBool("DEBUG")&&!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===V().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&V().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(t);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture.texture,...oS(i))}if(r.pendingRead.set(t,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(u.real.dataId),r.read(u.imag.dataId)]);f=Ka(g[0],g[1])}else if(null==d)f=r.getValuesFromTexture(t);else{const g=j(i);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const g=r.gpgpu.gl;be(g,()=>g.deleteBuffer(d))}const p=r.convertAndCacheOnCPU(t,f),m=r.pendingRead.get(t);return r.pendingRead.delete(t),m.forEach(g=>g(p)),r.pendingDisposal.has(t)&&(r.pendingDisposal.delete(t),r.disposeData(t)&&vo().removeDataId(t,r),r.pendingDeletes--),p})()}readToGPU(t,r={}){const s=this.texData.get(t),{values:o,shape:i,slice:a,dtype:l,isPacked:u,texture:c}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let p;p=u?new mu(i,pu):new da(i,pu);const m=this.runWebGLProgram(p,[{dataId:t,shape:i,dtype:l}],l),g=this.readToGPU(m,r);return this.disposeIntermediateTensorInfo(m),g}if(null==c)throw null!=o?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(t,r.customTexShape),h=vo().makeTensorFromTensorInfo(d),f=this.texData.get(d.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(t){const r=this.readSync(t.dataId);if("string"===t.dtype)try{const s=r.map(o=>Pa(o));return it(t.shape,t.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return it(t.shape,t.dtype,r)}checkNumericalProblems(t){if(null!=t)for(let r=0;r<t.length;r++){const s=t[r];if(!ZRe(s))throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:r,dtype:s,isPacked:o}=this.texData.get(t),i=j(r);if(V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(t),p=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...oS(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),m}const a=V().getBool("WEBGL_PACK")&&!0===o,l=a?lS(r):r,u=a?new hOe(l):new dOe(l),c=this.runWebGLProgram(u,[{shape:l,dtype:s,dataId:t}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){var r=this;const s=this.activeTimers,o=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=o,i=!0):this.activeTimers.push(o),this.activeTimers=o,t();const a=Ki(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=Ki(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=s,i&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return F(function*(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(a);u.kernelMs=R4(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Vr(),endMs:null}}endTimer(t){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=Vr(),t)}getQueryTime(t){var r=this;return F(function*(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(t):t.endMs-t.startMs})()}disposeData(t,r=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(r?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!r&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:s}=this.texData.get(t);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:r,dtype:s,texShape:o,usage:i,isPacked:a,slice:l}=this.texData.get(t),u=l&&l.origDataId||t,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=r&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(r,o,i,a)));const d=this.texData.get(t);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,r=j2e){return V().getBool("WEBGL_CPU_FORWARD")&&t.every(s=>null==this.texData.get(s.dataId).texture&&j(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(t){yo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=t.dataSync();return z2e(t.shape,r)}packedUnaryOp(t,r,s){const o=new mu(t.shape,r),i=this.compileAndRun(o,[t],s);return vo().makeTensorFromTensorInfo(i)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const o=w8(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,o)}if(V().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,D8,t.dtype);const r=new da(t.shape,D8),s=this.compileAndRun(r,[t]);return vo().makeTensorFromTensorInfo(s)}makeTensorInfo(t,r,s){let o;if("string"===r&&null!=s&&s.length>0&&Gi(s[0])){const i=s.map(a=>qi(a));o=this.write(i,t,r)}else o=this.write(s,t,r);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:r}}makeOutput(t,r,s){return vo().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,s),this)}unpackTensor(t){const r=new B2e(t.shape);return this.runWebGLProgram(r,[t],t.dtype)}packTensor(t){const r=new S2e(t.shape);return this.runWebGLProgram(r,[t],t.dtype,null,!0)}packedReshape(t,r){const s=[cp(t.shape),...dp(t.shape)],o={dtype:t.dtype,shape:s,dataId:t.dataId},i=[cp(r),...dp(r)],a=new I8(i,s),c=this.runWebGLProgram(a,[o],t.dtype,[s],!0);return{dataId:c.dataId,shape:r,dtype:c.dtype}}decode(t,r){const s=this.texData.get(t),{isPacked:o,shape:i,dtype:a}=s;null!=r&&S(j(i)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=lS(i);let u;u=o?new cOe(l):new uOe(l);const d=[r??oS(l)];return{dtype:a,shape:i,dataId:this.runWebGLProgram(u,[{shape:l,dtype:a,dataId:t}],a,d,!0,r).dataId}}runWebGLProgram(t,r,s,o,i=!1,a){const l=this.makeTensorInfo(t.outputShape,s),u=this.texData.get(l.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===sS.DENSE){const v=a??oS(t.outputShape);u.texShape=v.map(b=>2*b)}if(null!=t.outTexUsage&&(u.usage=t.outTexUsage),0===j(l.shape))return u.values=Er(l.dtype,0),l;const c=[],d=r.map(v=>{if("complex64"===v.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(v.dataId);if(null==b.texture){if(!t.packedInputs&&j(v.shape)<=V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!b.isPacked!=!!t.packedInputs)v=b.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),b=this.texData.get(v.dataId);else if(b.isPacked&&!cS(b.shape,v.shape)){const w=v,x=v.shape;v.shape=b.shape,v=this.packedReshape(v,x),c.push(v),b=this.texData.get(v.dataId),w.shape=x}return{shape:v.shape,texData:b,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:u,isUniform:!1},f=function lOe(e,n,t){let r="";n.concat(t).forEach(i=>{const a=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=qM(e.packedInputs,i.shape,l);let h="",f="",p="";if(1===c.length&&e.packedInputs){const x=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${x[0]>1}_${x[1]>1}`}else if(2!==c.length||e.packedInputs){if(c.length>2&&!e.packedInputs){const x=Oe(c);p=`${x[0]===l[1]}_${x[x.length-1]===l[1]}`}}else f=`${c[0]>1}_${c[1]>1}`;const m=i.shape.length,g=2===c.length&&wt(i.shape,l),y=1===j(i.shape),v=Rc(i.shape,t.shape),b=!e.packedInputs&&m===t.shape.length&&wt(l,t.texData.texShape);r+=`${m}_${b}_${u?d:""}_${c.length}_${y}_${v}_${g}_${h}_${f}_${p}_${e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${a}`});let o=e.constructor.name;return o+="_"+r+"_"+e.userCode+`${V().getNumber("WEBGL_VERSION")}`,o}(t,d,h),p=this.getAndSaveBinary(f,()=>function iOe(e,n,t,r){const s=t.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:n.variableNames[d],shapeInfo:h}}),o=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=SMe(s,i,n),l=function eMe(e,n){const t=el(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(be(e,()=>e.shaderSource(t,n)),be(e,()=>e.compileShader(t)),V().get("ENGINE_COMPILE_ONLY"))return t;if(!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw n8(n,e.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}(e.gl,a),u=e.createProgram(l);return V().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:n,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:o,outShapeInfo:i},d8(e,n,u)))}(this.gpgpu,t,d,h)),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),V().get("ENGINE_COMPILE_ONLY")||function aOe(e,n,t,r,s){n.program.enableShapeUniforms||(h8(n.inShapeInfos,t),h8([n.outShapeInfo],[r]));const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):e.setOutputMatrixTexture(o.texture,i[0],i[1]),e.setProgram(n.webGLProgram),e.bindVertexArray(n.webGLProgram.vao),1===V().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&e.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&e.gl.uniform1f(n.nanLoc,NaN);for(let l=0;l<t.length;++l){const u=t[l],{uniform:c,offset:d,shape:h,texShape:f}=n.variablesLocations[l];if(h){const{uniformShape:p}=qM(n.program.packedInputs,u.shape,u.texData.texShape);switch(p.length){case 1:e.gl.uniform1iv(h,new Int32Array(p));break;case 2:e.gl.uniform2iv(h,new Int32Array(p));break;case 3:e.gl.uniform3iv(h,new Int32Array(p));break;case 4:e.gl.uniform4iv(h,new Int32Array(p))}}if(f&&e.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),null!=c){if(u.isUniform){if(j(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let p=u.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),e.gl.uniform1fv(c,p)}continue}null!=u.texData.slice&&null!=d&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:e.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(a,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const l=Oe(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(l))}}if(n.outTexShapeLocation&&e.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&s)for(let l=0;l<n.program.customUniforms.length;++l){const u=n.program.customUniforms[l],c=n.customUniformLocations[l],d=s[l];if("float"===u.type)e.gl.uniform1fv(c,d);else if("vec2"===u.type)e.gl.uniform2fv(c,d);else if("vec3"===u.type)e.gl.uniform3fv(c,d);else if("vec4"===u.type)e.gl.uniform4fv(c,d);else if("int"===u.type)e.gl.uniform1iv(c,d);else if("ivec2"===u.type)e.gl.uniform2iv(c,d);else if("ivec3"===u.type)e.gl.uniform3iv(c,d);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);e.gl.uniform4iv(c,d)}}e.executeProgram()}(this.gpgpu,p,d,h,o),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),m&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));const y=V().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const v=Vr();v-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!V().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===i){const v=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),v}return l}compileAndRun(t,r,s,o,i=!1){return this.runWebGLProgram(t,r,s=s||r[0].dtype,o,i)}getAndSaveBinary(t,r){return t in this.binaryCache||(this.binaryCache[t]=r()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(V().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=L(()=>{if(!V().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=V().getBool("DEBUG");V().set("DEBUG",!1);const r=this.abs(Re(1e-8)).dataSync()[0];if(V().set("DEBUG",t),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const r=this.texData.get(t),{shape:s,dtype:o,values:i,texture:a,usage:l,isPacked:u}=r;if(null!=a)return;const c=null!=this.activeTimers;let d;c&&(d=Vr());let h=r.texShape;if(null==h&&(h=function pMe(e,n=!1){let t=V().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=V().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&V().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),n&&(t*=2,r*=2,1===(e=e.map((a,l)=>l>=e.length-2?o0(e[l]):e[l])).length&&(e=[2,e[0]])),2!==e.length&&(e=Oa(e).newShape);let s=j(e),o=null;e.length<=1&&s<=t?o=[1,s]:2===e.length&&e[0]<=t&&e[1]<=t?o=e:3===e.length&&e[0]*e[1]<=t&&e[2]<=t?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=t&&e[1]*e[2]<=t?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=t&&e[3]<=t?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=t&&e[1]*e[2]*e[3]<=t&&(o=[e[0],e[1]*e[2]*e[3]]);const i=null!=o&&Math.max(...o)>r&&Math.min(...o)<=(n?2:1)&&Math.min(...o)>0;if(null==o||i)if(n){const a=cp(e);let l=2,u=2;e.length&&([l,u]=dp(e)),s=a*(l/2)*(u/2),o=a0(s).map(c=>2*c)}else o=a0(s);return o}(s,u),r.texShape=h),null!=i){const f=lS(s);let p,m=h[1],g=h[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(u||!y)&&([m,g]=up(h[0],h[1])),p=u?new pOe(f,y):new f8(f,y);const v=y?[g,m]:h,b=this.makeTensorInfo(v,o),w=this.texData.get(b.dataId);w.usage=y?Yo.PIXELS:Yo.UPLOAD,w.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),m,g,i);const _=this.runWebGLProgram(p,[b],o,[[g,m]],!0),D=this.texData.get(_.dataId);r.texShape=D.texShape,r.isPacked=D.isPacked,r.usage=D.usage,V().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(r.texture=D.texture,r.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=Vr()-d)}else{const f=this.acquireTexture(h,l,o,u);r.texture=f}}convertAndCacheOnCPU(t,r){const s=this.texData.get(t),{dtype:o}=s;return null!=r&&(s.values=function X2e(e,n){if("float32"===n||"complex64"===n)return e;if("int32"===n||"bool"===n){const t="int32"===n?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<t.length;++r)t[r]=Math.round(e[r]);return t}throw new Error(`Unknown dtype ${n}`)}(r,o)),s.values}acquireTexture(t,r,s,o){if(this.numBytesInGPU+=this.computeBytes(t,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,r,o)}computeBytes(t,r){return t[0]*t[1]*Ag(r)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}checkCompileCompletionAsync(){var t=this;return F(function*(){const r=[];if(t.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(t.binaryCache))r.push(t.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(t.binaryCache)){const o=new Promise(i=>{try{t.checkCompletion_(s),i(!0)}catch(a){throw a}});r.push(o)}return Promise.all(r)})()}checkCompletionAsync_(t){var r=this;return F(function*(){return r.gpgpu.gl.getProgramParameter(t.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(t):(yield QA(),r.checkCompletionAsync_(t))})()}checkCompletion_(t){if(!1===this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(n8(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:r,customUniformLocations:s,infLoc:o,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:u}=d8(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=r,t.customUniformLocations=s,t.infLoc=o,t.nanLoc=i,t.outShapeLocation=a,t.outShapeStridesLocation=l,t.outTexShapeLocation=u}}createTensorFromGPUData(t,r,s){t.channels=t.channels||"RGBA";const{texture:o,height:i,width:a,channels:l}=t,u=vo().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(o,r,s,i,a,l);return vo().makeTensorFromDataId(c,r,s,u)}}return e.nextDataId=0,e})();H1()&&q1("webgl",()=>new K2e,2);const YM="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class td{constructor(n,t,r){this.variableNames=["A","B"],this.outputShape=et(t,r),this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const nd="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class gp{constructor(n,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=et(t,r);const o=this.outputShape.length;this.enableShapeUniforms=ts(o);let i="";if(s)if(0===o||1===j(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${Xt(o)} coords = getOutputCoords();\n        `,1===o)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=ys("coords",o);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= outShape[${o} - 2];\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= outShape[${o} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[o-2]} + 1) >= ${this.outputShape[o-2]};\n            bool nextColOutOfBounds =\n              (${l[o-1]} + 1) >= ${this.outputShape[o-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${n}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function to(e){const{inputs:n,backend:t}=e,{x:r}=n;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Q2e={kernelName:nf,backendName:"webgl",kernelFunc:to};function gu(e){const{inputs:n,backend:t}=e,{real:r,imag:s}=n,o=t.makeTensorInfo(r.shape,"complex64"),i=t.texData.get(o.dataId),a=to({inputs:{x:r},backend:t}),l=to({inputs:{x:s},backend:t});return i.complexTensorInfos={real:a,imag:l},o}const J2e={kernelName:y0,backendName:"webgl",kernelFunc:gu},N8="return (a < 0.) ? b * a : a;",T8="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",tFe={kernelName:ey,backendName:"webgl",kernelFunc:function eFe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{alpha:o}=r,i=t.makeTensorInfo([],"float32",$a(o,"float32")),a=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gp(T8,s.shape,i.shape):new td(N8,s.shape,i.shape),l=t.runWebGLProgram(a,[s,i],"float32");return t.disposeIntermediateTensorInfo(i),l}},k8="return (a < 0.) ? b * a : a;",A8="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",rFe={kernelName:by,backendName:"webgl",kernelFunc:function nFe(e){const{inputs:n,backend:t}=e,{x:r,alpha:s}=n,o=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gp(A8,r.shape,s.shape):new td(k8,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],"float32")}},yp="if (isnan(x)) return x;";function At({opSnippet:e,packedOpSnippet:n,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=t){const d=a.texData.get(i.dataId),h=t(d.values,l);return a.makeTensorInfo(i.shape,l,h)}let c;return c=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new mu(i.shape,n):new da(i.shape,e),a.runWebGLProgram(c,[i],l)}}function jr({opSnippet:e,packedOpSnippet:n,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:l,b:u}=i,c=a;if(r&&"complex64"===l.dtype){const p=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(b=>{const[w,x]=b,I={dataId:w.dataId,dtype:w.dtype,shape:l.shape},_={dataId:x.dataId,dtype:x.dtype,shape:u.shape},D=new td(e,l.shape,u.shape);return c.runWebGLProgram(D,[I,_],Ts(w.dtype,x.dtype))}),v=gu({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),v}const d=o||Ts(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const p=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g="string"===l.dtype?Xa(p):p,y="string"===l.dtype?Xa(m):m,[v,b]=s(l.shape,u.shape,g,y,d),w=c.makeTensorInfo(b,d);return c.texData.get(w.dataId).values=v,w}let f;return f=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new gp(n,l.shape,u.shape,t):new td(e,l.shape,u.shape),c.runWebGLProgram(f,[l,u],d)}}function Vv(e,n=!1){if("linear"===e)return"return x;";if("relu"===e)return n?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":R2e;if("elu"===e)return n?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return n?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":M2e;if("prelu"===e)return n?A8:k8;if("leakyrelu"===e)return n?T8:N8;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class R8{constructor(n,t,r,s=!1,o=!1,i=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ts(this.outputShape.length);const d=Math.ceil((s?n[1]:n[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=o?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const v=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",w="rc.x";n[0]<t[0]?b=`imod(rc.x, ${n[0]})`:t[0]<n[0]&&(w=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${w};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${m[0]});\n          result += (${p[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${v}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class O8{constructor(n,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=et(t,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${n}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const F8="return a * b;";function ZM(e){const{inputs:n,backend:t}=e,{a:r,b:s}=n,o=Ts(r.dtype,s.dtype);if("complex64"===r.dtype){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),u=new O8("return areal * breal - aimag * bimag;",r.shape,s.shape),c=new O8("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=t.runWebGLProgram(u,d,"float32"),f=t.runWebGLProgram(c,d,"float32"),p=gu({inputs:{real:h,imag:f},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),p}if(t.shouldExecuteOnCPU([r,s])){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),[u,c]=JOe(r.shape,s.shape,a.values,l.values,o),d=t.makeTensorInfo(c,o);return t.texData.get(d.dataId).values=u,d}let i;return i=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gp(F8,r.shape,s.shape):new td(F8,r.shape,s.shape),t.runWebGLProgram(i,[r,s],o)}const sFe={kernelName:ff,backendName:"webgl",kernelFunc:ZM};function ye(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{shape:o}=r,i=t,a=j(s.shape),l=A1(o,a),u=j(l);S(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||cS(s.shape,l)||null!==c.texture&&cS(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function oFe(e,n,t){const r=[cp(e.shape),...dp(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[cp(n),...dp(n)],i=new I8(o,r),u=t.runWebGLProgram(i,[s],e.dtype,[r],!0);return{dataId:u.dataId,shape:n,dtype:u.dtype}}(s,l,i)}const iFe={kernelName:xy,backendName:"webgl",kernelFunc:ye};class $8{constructor(n,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];const a=4*Math.floor(r/4),l=r%4;let u="sumValue += dot(values, ones);";if(null!=t){const d=1/t;u=`sumValue += dot(values * ${bc(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class aFe{constructor(n,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:i}=n;this.outputShape=[s,i];let a="0.0",l="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",l="min"):"max"===t&&(a="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const c=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===t?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===t&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function rd(e,n,t,r){const s=function lFe(e){const n=[];for(;0===n.length||1!==n[n.length-1].outSize;){const t=n.length?n[n.length-1].outSize:e[1],r=mI(t);n.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return n}(e.shape);let o=e;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===t?0===i?new $8({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:u},a):new $8({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:u}):new aFe({windowSize:l,inSize:a,batchSize:e.shape[0],outSize:u},t),d=o,o=r.runWebGLProgram(c,[o],n),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class uFe{constructor(n,t){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[t[i]];this.outputShape=r,this.rank=r.length;const s=Xt(this.rank),o=function cFe(e){const n=e.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let s=0;s<e.length;s++)r[e[s]]=t[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${o}));\n    }\n    `}}class dFe{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(n.length);for(let c=0;c<r.length;c++)r[c]=n[t[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Xt(this.rank),o=C8("rc",this.rank),i=new Array(this.rank);for(let c=0;c<t.length;c++)i[t[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,l=`++${o[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${o[this.rank-1]};\n      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function gS(e,n,t){const r=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dFe(e.shape,n):new uFe(e.shape,n);return t.runWebGLProgram(r,[e],e.dtype)}function yS(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r;return function hFe(e,n,t,r){const o=e.shape.length,i=pt(n,e.shape);let a=i;const l=Dn(a,o),u=null!=l;let c=e;u&&(c=gS(e,l,r),a=Hn(a.length,o)),Ur("sum",a,o);const[d,h]=kr(c.shape,a);let f=d;t&&(f=Wn(d,i));const p=j(h),y=ye({inputs:{x:c},attrs:{shape:[j(e.shape)/p,p]},backend:r}),b=rd(y,IC(e.dtype),"sum",r),w=ye({inputs:{x:b},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),w}(s,o,i,t)}const fFe={kernelName:Dy,backendName:"webgl",kernelFunc:yS};function vs(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{perm:o}=r,i=t,l=new Array(s.shape.length);for(let c=0;c<l.length;c++)l[c]=s.shape[o[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=XM(d,s.shape,s.dtype,o,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=h}else u=gS(s,o,i);return u}const pFe={kernelName:Sc,backendName:"webgl",kernelFunc:vs};function vS({a:e,b:n,transposeA:t,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){const u=e.shape.length,c=n.shape.length,d=t?e.shape[u-2]:e.shape[u-1],h=r?n.shape[c-1]:n.shape[c-2],f=t?e.shape[u-1]:e.shape[u-2],p=r?n.shape[c-2]:n.shape[c-1],m=e.shape.slice(0,-2),g=n.shape.slice(0,-2),y=j(m),v=j(g),w=et(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${t} and transposeB=${r} must match.`);const x=t?[y,d,f]:[y,f,d],I=r?[v,p,h]:[v,h,p],_=ye({inputs:{x:e},backend:s,attrs:{shape:x}}),D=ye({inputs:{x:n},backend:s,attrs:{shape:I}}),N=[_,D],T=Math.max(y,v),P=t?_.shape[1]:_.shape[2],B=null!=o,W=null!=i,H="leakyrelu"===l,G=null!=l?Vv(l,!0):null;let Q;if((1===f||1===p)&&P>1e3&&!1===(B||W||H||null!=G)){let J=_,ie=D;t&&(J=vs({inputs:{x:_},backend:s,attrs:{perm:[0,2,1]}}),N.push(J)),r&&(ie=vs({inputs:{x:D},backend:s,attrs:{perm:[0,2,1]}}),N.push(ie));const me=1===p;let de=J;1!==p&&(de=ye({inputs:{x:J},backend:s,attrs:{shape:[T,P,1]}}),N.push(de));const xe=1===p?2:1;let ge=ie;me&&(ge=ye({inputs:{x:ie},backend:s,attrs:{shape:[T,1,P]}}),N.push(ge));const Ie=ZM({inputs:{a:de,b:ge},backend:s});Q=yS({inputs:{x:Ie},backend:s,attrs:{axis:xe,keepDims:!0}}),N.push(Ie)}else{const J=Ts(e.dtype,n.dtype),ie=new R8(x,I,[T,f,p],t,r,B,G,W,H),ue=[_,D];if(null!=o&&ue.push(o),W&&ue.push(i),H){const me=s.makeTensorInfo([],"float32",$a(a,"float32"));ue.push(me),N.push(me)}Q=s.runWebGLProgram(ie,ue,J)}const q=ye({inputs:{x:Q},backend:s,attrs:{shape:w}});N.push(Q);for(const J of N)s.disposeIntermediateTensorInfo(J);return q}const gFe={kernelName:Fy,backendName:"webgl",kernelFunc:function mFe(e){const{inputs:n,backend:t,attrs:r}=e,{a:s,b:o,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return vS({a:s,b:o,transposeA:l,transposeB:u,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:d,activation:c})}},L8="return abs(x);",vFe={kernelName:Rg,backendName:"webgl",kernelFunc:function yFe(e){const{inputs:n,backend:t}=e,{x:r}=n;if(t.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const o=t.texData.get(r.dataId),i=w8(o.values);return t.makeTensorInfo(r.shape,r.dtype,i)}let s;return s=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mu(r.shape,L8):new da(r.shape,L8),t.runWebGLProgram(s,[r],r.dtype)}},wFe=At({opSnippet:To+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),xFe={kernelName:Fh,backendName:"webgl",kernelFunc:wFe},IFe=At({opSnippet:To+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),SFe={kernelName:$h,backendName:"webgl",kernelFunc:IFe},V8="return a + b;",_Fe=jr({opSnippet:V8,packedOpSnippet:V8,supportsComplex:!0,cpuKernelImpl:ROe}),EFe={kernelName:Ic,backendName:"webgl",kernelFunc:_Fe};class DFe{constructor(n,t){this.outputShape=[],this.outputShape=n,this.variableNames=t.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class NFe{constructor(n,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=t.map((o,i)=>`T${i}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const TFe={kernelName:Mg,backendName:"webgl",kernelFunc:function bS(e){const{inputs:n,backend:t}=e,r=n;if(1===r.length)return to({inputs:{x:r[0]},backend:t});if(r.length>V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=bS({inputs:r.slice(0,l),backend:t}),c=bS({inputs:r.slice(l),backend:t});return bS({inputs:[u,c],backend:t})}const s=r.map(l=>l.dtype).reduce((l,u)=>Ts(l,u)),o=r.map(l=>l.shape),a=V().getBool("WEBGL_PACK")?new NFe(r[0].shape,o):new DFe(r[0].shape,o);return t.runWebGLProgram(a,r,s)}},AFe={kernelName:d0,backendName:"webgl",kernelFunc:function kFe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=pt(o,s.shape);let u=l;const c=Dn(u,a);let d=s;null!=c&&(d=vs({inputs:{x:s},backend:t,attrs:{perm:c}}),u=Hn(u.length,a)),Ur("all",u,a);const[h,f]=kr(d.shape,u),m=ye({inputs:{x:d},backend:t,attrs:{shape:[-1,j(f)]}}),g=rd(m,m.dtype,"all",t);let y;return y=ye(i?{inputs:{x:g},backend:t,attrs:{shape:Wn(h,l)}}:{inputs:{x:g},backend:t,attrs:{shape:h}}),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),null!=c&&t.disposeIntermediateTensorInfo(d),y}},MFe={kernelName:h0,backendName:"webgl",kernelFunc:function RFe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=pt(o,s.shape);let u=l;const c=Dn(u,a);let d=s;null!=c&&(d=vs({inputs:{x:s},backend:t,attrs:{perm:c}}),u=Hn(u.length,a)),Ur("any",u,a);const[h,f]=kr(d.shape,u),m=ye({inputs:{x:d},backend:t,attrs:{shape:[-1,j(f)]}}),g=rd(m,m.dtype,"any",t);let y;return y=ye(i?{inputs:{x:g},backend:t,attrs:{shape:Wn(h,l)}}:{inputs:{x:g},backend:t,attrs:{shape:h}}),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),null!=c&&t.disposeIntermediateTensorInfo(d),y}};class OFe{constructor(n,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class FFe{constructor(n,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(n[n.length-1]/t);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Xt(l),c=ys("coords",l);let d,h;if(1===i){h=l+1;const D=Xt(h);d=`\n        ${D} sourceLocR = ${D}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${D} sourceLocG = ${D}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${D} sourceLocA = ${D}(${c.join()}, 0);\n        --${c[l-1]};\n        ${D} sourceLocB = ${D}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],m=f.map(D=>"int "+D),g=ys("sourceLocR",h-1).concat("inIdx.r"),y=ys("sourceLocG",h-1).concat("inIdx.g"),v=ys("sourceLocB",h-1).concat("inIdx.b"),b=ys("sourceLocA",h-1).concat("inIdx.a"),w="max"===r?"greaterThan":"lessThan",x=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${v.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,I=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${v.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,_=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${_}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${I};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${I};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function B8(e,n,t,r=null){let s=n.shape[0],o=n.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=mI(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},l=new OFe(a,t,null==r),u=[n];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=B8(e,n,t,c);return e.disposeIntermediateTensorInfo(c),d}function z8(e,n,t,r=null){const s=null!=r?r.shape:n.shape,i=mI(s[s.length-1]),a=new FFe(s,i,t,null==r),u=e.runWebGLProgram(a,null==r?[n]:[n,r],"int32");if(u.shape.length===n.shape.length){const c=z8(e,n,t,u);return e.disposeIntermediateTensorInfo(u),c}return u}function U8(e,n,t,r){const s=[t];if(Ur("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,n.shape.length),!V().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){const o=[],i=e.texData.get(n.dataId);let l=n;null!==i&&i.isPacked&&(l=e.unpackTensor(n),o.push(l));const[u,c]=kr(l.shape,s),d=j(c),h=ye({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});o.push(h);const f=B8(e,h,r);o.push(f);const p=ye({inputs:{x:f},backend:e,attrs:{shape:u}});return o.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}return z8(e,n,r)}const PFe={kernelName:Og,backendName:"webgl",kernelFunc:function $Fe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o}=r;let i=pt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=vs({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),i=Hn(i.length,l.shape.length)),Ur("argMax",[i[0]],l.shape.length);const c=U8(t,l,i[0],"max");return u.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}},VFe={kernelName:Fg,backendName:"webgl",kernelFunc:function LFe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o}=r;let i=pt(o,s.shape);const a=Dn(i,s.shape.length);let l=s;const u=[];null!=a&&(l=vs({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),i=Hn(i.length,l.shape.length)),Ur("argMin",[i[0]],l.shape.length);const c=U8(t,l,i[0],"min");return u.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}},zFe=At({opSnippet:To+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),UFe={kernelName:Ph,backendName:"webgl",kernelFunc:zFe},HFe=At({opSnippet:To+"return log(x + sqrt(x * x + 1.0));"}),jFe={kernelName:Lh,backendName:"webgl",kernelFunc:HFe},qFe=At({opSnippet:To+"\n  return atan(x);\n"}),KFe={kernelName:Vh,backendName:"webgl",kernelFunc:qFe},ZFe=jr({opSnippet:YM+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nd+"\n  return result;\n"}),QFe={kernelName:zh,backendName:"webgl",kernelFunc:ZFe},e$e=At({opSnippet:To+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),t$e={kernelName:Bh,backendName:"webgl",kernelFunc:e$e};class Bv{constructor(n,t,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideHeight,l=n.strideWidth,u=n.dilationHeight,c=n.dilationWidth,d=n.effectiveFilterHeight,h=n.effectiveFilterWidth,f=n.padInfo.top,p=n.padInfo.left;this.outputShape=n.outShape;const m="avg"===t;let v="0.0";if(m||(v="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?o?`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`:`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");const x=4*Math.floor(i/4),I=i%4,_=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${_}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${_}\n          } else if (${2===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${_}\n          } else if (${3===I}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${_}\n          }\n        }\n        setOutput(${w});\n      }\n    `}}class QM{constructor(n,t,r,s=!1,o=!1){if(this.variableNames=["x"],"avg"===t&&r)throw new Error("Cannot compute positions for average pool.");const i=n.filterWidth,a=n.strideDepth,l=n.strideHeight,u=n.strideWidth,c=n.dilationDepth,d=n.dilationHeight,h=n.dilationWidth,f=n.effectiveFilterDepth,p=n.effectiveFilterHeight,m=n.effectiveFilterWidth,g=n.padInfo.front,y=n.padInfo.top,v=n.padInfo.left;this.outputShape=n.outShape;const b="avg"===t;let w="0.0";if(b||(w="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${u});\n        const ivec3 pads = ivec3(${g}, ${y}, ${v});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?o?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${p} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(I="avgValue / max(count, 1.0)");const _=4*Math.floor(i/4),D=i%4,N=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${u});\n      const ivec3 pads = ivec3(${g}, ${y}, ${v});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${_}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${N}\n            }\n\n            int xC = xCCorner + ${_};\n            if (${1===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${2===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${N}\n            } else if (${3===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${N}\n            }\n          }\n        }\n        setOutput(${I});\n      }\n    `}}const r$e={kernelName:$g,backendName:"webgl",kernelFunc:function n$e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n;Pv(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(Br(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Wo(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))return to({inputs:{x:s},backend:t});const d=new Bv(c,"avg",!1);return t.runWebGLProgram(d,[s],"float32")}},o$e={kernelName:Pg,backendName:"webgl",kernelFunc:function s$e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:u}=r,d=za(s.shape,o,i,[1,1,1],a,l,u),h=new QM(d,"avg",!1);return t.runWebGLProgram(h,[s],"float32")}};class i$e{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const l=n.effectiveFilterHeight,u=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-n.padInfo.top}, ${u-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${n.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class a$e{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;const d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,f=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-n.padInfo.front}, ${h-1-n.padInfo.top}, ${f-1-n.padInfo.left});\n      const float avgMultiplier = float(${1/(n.filterDepth*n.filterHeight*n.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const u$e={kernelName:p0,backendName:"webgl",kernelFunc:function l$e(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=za(i.shape,a,l,[1,1,1],u,c),f=new a$e(h);return t.runWebGLProgram(f,[s],i.dtype)}},d$e={kernelName:f0,backendName:"webgl",kernelFunc:function c$e(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o}=n,i=o;Pv([s,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=Wo(i.shape,a,l,1,u),d=new i$e(c);return t.runWebGLProgram(d,[s],i.dtype)}},f$e={kernelName:Lg,backendName:"webgl",kernelFunc:function h$e(e){const{inputs:n,backend:t,attrs:r}=e,{a:s,b:o}=n,{transposeA:i,transposeB:a}=r;return vS({a:s,b:o,transposeA:i,transposeB:a,backend:t})}};class p$e{constructor(n,t,r,s,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],et(n,t),et(n,r);let a="0.0";null!=s&&(et(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=o&&(et(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class m$e{constructor(n,t,r,s,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],et(n,t),et(n,r);let a="vec4(0.0)";null!=s&&(et(n,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=o&&(et(n,o),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const g$e={kernelName:Zg,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=e;S(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;null==l&&(l=.001);const u=[r,s,o];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=a&&(d=a.shape,u.push(a));const h=V().getBool("WEBGL_PACK_NORMALIZATION")?new m$e(r.shape,s.shape,o.shape,c,d,l):new p$e(r.shape,s.shape,o.shape,c,d,l);return n.runWebGLProgram(h,u,u[0].dtype)}};class y$e{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const t=Xt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function v$e(e){if(1===e)return"sourceLoc";if(e<=6)return JM.slice(0,e).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${n.map((i,a)=>`sourceLoc.${JM[a]} = start[${a}] + coords.${JM[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const JM=["x","y","z","w","u","v"];class b$e{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Xt(this.rank),r=ys("coords",this.rank),s=ys("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${o})`,a=`\n      result.x = ${i};\n      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${n.map((c,d)=>`start[${d}]`).join()});`:n.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function vp(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{begin:o,size:i}=r,[a,l]=OC(s,o,i);if(Rk(s,a,l),0===j(l))return t.makeTensorInfo(l,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=t.texData.get(s.dataId),h=c2e(d.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=t.texData.get(s.dataId),c=Ok(s.shape,a,l);if(u||!c){const d=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new b$e(l):new y$e(l);return t.runWebGLProgram(d,[s],s.dtype,[a])}return t.uploadToGPU(s.dataId),function w$e(e,n,t,r){const s=r.texData.get(e.dataId),o=r.makeTensorInfo(t,e.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=t,i.dtype=e.dtype;let a=Fk(n,Oe(e.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),o}(s,a,l,t)}const x$e={kernelName:Ey,backendName:"webgl",kernelFunc:vp},C$e={kernelName:Vg,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{blockShape:o,crops:i}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((v,b)=>v*b),l=gv(s.shape,o,a),u=yv(l.length,o.length),c=vv(s.shape,o,a),d=nR(i,o.length),h=rR(c,i,o.length),f=[],p=ye({inputs:{x:s},backend:t,attrs:{shape:l}}),m=vs({inputs:{x:p},backend:t,attrs:{perm:u}}),g=ye({inputs:{x:m},backend:t,attrs:{shape:c}}),y=vp({inputs:{x:g},backend:t,attrs:{begin:d,size:h}});return f.push(p),f.push(m),f.push(g),f.forEach(v=>t.disposeIntermediateTensorInfo(v)),y}},S$e={kernelName:m0,backendName:"webgl",kernelFunc:function I$e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,weights:o}=n,{size:i}=r,a=t.readSync(s.dataId),l=t.readSync(o.dataId),u=b8(a,l,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}},N$e={kernelName:Bg,backendName:"webgl",kernelFunc:function D$e(e){const{inputs:n,backend:t}=e,{a:r,b:s}=n,o=V().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=V().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,s])||1===i){const l=t.texData.get(r.dataId).values,u=t.texData.get(s.dataId).values,[c,d]=OOe(r.shape,s.shape,l,u,r.dtype),h=t.makeTensorInfo(d,r.dtype);return t.texData.get(h.dataId).values=c,h}let a;return a=o?new gp("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new td("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),t.runWebGLProgram(a,[r,s],r.dtype)}},k$e={kernelName:g0,backendName:"webgl",kernelFunc:function T$e(e){const{inputs:n,backend:t}=e,{s0:r,s1:s}=n,o=t.readSync(r.dataId),i=t.readSync(s.dataId),a=et(Array.from(o),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},W8=jr({opSnippet:"return float(a != b);",cpuKernelImpl:t2e,dtype:"bool"}),A$e={kernelName:py,backendName:"webgl",kernelFunc:W8};function zv(e){const{inputs:n,backend:t}=e,{input:r}=n;return to({inputs:{x:t.texData.get(r.dataId).complexTensorInfos.real},backend:t})}const R$e={kernelName:Q0,backendName:"webgl",kernelFunc:zv},F$e={kernelName:Uh,backendName:"webgl",kernelFunc:function eO(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return to({inputs:{x:s},backend:t});const i=tr(s.shape),a=eO({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=gu({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const i=zv({inputs:{input:s},backend:t}),a=eO({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(i),a}if(!R1(s.dtype,o)){const i=to({inputs:{x:s},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId).values,[a,l,u]=FOe(i,s.shape,s.dtype,o);return t.makeTensorInfo(a,l,u)}if("int32"===o)return function O$e(e,n){const t=new da(e.shape,"return float(int(x));"),r=n.runWebGLProgram(t,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,t);if("bool"===o){const i=t.makeTensorInfo([],"bool",Er("bool",1)),l=W8({inputs:{a:s,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}},H8="return ceil(x);",$$e=At({opSnippet:H8,packedOpSnippet:H8,cpuKernelImpl:$Oe}),P$e={kernelName:Wh,backendName:"webgl",kernelFunc:$$e};class L$e{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class V$e{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const z$e={kernelName:Hh,backendName:"webgl",kernelFunc:function B$e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{clipValueMin:o,clipValueMax:i}=r;let a;return a=V().getBool("WEBGL_PACK_CLIP")?new V$e(s.shape):new L$e(s.shape),t.runWebGLProgram(a,[s],s.dtype,[[o],[i]])}};class U$e{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function j8(e,n){return{dataId:n.dataId,dtype:n.dtype,shape:e.shape}}const H$e={kernelName:zg,backendName:"webgl",kernelFunc:function W$e(e){const{inputs:n,backend:t}=e,{x:r}=n,s=t.texData.get(r.dataId),o=new U$e(r.shape),i=[j8(r,s.complexTensorInfos.real),j8(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}};class j$e{constructor(n){this.outputShape=[],this.outputShape=ta(n,1),this.variableNames=n.map((i,a)=>`T${a}`);const t=new Array(n.length-1);t[0]=n[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+n[i][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++)r.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${t[i-1]}));`);r.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class G$e{constructor(n,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ta(n,t);const r=this.outputShape,s=r.length,o=Xt(s),i=ys("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=n.map((m,g)=>`T${g}`);const l=new Array(n.length-1);l[0]=n[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+n[m][t];const u=a[t],c=a.slice(-2),d=a.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${wS(a,u,g)}),\n            vec2(${wS(c,u,g)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${wS(a,u,p)}),\n          vec2(${wS(c,u,p)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${r[s-2]} &&\n            ${i[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function wS(e,n,t){const r=e.indexOf(n);return e.map((o,i)=>i===r?`${o} - ${t}`:o).join()}function xS(e){const{inputs:n,backend:t}=e,{input:r}=n;return to({inputs:{x:t.texData.get(r.dataId).complexTensorInfos.imag},backend:t})}const q$e={kernelName:L0,backendName:"webgl",kernelFunc:xS};function Uv(e,n,t){const r=e[0].dtype;if("complex64"===r){const f=e.map(v=>zv({inputs:{input:v},backend:t})),p=e.map(v=>xS({inputs:{input:v},backend:t})),m=Uv(f,n,t),g=Uv(p,n,t),y=gu({inputs:{real:m,imag:g},backend:t});return f.forEach(v=>t.disposeIntermediateTensorInfo(v)),p.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),y}let s=t.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const f=e.map(w=>{const I=[-1,j(w.shape.slice(n))];return ye({inputs:{x:w},backend:t,attrs:{shape:I}})}),p=f.map(w=>({vals:t.readSync(w.dataId),shape:w.shape})),m=ta(f.map(w=>w.shape),1),y=POe(p,m,r,1===f[0].shape[0]),v=ta(e.map(w=>w.shape),n),b=t.makeTensorInfo(v,r,y);return f.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}const o=e.filter(f=>j(f.shape)>0),i=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(1===o.length){const f=i?new da(e[0].shape,pu):new mu(e[0].shape,pu);return t.runWebGLProgram(f,e,r)}const a=V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const f=[];for(let m=0;m<o.length;m+=a){const g=o.slice(m,m+a);f.push(Uv(g,n,t))}const p=Uv(f,n,t);for(const m of f)t.disposeIntermediateTensorInfo(m);return p}if(i){const f=new G$e(o.map(p=>p.shape),n);return t.runWebGLProgram(f,o,r)}const{tensors2D:l,outShape:u}=function K$e(e,n,t){const r=ta(e.map(o=>o.shape),n);return{tensors2D:e.map(o=>ye({inputs:{x:o},attrs:{shape:[-1,j(o.shape.slice(n))]},backend:t})),outShape:r}}(o,n,t),c=new j$e(l.map(f=>f.shape)),d=t.runWebGLProgram(c,l,r);l.forEach(f=>t.disposeIntermediateTensorInfo(f));const h=ye({inputs:{x:d},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(d),h}function G8(e){const{inputs:n,backend:t,attrs:r}=e,{axis:s}=r,o=pt(s,n[0].shape)[0];JA(n.map(u=>u.shape),o);const a=ta(n.map(u=>u.shape),o);if(0===j(a))return t.makeTensorInfo(a,n[0].dtype,[]);const l=n.filter(u=>j(u.shape)>0);return 1===l.length?to({inputs:{x:l[0]},backend:t}):Uv(l,o,t)}const X$e={kernelName:Ug,backendName:"webgl",kernelFunc:G8};class q8{constructor(n,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const i=n.padInfo.top,a=n.padInfo.left,l=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,d=n.dilationWidth,h=n.filterHeight,f=n.filterWidth,p=4*Math.floor(n.inChannels/4),m=n.inChannels%4,g="channelsLast"===n.dataFormat,y=g?1:2,v=g?2:3,b=g?3:1;let w="",x="";r&&(w=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,x="result = activation(result);");const I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${v}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${I}\n        ${x}\n        setOutput(result);\n      }\n    `}}class Y$e{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const t=n.padInfo.front,r=n.padInfo.top,s=n.padInfo.left,o=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,c=n.dilationWidth,d=n.filterDepth,h=n.filterHeight,f=n.filterWidth,p=4*Math.floor(n.inChannels/4),m=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${i}, ${a});\n      const ivec3 pads = ivec3(${t}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class K8{constructor(n,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ts(this.outputShape.length);const i=n.padInfo.left,a=n.strideWidth,l=n.dilationWidth,u=n.filterHeight,c=n.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {\n       `;for(let g=0;g<c;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(d+1)/2;g++){const y=2*g;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<c)){const v=i%2==0?o0(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${v};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===v?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${v};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<c&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<c&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<c&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${n.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<c&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${n.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let f="",p="";r&&(f=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:o?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,p="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${p}\n         setOutput(result);\n       }\n     `}}class Z$e{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=ts(this.outputShape.length);const{dataFormat:r}=t,s=gs(),o="channelsLast"===r,i=o?1:2,a=o?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${c};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${o}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${s.output} = result;\n      }\n    `}}function CS(e,n){const t=e.length;return t>=3?n?[...e.slice(0,-3),e[t-3]*e[t-2],e[t-1]]:[...e.slice(0,-3),e[t-3],e[t-2]*e[t-1]]:!n&&1===t&&e[0]>1?[e[0],1]:null}function X8({x:e,filter:n,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const l=e.shape,u=r.texData.get(e.dataId),c=t.inChannels,d=l[0]*l[1]*l[2],h=t.outChannels,f="channelsLast"===t.dataFormat,m=!1;let g;const y=[];if(null!=o){const w=CS(o.shape,f);null!=w&&(o=ye({inputs:{x:o},backend:r,attrs:{shape:w}}),y.push(o))}if(null!=s){const w=CS(s.shape,f);null!=w&&(s=ye({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if((1!==d&&1!==h||!(c>1e3))&&u.isPacked&&f&&null!=u.texture&&l[2]%2!=0&&wt(u.shape.slice(-3),l.slice(-3))){const x={dataId:e.dataId,shape:[1,l[0]*l[1]*(l[2]+1),t.inChannels],dtype:e.dtype},I=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,S(cS(u.shape,x.shape),()=>`packed reshape ${u.shape} to ${x.shape} isn't free`);const _=ye({inputs:{x:n},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(_);const D=vS({a:x,b:_,backend:r,transposeA:!1,transposeB:m,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),N=r.texData.get(D.dataId);S(N.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=I,N.shape=t.outShape,g=to({inputs:{x:D},backend:r}),g.shape=t.outShape,y.push(D)}else{const w=t.outHeight*t.outWidth,x=ye({inputs:{x:e},backend:r,attrs:{shape:f?[t.batchSize,w,t.inChannels]:[t.batchSize,t.inChannels,w]}}),I=ye({inputs:{x:n},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),_=vS({a:f?x:I,b:f?I:x,transposeA:!f,transposeB:m,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});g=ye({inputs:{x:_},backend:r,attrs:{shape:t.outShape}}),y.push(x),y.push(I),y.push(_)}for(const w of y)r.disposeIntermediateTensorInfo(w);return g}function Y8({x:e,filter:n,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:f}=t,p="channelsLast"===f,m=l*u*c,g=h*d,y=[t.batchSize,m,g],w=[];if(null!=o){const q=CS(o.shape,p);null!=q&&(o=ye({inputs:{x:o},backend:r,attrs:{shape:q}}),w.push(o))}if(null!=s){const q=CS(s.shape,p);null!=q&&(s=ye({inputs:{x:s},backend:r,attrs:{shape:q}}),w.push(s))}const x=ye({inputs:{x:n},backend:r,attrs:{shape:[1,m,j(n.shape)/m]}});w.push(x);const I=new Z$e(y,t),D=r.runWebGLProgram(I,[e],"float32",[e.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]]),N=ye({inputs:{x:D},backend:r,attrs:{shape:y}});w.push(D),w.push(N);const T=null!=s,P=null!=o,B="leakyrelu"===a,W=a?Vv(a,!0):null,H=new R8(p?N.shape:x.shape,p?x.shape:N.shape,p?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],!0,!1,T,W,P,B),G=p?[N,x]:[x,N];if(s&&G.push(s),P&&G.push(o),B){const q=r.makeTensorInfo([],"float32",$a(i,"float32"));G.push(q),w.push(q)}const Y=r.runWebGLProgram(H,G,"float32"),Q=ye({inputs:{x:Y},backend:r,attrs:{shape:t.outShape}});w.push(Y);for(const q of w)r.disposeIntermediateTensorInfo(q);return Q}const J$e={kernelName:Wg,backendName:"webgl",kernelFunc:function Q$e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o}=n,{strides:i,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=Ua(l),h=Tr(s.shape,o.shape,i,u,a,c,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&V().getBool("WEBGL_EXP_CONV")){const m=new K8(h);f=t.runWebGLProgram(m,[s,o],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(V().getBool("WEBGL_CONV_IM2COL"))f=Y8({x:s,filter:o,convInfo:h,backend:t});else{const m=new q8(h);f=t.runWebGLProgram(m,[s,o],"float32")}else f=X8({x:s,filter:o,convInfo:h,backend:t});const p=ye({inputs:{x:f},backend:t,attrs:{shape:h.outShape}});return t.disposeIntermediateTensorInfo(f),p}};class ePe{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===n.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class tPe{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const t=n.filterHeight,r=n.filterWidth,i="channelsLast"===n.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class nPe{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${n.strideDepth} - ${n.padInfo.front};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rPe{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const t=n.filterDepth,r=n.filterHeight,s=n.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-n.padInfo.front}, ${r-1-n.padInfo.top}, ${s-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${n.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const oPe={kernelName:v0,backendName:"webgl",kernelFunc:function sPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,dy:o}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=Ua(l),h=Tr(s.shape,c,i,1,a,u,!1,d),f=new ePe(h);return t.runWebGLProgram(f,[s,o],"float32")}};class iPe{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=ts(this.outputShape.length);const t=n.filterHeight,r=n.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int wCPerm = ${r} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const lPe={kernelName:Hg,backendName:"webgl",kernelFunc:function aPe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,filter:o}=n,{inputShape:i,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=Ua(u),h=Tr(i,o.shape,a,1,l,c,!1,d);if(V().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const f=[[h.strideHeight,h.strideWidth]],p=new iPe(h);return t.runWebGLProgram(p,[s,o],"float32",f)}{const f=new tPe(h);return t.runWebGLProgram(f,[s,o],"float32")}}},cPe={kernelName:jg,backendName:"webgl",kernelFunc:function uPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=Xl(s.shape,o.shape,i,l,a),c=new Y$e(u);return t.runWebGLProgram(c,[s,o],"float32")}},hPe={kernelName:b0,backendName:"webgl",kernelFunc:function dPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,dy:o}=n,{strides:i,pad:a,filterShape:l}=r,u=Xl(s.shape,l,i,1,a),c=new nPe(u);return t.runWebGLProgram(c,[s,o],"float32")}},pPe={kernelName:w0,backendName:"webgl",kernelFunc:function fPe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,filter:o}=n,{pad:i,strides:a,inputShape:l}=r,u=Xl(l,o.shape,a,1,i),c=new rPe(u);return t.runWebGLProgram(c,[s,o],"float32")}},yPe=At({opSnippet:yp+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${nd}\n  return result;\n`}),vPe={kernelName:jh,backendName:"webgl",kernelFunc:yPe},bPe=At({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),wPe={kernelName:Gh,backendName:"webgl",kernelFunc:bPe};class xPe{constructor(n,t,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,l,u]=n,[c]=t,[d,h]=r;this.outputShape=[c,d,h,u];const f="bilinear"===s?1:0,[p,m]=[a-1+".0",l-1+".0"],[g,y,v]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,w,x]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${w};\n\n        float in_y = ${v};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const CPe={kernelName:C0,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:r}=e,{image:s,boxes:o,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:u}=r,c=new xPe(s.shape,o.shape,a,l,u);return t.runWebGLProgram(c,[s,o,i],"float32")}};var IS=function(e){return e.Prod="*",e.Sum="+",e}(IS||{});class Z8{constructor(n,t,r,s){this.op=n,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,a=r?this.op===IS.Prod?"1.0":"0.0":`getX(${Q8(o,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?"end != "+(l-1):"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${Xt(o)} coords = getOutputCoords();\n        int end = ${J8(o,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${c};\n          ${J8(o,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Q8(o,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Q8(e,n,t){if(1===e)return`${n}`;if(2===e)return`${n}.x, ${n}.y`;if(3===e)return`${n}.x, ${n}.y, ${n}.z`;if(4===e)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${t} for rank ${e} is not yet supported`)}function J8(e,n,t){if(1===e)return`${n}`;if(2===e)return`${n}.y`;if(3===e)return`${n}.z`;if(4===e)return`${n}.w`;throw new Error(`Cumulative ${t} for rank ${e} is not yet supported`)}function eK(e,n,t,r,s,o){const i=n.shape.length,a=Dn([r],i);let l=n;null!=a&&(l=vs({inputs:{x:n},backend:t,attrs:{perm:a}}));const u=Hn(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=to({inputs:{x:l},backend:t});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const f=new Z8(e,l.shape,!1,o),m=d;d=t.runWebGLProgram(f,[d],d.dtype,[[h]]),t.disposeIntermediateTensorInfo(m)}if(s){const h=new Z8(e,l.shape,s,o),f=d;d=t.runWebGLProgram(h,[d],d.dtype),t.disposeIntermediateTensorInfo(f)}if(null!=a){const f=vs({inputs:{x:d},backend:t,attrs:{perm:Ql(a)}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(l),f}return d}const SPe={kernelName:x0,backendName:"webgl",kernelFunc:function IPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return eK(IS.Prod,s,t,o,i,a)}},EPe={kernelName:Gg,backendName:"webgl",kernelFunc:function _Pe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,exclusive:i,reverse:a}=r;return eK(IS.Sum,s,t,o,i,a)}},NPe={kernelName:I0,backendName:"webgl",kernelFunc:function DPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,weights:o}=n,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const l=t.readSync(s.dataId),u=t.readSync(o.dataId),c=b8(l,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}if(2===s.shape.length){const l=t.bufferSync(s),u=t.bufferSync(o),c=MOe(l,u,i,a);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class TPe{constructor(n,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=t,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const APe={kernelName:S0,backendName:"webgl",kernelFunc:function kPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{blockSize:o,dataFormat:i}=r,a=s.shape[0],d=("NHWC"===i?s.shape[1]:s.shape[2])*o,h=("NHWC"===i?s.shape[2]:s.shape[3])*o,f=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),m=new TPe("NHWC"===i?[a,d,h,f]:[a,f,d,h],o,i);return t.runWebGLProgram(m,[s],s.dtype)}};class tK{constructor(n,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ts(this.outputShape.length);const i=n.filterHeight,a=n.filterWidth,l=n.outChannels/n.inChannels;let u="",c="";r&&(u=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,c="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${c}\n        setOutput(result);\n      }\n    `}}class nK{constructor(n,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=ts(this.outputShape.length);const i=n.outChannels/n.inChannels,a=n.padInfo.left,l=n.strideWidth,u=n.dilationWidth,c=n.filterHeight,d=n.filterWidth,h=d;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)f+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;f+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let y=0;y<d;y++)f+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const v=2*y;if(f+=`\n          xC = xCCorner + ${v*u};\n          `,1===l){if(v<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n              `,f+=1===u&&v>0?`\n                xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${v} = vec4(previous.zw, xTexelC${v}.xy);\n                  } else {\n                    xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                xC${v} = xTexelC${v};\n                `,v+1<d)){const b=a%2==0?o0(u):u;u%2==0&&a%2==1||u%2!=0&&a%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                    xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${v+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${v+1}Ready = 1;\n                  }\n                  `,f+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);\n                    } else {\n                     xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);\n                    }\n                    `:`\n                    xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);\n                    `):f+=1===b?`\n                    xC${v+1} = xTexelC${v};\n                    `:`\n                    xCOffset = xC + ${b};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                      xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${v+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${v+1}Ready = 1;\n                    }\n\n                    xC${v+1} = xTexelC${v+1};\n                    `}}else v<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {\n                  xTexelC${v+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${v+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${v+1}Ready = 1;\n                }\n\n                xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);\n              `,v+1<d&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {\n                  xTexelC${v} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${v}.zw = vec2(0.0);\n                  }\n                  xTexelC${v}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {\n                  xTexelC${v+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${v+1}.zw = vec2(0.);\n                  }\n                  xTexelC${v+1}Ready = 1;\n                }\n\n                xC${v} = vec4(\n                  xTexelC${v}.xy, xTexelC${v+1}.xy);\n              `,v+1<d&&(f+=`\n                  xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);\n                `)));v<d&&(f+=`\n            wTexel = getW(r, ${v}, d1, q);\n            dotProd += xC${v} * vec4(wTexel.xz, wTexel.xz);\n          `,v+1<d&&(f+=`\n              wTexel = getW(r, ${v+1}, d1, q);\n              dotProd += xC${v+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let p="",m="";r&&(p=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:o?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const MPe={kernelName:qg,backendName:"webgl",kernelFunc:function RPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),S(Br(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Tr(s.shape,o.shape,i,c,a,u,!0);let h;return h=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new nK(d):new tK(d),t.runWebGLProgram(h,[s,o],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class OPe{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${n.outChannels/n.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${n.strideHeight} - ${n.padInfo.top};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${n.strideWidth} - ${n.padInfo.left};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FPe{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const t=n.filterHeight,r=n.filterWidth,l=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-n.padInfo.top}, ${r-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const PPe={kernelName:_0,backendName:"webgl",kernelFunc:function $Pe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,dy:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,d=Tr(s.shape,c,i,a,l,u,!0),h=new OPe(d);return t.runWebGLProgram(h,[s,o],"float32")}},VPe={kernelName:E0,backendName:"webgl",kernelFunc:function LPe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,filter:o}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,d=Tr(c,o.shape,i,a,l,u,!0),h=new FPe(d);return t.runWebGLProgram(h,[s,o],"float32")}};class BPe{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const UPe={kernelName:D0,backendName:"webgl",kernelFunc:function zPe(e){const{inputs:n,backend:t}=e,{x:r}=n,s=[...r.shape,...r.shape],o=j(r.shape),i=ye({inputs:{x:r},backend:t,attrs:{shape:[o]}}),a=new BPe(o),l=t.runWebGLProgram(a,[i],i.dtype),u=ye({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),u}};class WPe{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=n,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${i});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const jPe={kernelName:Kg,backendName:"webgl",kernelFunc:function HPe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o}=n,{strides:i,pad:a,dilations:l}=r,u=Yy(s.shape,o.shape,i,a,"NHWC",l);let c;const d=new WPe(u);c=t.runWebGLProgram(d,[s,o],"float32");const h=ye({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),h}},qPe={kernelName:A0,backendName:"webgl",kernelFunc:function GPe(e){const{inputs:n,backend:t,attrs:r}=e,{equation:s}=r,o=n,{allDims:i,summedDims:a,idDims:l}=hR(s,o.length);pR(i.length,l,o);const{path:u,steps:c}=mR(a,l),d=c.length;let h=null,f=i.length;const p=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:v}=fR(f,l[g]);let b;gR(y)?b=o[g]:(b=vs({inputs:{x:o[g]},backend:t,attrs:{perm:y}}),p.push(b));const w=b.shape.slice();for(let x=0;x<v.length;++x)w.splice(v[x],0,1);wt(b.shape,w)||(b=ye({inputs:{x:b},backend:t,attrs:{shape:w}}),p.push(b)),null===h?h=b:(h=ZM({inputs:{a:b,b:h},backend:t}),p.push(h))}m<d-1&&(u[m]>=0&&(h=yS({inputs:{x:h},backend:t,attrs:{axis:u[m]-(i.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&t.disposeIntermediateTensorInfo(m);return h}},KPe=At({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),XPe={kernelName:Kh,backendName:"webgl",kernelFunc:KPe},QPe={kernelName:R0,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t}=e,{dy:r,y:s}=n,o=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new gp("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new td("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return t.runWebGLProgram(o,[r,s],r.dtype)}},JPe=jr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:LOe}),eLe={kernelName:Xg,backendName:"webgl",kernelFunc:JPe},nLe=At({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${sR};\n  float a1 = ${oR};\n  float a2 = ${iR};\n  float a3 = ${aR};\n  float a4 = ${lR};\n  float a5 = ${uR};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),rLe={kernelName:Xh,backendName:"webgl",kernelFunc:nLe},rK=At({opSnippet:yp+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:VOe,dtype:"float32"}),oLe={kernelName:Yh,backendName:"webgl",kernelFunc:rK};function tO(e){const{inputs:n,attrs:t,backend:r}=e,{dim:s}=t,{input:o}=n,i=o.shape.length,a=o.shape.slice();let l=s;return s<0&&(S(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),ye({inputs:{x:o},backend:r,attrs:{shape:a}})}const iLe={kernelName:Yg,backendName:"webgl",kernelFunc:tO},sK="return exp(x) - 1.0;",aLe=At({opSnippet:sK,packedOpSnippet:sK,cpuKernelImpl:BOe}),lLe={kernelName:Zh,backendName:"webgl",kernelFunc:aLe};class oK{constructor(n,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let a;if("real"===n)a="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function iK(e,n,t){const r=t.texData.get(e.dataId),s=j(e.shape),o=e.shape[e.shape.length-1],a=ye({inputs:{x:e},backend:t,attrs:{shape:[s/o,o]}}),l=a.shape,u=new oK("real",l,n),c=new oK("imag",l,n),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=t.runWebGLProgram(u,d,"float32"),f=t.runWebGLProgram(c,d,"float32"),p=gu({inputs:{real:h,imag:f},backend:t});t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f);const m=ye({inputs:{x:p},backend:t,attrs:{shape:e.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(p),m}const cLe={kernelName:M0,backendName:"webgl",kernelFunc:function uLe(e){const{inputs:n,backend:t}=e,{input:r}=n;return iK(r,!1,t)}};class dLe{constructor(n,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Wv(e){const{backend:n,attrs:t}=e,{shape:r,value:s}=t;let{dtype:o}=t;if(o=o||xc(s),"string"===o){const i=On(o,j(r));return i.fill(s),n.makeTensorInfo(r,o,i)}{const i=new dLe(r,s);return n.runWebGLProgram(i,[],o,[[s]])}}const hLe={kernelName:O0,backendName:"webgl",kernelFunc:Wv};class fLe{constructor(n){this.variableNames=["Image"],this.outputShape=[];const t=n[2];this.outputShape=n,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const pLe={kernelName:F0,backendName:"webgl",kernelFunc:({inputs:e,backend:n})=>{const{image:t}=e,r=n,s=new fLe(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}},aK="return floor(x);",mLe=At({opSnippet:aK,packedOpSnippet:aK,cpuKernelImpl:zOe}),gLe={kernelName:Qh,backendName:"webgl",kernelFunc:mLe},yLe=jr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),vLe={kernelName:Jh,backendName:"webgl",kernelFunc:yLe};class bLe{constructor(n){this.variableNames=["A"];const t=gs(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class wLe{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=gs(),[r,s]=n;this.outputShape=n,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const xLe={kernelName:yC,backendName:"webgl",kernelFunc:function CLe(e){const{inputs:n,backend:t,attrs:r}=e;let{pixels:s}=n;const{numChannels:o}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,o];if(a||i){const m=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==bp||m!==nO)&&(nO=m,bp=document.createElement("canvas").getContext("2d",{willReadFrequently:nO})),bp.canvas.width=l,bp.canvas.height=u,bp.drawImage(s,0,0,l,u),s=bp.canvas}const h=t.makeTensorInfo(c,"int32");t.texData.get(h.dataId).usage=Yo.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(h.dataId),s);const f=V().getBool("WEBGL_PACK")?new wLe(d):new bLe(d),p=t.runWebGLProgram(f,[h],"int32");return t.disposeData(h.dataId),p}};let bp,nO=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const SLe={kernelName:$y,backendName:"webgl",kernelFunc:function ILe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,m=Ua(c),g=Tr(s.shape,o.shape,l,d,u,h,!1,m);let y;const v=[],b=null!=i,w=null!=a,x="leakyrelu"===f,I=()=>{const D=[s,o],N=(T,P)=>{if("NCHW"===P&&1===T.shape.length&&1!==T.shape[0]){const B=ye({inputs:{x:T},backend:t,attrs:{shape:[T.shape[0],1,1]}});return v.push(B),B}return T};if(b&&D.push(N(i,c)),w&&D.push(N(a,c)),x){const T=t.makeTensorInfo([],"float32",$a(p,"float32"));D.push(T),v.push(T)}return D};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&V().getBool("WEBGL_EXP_CONV")){const D=f?Vv(f,!0):null,N=new K8(g,b,D,w,x),T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],P=I();y=t.runWebGLProgram(N,P,"float32",T)}else if(V().getBool("WEBGL_CONV_IM2COL"))y=Y8({x:s,filter:o,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const D=f?Vv(f,!1):null,N=new q8(g,b,D,w,x),T=I();y=t.runWebGLProgram(N,T,"float32")}else y=X8({x:s,filter:o,convInfo:g,backend:t,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const _=ye({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return v.push(y),v.forEach(D=>t.disposeIntermediateTensorInfo(D)),_}},ELe={kernelName:Py,backendName:"webgl",kernelFunc:function _Le(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=n,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let m=c;null==m&&(m=[1,1]),S(Br(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Tr(s.shape,o.shape,l,m,u,d,!0),y=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,v=h?Vv(h,y):null,b=[s,o],w=null!=i,x=null!=a,I="leakyrelu"===h;if(w&&b.push(i),x&&b.push(a),I){const T=t.makeTensorInfo([],"float32",$a(f,"float32"));b.push(T),p.push(T)}let _;_=y?new nK(g,w,v,x,I):new tK(g,w,v,x,I);const N=t.runWebGLProgram(_,b,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return p.forEach(T=>t.disposeIntermediateTensorInfo(T)),N}};class DLe{constructor(n,t,r,s){this.sliceDim=n,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const o=Xt(r.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${o} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const TLe={kernelName:$0,backendName:"webgl",kernelFunc:function NLe(e){const{inputs:n,backend:t}=e,{params:r,indices:s}=n,o=s.shape,i=o[o.length-1],a=j(r.shape),[l,u,c,d]=RC(r,s),h=ye({inputs:{x:s},backend:t,attrs:{shape:[u,i]}}),f=ye({inputs:{x:r},backend:t,attrs:{shape:[j(r.shape)/c,c]}});if(t.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=t.readSync(s.dataId),v=t.bufferSync(r),b=UOe(y,v,r.dtype,u,i,c,d,r.shape,a);return t.makeTensorInfo(l,r.dtype,b.values)}const p=new DLe(i,d,[u,c],r.shape),m=t.runWebGLProgram(p,[f,h],f.dtype),g=ye({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}};class kLe{constructor(n,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Xt(this.rank),s=function ALe(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)r.push(2===s?"index":`${t[s]}`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function lK(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,indices:o}=n,{axis:i,batchDims:a}=r,l=pt(i,s.shape)[0];if(V().get("DEBUG")){const v=t.readSync(o.dataId),b=s.shape[l];for(let w=0;w<v.length;++w){const x=v[w];S(x<=b-1&&x>=0,()=>`GatherV2: the index value ${x} is not in [0, ${b-1}]`)}}const u=bR(s,o,l,a),c=j(o.shape),d=[],h=ye({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=ye({inputs:{x:o},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(f);const p=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const v=t.bufferSync(f),b=t.bufferSync(h),w=WOe(b,v,p);return d.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(u.outputShape,w.dtype,w.values)}const m=new kLe(h.shape,p),g=t.runWebGLProgram(m,[h,f],h.dtype);d.push(g);const y=ye({inputs:{x:g},backend:t,attrs:{shape:u.outputShape}});return d.forEach(v=>t.disposeIntermediateTensorInfo(v)),y}const RLe={kernelName:Qg,backendName:"webgl",kernelFunc:lK},MLe=jr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:HOe,dtype:"bool"}),OLe={kernelName:Jg,backendName:"webgl",kernelFunc:MLe},FLe=jr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:jOe}),$Le={kernelName:ef,backendName:"webgl",kernelFunc:FLe},LLe={kernelName:P0,backendName:"webgl",kernelFunc:function PLe(e){const{inputs:n,backend:t}=e,{input:r}=n;return iK(r,!0,t)}},VLe=At({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),BLe={kernelName:rf,backendName:"webgl",kernelFunc:VLe},zLe=At({opSnippet:"return float(isinf(x));",dtype:"bool"}),ULe={kernelName:sf,backendName:"webgl",kernelFunc:zLe},WLe=At({opSnippet:"return float(isnan(x));",dtype:"bool"}),HLe={kernelName:af,backendName:"webgl",kernelFunc:WLe},jLe=jr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:GOe,dtype:"bool"}),GLe={kernelName:ty,backendName:"webgl",kernelFunc:jLe},qLe=jr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:qOe,dtype:"bool"}),KLe={kernelName:ny,backendName:"webgl",kernelFunc:qLe},YLe={kernelName:V0,backendName:"webgl",kernelFunc:function XLe(e){const{backend:n,attrs:t}=e,{start:r,stop:s,num:o}=t,i=KOe(r,s,o);return n.makeTensorInfo([i.length],"float32",i)}},QLe=At({opSnippet:yp+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:XOe}),JLe={kernelName:lf,backendName:"webgl",kernelFunc:QLe},tVe=At({opSnippet:yp+"\n  return log(1.0 + x);\n"}),nVe={kernelName:uf,backendName:"webgl",kernelFunc:tVe},rVe=jr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),sVe={kernelName:ry,backendName:"webgl",kernelFunc:rVe},oVe=At({opSnippet:"return float(!(x >= 1.0));"}),iVe={kernelName:sy,backendName:"webgl",kernelFunc:oVe},aVe=jr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),lVe={kernelName:oy,backendName:"webgl",kernelFunc:aVe};class uVe{constructor(n,t,r,s,o){this.variableNames=["x"],this.outputShape=[];const i=t,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class cVe{constructor(n,t,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=n[3]-1;let l;this.outputShape=n;const u=`float(${r}) + float(${s}) * sum`;l=.5===o?`inversesqrt(${u})`:1===o?`1.0/(${u})`:`exp(log(${u}) * float(-${o}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const dVe={kernelName:iy,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{depthRadius:o,bias:i,alpha:a,beta:l}=r,u=V().getBool("WEBGL_PACK_NORMALIZATION")?new cVe(s.shape,o,i,a,l):new uVe(s.shape,o,i,a,l);return t.runWebGLProgram(u,[s],s.dtype)}};class hVe{constructor(n,t,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const fVe={kernelName:B0,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:r}=e,{x:s,y:o,dy:i}=n,{depthRadius:a,bias:l,alpha:u,beta:c}=r,d=new hVe(s.shape,a,l,u,c);return t.runWebGLProgram(d,[s,o,i],s.dtype)}};function uK(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,l=pt(o,s.shape);let u=l;const c=Dn(u,a),d=null!=c,h=t.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const b=t.texData.get(f.dataId).values,w=new Array(a);for(let _=0;_<w.length;_++)w[_]=s.shape[c[_]];const x=XM(b,s.shape,s.dtype,c,w);f=t.makeTensorInfo(w,s.dtype),t.texData.get(f.dataId).values=x}else f=gS(s,c,t);u=Hn(u.length,a)}Ur("max",u,a);const[p,m]=kr(f.shape,u);let y,g=p;if(i&&(g=Wn(p,l)),h){const b=t.texData.get(f.dataId).values,w=YOe(b,j(m),g,s.dtype);y=t.makeTensorInfo(g,s.dtype),t.texData.get(y.dataId).values=w}else y=function pVe(e,n,t,r){const s=j(n),a=ye({inputs:{x:e},attrs:{shape:[j(e.shape)/s,s]},backend:r}),l=rd(a,e.dtype,"max",r),u=ye({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(f,m,g,t);return d&&t.disposeIntermediateTensorInfo(f),y}const mVe={kernelName:ay,backendName:"webgl",kernelFunc:uK},vVe=jr({opSnippet:YM+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nd+"\n  return result;\n",cpuKernelImpl:ZOe}),bVe={kernelName:cf,backendName:"webgl",kernelFunc:vVe},xVe={kernelName:ly,backendName:"webgl",kernelFunc:function wVe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n;Pv(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=r;S(Br(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const c=Wo(s.shape,o,i,1,a,l);if(1===c.filterWidth&&1===c.filterHeight&&wt(c.inShape,c.outShape))return to({inputs:{x:s},backend:t});const d=new Bv(c,"max",!1);return t.runWebGLProgram(d,[s],s.dtype)}},IVe={kernelName:uy,backendName:"webgl",kernelFunc:function CVe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{filterSize:o,strides:i,pad:a,dataFormat:l,dimRoundingMode:u}=r,d=za(s.shape,o,i,[1,1,1],a,u,l),h=new QM(d,"max",!1);return t.runWebGLProgram(h,[s],s.dtype)}};class SVe{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const o=n.effectiveFilterHeight,i=n.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${o-1-n.padInfo.top}, ${i-1-n.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n          wR += ${n.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${o*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _Ve{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const l=n.effectiveFilterDepth,u=n.effectiveFilterHeight,c=n.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-n.padInfo.front}, ${u-1-n.padInfo.top}, ${c-1-n.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${n.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${n.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${n.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${n.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${n.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${n.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const DVe={kernelName:U0,backendName:"webgl",kernelFunc:function EVe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o}=n,i=o,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=za(i.shape,a,l,[1,1,1],u,c),f=new QM(h,"max",!0),p=t.runWebGLProgram(f,[i],i.dtype),m=new _Ve(h),g=t.runWebGLProgram(m,[s,p],i.dtype);return t.disposeIntermediateTensorInfo(p),g}},TVe={kernelName:z0,backendName:"webgl",kernelFunc:function NVe(e){const{inputs:n,backend:t,attrs:r}=e,{dy:s,input:o,output:i}=n,a=o;Pv([o,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Wo(a.shape,l,u,1,c,d),p=new Bv(h,"max",!0),m=t.runWebGLProgram(p,[a],a.dtype),g=new SVe(h),y=t.runWebGLProgram(g,[s,m],a.dtype);return t.disposeIntermediateTensorInfo(m),y}},AVe={kernelName:W0,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{x:r}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=n,l=t;S(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];S(Br(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=Wo(r.shape,s,o,u,i),[d,h]=function kVe(e,n,t,r){let s=new Bv(t,"max",!1);const o=r.runWebGLProgram(s,[e],"float32");return s=new Bv(t,"max",!0,!0,n),[o,r.runWebGLProgram(s,[e],"float32")]}(r,a,c,l);return[d,h]}},MVe={kernelName:cy,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{x:r}=e,{keepDims:s,axis:o}=n,i=t,a=r.shape.length,l=pt(o,r.shape);let u=l;const c=Dn(u,a),d=null!=c,h=i.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const w=i.texData.get(p.dataId).values,x=new Array(a);for(let D=0;D<x.length;D++)x[D]=r.shape[c[D]];const I=XM(w,r.shape,r.dtype,c,x);p=i.makeTensorInfo(x,r.dtype),i.texData.get(p.dataId).values=I}else p=gS(r,c,i);f.push(p),u=Hn(u.length,a)}Ur("sum",u,a);const[m,g]=kr(p.shape,u);let y=m;s&&(y=Wn(m,l));const v=function RVe(e,n,t,r){const s=j(n),a=ye({inputs:{x:e},attrs:{shape:[j(e.shape)/s,s]},backend:r}),l=rd(a,"float32","mean",r),u=ye({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}(p,g,y,i);for(const b of f)i.disposeIntermediateTensorInfo(b);return v}},FVe={kernelName:dy,backendName:"webgl",kernelFunc:function OVe(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=pt(o,s.shape);let u=l;const c=Dn(u,a);let d=s;null!=c&&(d=vs({inputs:{x:s},backend:t,attrs:{perm:c}}),u=Hn(u.length,s.shape.length)),Ur("min",u,a);const[h,f]=kr(d.shape,u),m=ye({inputs:{x:d},backend:t,attrs:{shape:[-1,j(f)]}}),g=rd(m,m.dtype,"min",t);let y;return y=ye(i?{inputs:{x:g},backend:t,attrs:{shape:Wn(h,l)}}:{inputs:{x:g},backend:t,attrs:{shape:h}}),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),null!=c&&t.disposeIntermediateTensorInfo(d),y}},LVe=jr({opSnippet:YM+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nd+"\n  return result;\n",cpuKernelImpl:QOe}),VVe={kernelName:df,backendName:"webgl",kernelFunc:LVe};class BVe{constructor(n,t,r){this.variableNames=["x"],this.outputShape=t.map((c,d)=>c[0]+n[d]+c[1]);const s=n.length,o=Xt(s),i=t.map(c=>c[0]).join(","),a=t.map((c,d)=>c[0]+n[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u="reflect"===r?0:1;this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${o} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class zVe{constructor(n,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,m)=>p[0]+n[m]+p[1]);const s=n.length,o=Xt(s),i=t.map(p=>p[0]).join(","),a=t.map((p,m)=>p[0]+n[m]).join(","),l=ys("rc",s),u=ys("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${o} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const p=`\n        ${o} source = rc;\n        ${o} lt = ${o}(lessThan(source, start));\n        ${o} gte = ${o}(greaterThanEqual(source, end));\n        ${o} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${o} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${c}) {\n          ${p}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${c}) {\n            ${p}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const UVe={kernelName:hy,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:r}=e,{paddings:s,mode:o}=t,i=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zVe(r.shape,s,o):new BVe(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},jVe=jr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+nd+"\n  return result;\n"}),GVe={kernelName:hf,backendName:"webgl",kernelFunc:jVe};class qVe{constructor(n,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const cK=jr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),KVe={kernelName:qh,backendName:"webgl",kernelFunc:cK},dK="return a - b;",hK=jr({opSnippet:dK,packedOpSnippet:dK,supportsComplex:!0,cpuKernelImpl:b2e}),XVe={kernelName:Nf,backendName:"webgl",kernelFunc:hK};function fK(e){const{inputs:n,backend:t,attrs:r}=e,{logits:s}=n,{dim:o}=r,i=pt([o],s.shape),a=uK({inputs:{x:s},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),l=Wn(a.shape,i),u=ye({inputs:{x:a},backend:t,attrs:{shape:l}}),c=hK({inputs:{a:s,b:u},backend:t}),d=rK({inputs:{x:c},backend:t}),h=yS({inputs:{x:d},backend:t,attrs:{axis:i,keepDims:!1}}),f=ye({inputs:{x:h},backend:t,attrs:{shape:l}}),p=cK({inputs:{a:d,b:f},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),p}const YVe={kernelName:ky,backendName:"webgl",kernelFunc:fK},QVe={kernelName:H0,backendName:"webgl",kernelFunc:function ZVe(e){const{inputs:n,backend:t,attrs:r}=e,{logits:s}=n,{numSamples:o,seed:i,normalized:a}=r,l=a?s:fK({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),d=new qVe(l.shape[0],l.shape[1],o),f=t.runWebGLProgram(d,[l],"int32",[[i]]);return a||t.disposeIntermediateTensorInfo(l),f}},JVe=To+"\n  return -x;\n",nBe={kernelName:fy,backendName:"webgl",kernelFunc:function tBe(e){const{inputs:n,backend:t}=e,{x:r}=n;if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId),[i,a]=e2e(o.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,i)}let s;return s=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new mu(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new da(r.shape,JVe),t.runWebGLProgram(s,[r],r.dtype)}},rBe=hI,oBe={kernelName:j0,backendName:"webgl",kernelFunc:function sBe(e){yo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:r}=e,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,u=t.readSync(s.dataId),c=t.readSync(o.dataId),{selectedIndices:d}=rBe(u,c,i,a,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}},iBe=fI,lBe={kernelName:G0,backendName:"webgl",kernelFunc:function aBe(e){yo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:r}=e,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=t.readSync(s.dataId),d=t.readSync(o.dataId),{selectedIndices:h,validOutputs:f}=iBe(c,d,i,a,l,u);return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}},uBe=pI,dBe={kernelName:q0,backendName:"webgl",kernelFunc:function cBe(e){yo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:n,backend:t,attrs:r}=e,{boxes:s,scores:o}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=t.readSync(s.dataId),d=t.readSync(o.dataId),h=i,f=a,p=l,m=u,{selectedIndices:g,selectedScores:y}=uBe(c,d,h,f,p,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class hBe{constructor(n,t,r,s){this.variableNames=["indices"],this.outputShape=[n,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const fBe={kernelName:gy,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:r}=e,{indices:s}=n,{dtype:o,depth:i,onValue:a,offValue:l}=r,u=j(s.shape),c=new hBe(u,i,a,l),d=ye({inputs:{x:s},backend:t,attrs:{shape:[u]}}),h=t.runWebGLProgram(c,[d],o);t.disposeIntermediateTensorInfo(d);const p=ye({inputs:{x:h},backend:t,attrs:{shape:[...s.shape,i]}});return t.disposeIntermediateTensorInfo(h),p}};function SS(e){const{inputs:n,backend:t}=e,{x:r}=n;if("complex64"===r.dtype){const s=zv({inputs:{input:r},backend:t}),o=SS({inputs:{x:s},backend:t}),i=xS({inputs:{input:r},backend:t}),a=SS({inputs:{x:i},backend:t}),l=gu({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}return Wv({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:t})}const pBe={kernelName:Oy,backendName:"webgl",kernelFunc:SS},mBe={kernelName:my,backendName:"webgl",kernelFunc:function pK(e){const{inputs:n,backend:t}=e,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=zv({inputs:{input:r},backend:t}),o=pK({inputs:{x:s},backend:t}),i=xS({inputs:{input:r},backend:t}),a=SS({inputs:{x:i},backend:t}),l=gu({inputs:{real:o,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),l}return Wv({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}},yBe={kernelName:yy,backendName:"webgl",kernelFunc:function gBe(e){const{inputs:n,backend:t,attrs:r}=e,{axis:s}=r;if(1===n.length)return tO({inputs:{input:n[0]},backend:t,attrs:{dim:s}});const o=n[0].shape,i=n[0].dtype;n.forEach(c=>{Pr(o,c.shape,"All tensors passed to stack must have matching shapes"),S(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=G8({inputs:n.map(c=>{const d=tO({inputs:{input:c},backend:t,attrs:{dim:s}});return a.push(d),d}),backend:t,attrs:{axis:s}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}};class vBe{constructor(n,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+n[c]+u[1]);const s=n.length,o=Xt(s),i=t.map(u=>u[0]).join(","),a=t.map((u,c)=>u[0]+n[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${o} start = ${o}(${i});\n      ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${o} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class bBe{constructor(n,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+n[g]+m[1]);const s=n.length,o=Xt(s),i=t.map(m=>m[0]).join(","),a=t.map((m,g)=>m[0]+n[g]).join(","),l=ys("rc",s),u=ys("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${u.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${c}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${c}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=1===s?2:4;m<g;m++)p+=`\n        ${h[m]}\n        if (${f}) {\n          result[${m}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${m}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${i});\n      const ${o} end = ${o}(${a});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const mK=e=>{const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{paddings:o,constantValue:i}=r;if(0===j(s.shape))return Wv({backend:t,attrs:{shape:o.map((c,d)=>c[0]+s.shape[d]+c[1]),value:i,dtype:s.dtype}});const a=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bBe(s.shape,o,i):new vBe(s.shape,o,i);return t.runWebGLProgram(a,[s],s.dtype,[[i]])},wBe={kernelName:vy,backendName:"webgl",kernelFunc:mK},IBe=jr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+nd+"\n  return result;\n"}),SBe={kernelName:pf,backendName:"webgl",kernelFunc:IBe},EBe={kernelName:wy,backendName:"webgl",kernelFunc:function _Be(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{axis:o,keepDims:i}=r,a=s.shape.length,l=[],u=pt(o,s.shape);let c=u;const d=Dn(c,a);let f,h=s;if(null!=d&&(h=vs({inputs:{x:s},backend:t,attrs:{perm:d}}),c=Hn(c.length,a),l.push(h)),Ur("prod",c,a),t.shouldExecuteOnCPU([h])){const p=t.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=n2e(h.shape,h.dtype,p,c);f=t.makeTensorInfo(g,y,m)}else{const[p,m]=kr(h.shape,c),g=j(m),y=ye({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}}),b=rd(y,IC(s.dtype),"prod",t);f=ye({inputs:{x:b},backend:t,attrs:{shape:p}}),l.push(y),l.push(b)}if(i){l.push(f);const p=Wn(f.shape,u);f=ye({inputs:{x:f},backend:t,attrs:{shape:p}})}return l.forEach(p=>t.disposeIntermediateTensorInfo(p)),f}},NBe={kernelName:K0,backendName:"webgl",kernelFunc:function DBe(e){const{inputs:n,backend:t,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=n,{outputRaggedRank:a}=r,l=s.map(y=>t.readSync(y.dataId)),u=s.map(y=>y.shape),c=t.readSync(o.dataId),d=t.readSync(i.dataId),[h,f,p]=r2e(l,u,c,o.shape,o.dtype,d,i.shape,a),m=h.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(p,o.dtype,f);return m.concat([g])}},kBe={kernelName:X0,backendName:"webgl",kernelFunc:function TBe(e){const{inputs:n,backend:t}=e,{starts:r,limits:s,deltas:o}=n,i=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(o.dataId),[u,c]=s2e(i,r.shape,r.dtype,a,s.shape,l,o.shape);return[t.makeTensorInfo([u.length],"int32",u),t.makeTensorInfo([c.length],r.dtype,c)]}},RBe={kernelName:Y0,backendName:"webgl",kernelFunc:function ABe(e){const{inputs:n,backend:t,attrs:r}=e,{shape:s,values:o,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,u=t.readSync(s.dataId),c=t.readSync(o.dataId),d=t.readSync(i.dataId),h=a.map(g=>t.readSync(g.dataId)),f=a.map(g=>g.shape),[p,m]=o2e(u,s.shape,c,o.shape,o.dtype,d,i.shape,h,f,l);return t.makeTensorInfo(p,o.dtype,m)}},gK=e=>{const{backend:n,attrs:t}=e,{start:r,stop:s,step:o,dtype:i}=t,a=i2e(r,s,o,i);return n.makeTensorInfo([a.length],i,a)},MBe={kernelName:Z0,backendName:"webgl",kernelFunc:gK},OBe=At({opSnippet:"return 1.0 / x;"}),FBe={kernelName:mf,backendName:"webgl",kernelFunc:OBe},PBe=At({opSnippet:To+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),LBe={kernelName:gf,backendName:"webgl",kernelFunc:PBe},BBe=At({opSnippet:To+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),zBe={kernelName:yf,backendName:"webgl",kernelFunc:BBe};class UBe{constructor(n,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],d=[s&&t>1?t-1:t,s&&r>1?r-1:r];let h;h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class WBe{constructor(n,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],d=[s&&t>1?t-1:t,s&&r>1?r-1:r];let h;h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const jBe={kernelName:Iy,backendName:"webgl",kernelFunc:function HBe(e){const{inputs:n,backend:t,attrs:r}=e,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new WBe(s.shape,l,u,o,i):new UBe(s.shape,l,u,o,i);return t.runWebGLProgram(c,[s],"float32")}};class GBe{constructor(n,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const KBe={kernelName:eC,backendName:"webgl",kernelFunc:function qBe(e){const{inputs:n,backend:t,attrs:r}=e,{images:s,dy:o}=n,{alignCorners:i}=r,a=new GBe(o.shape,s.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}};class XBe{constructor(n,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],d=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;f=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class YBe{constructor(n,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,l,u]=n;this.outputShape=[i,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],d=[s&&t>1?t-1:t,s&&r>1?r-1:r];let f;f=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const QBe={kernelName:Cy,backendName:"webgl",kernelFunc:function ZBe(e){const{inputs:n,backend:t,attrs:r}=e,{images:s}=n,{alignCorners:o,halfPixelCenters:i,size:a}=r,[l,u]=a,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new YBe(s.shape,l,u,o,i):new XBe(s.shape,l,u,o,i);return t.runWebGLProgram(c,[s],s.dtype)}};class JBe{constructor(n,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,i,a]=n,l=[r&&i>1?s-1:s,r&&a>1?o-1:o],u=[r&&i>1?i-1:i,r&&a>1?a-1:a],c=l[0]/u[0],d=l[1]/u[1],h=1/c,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${o}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const t3e={kernelName:J0,backendName:"webgl",kernelFunc:function e3e(e){const{inputs:n,backend:t,attrs:r}=e,{images:s,dy:o}=n,{alignCorners:i}=r,a=new JBe(o.shape,s.shape,i);return t.runWebGLProgram(a,[o],o.dtype)}};class n3e{constructor(n,t){this.variableNames=["x"];const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const o=n.map((a,l)=>(a=>-1!==t.indexOf(a)&&1!==n[a]?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),i=Xt(r);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}class r3e{constructor(n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;const s=ys("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Xt(r);function h(p){const m=n.map((v,b)=>function f(p,m){return-1!==t.indexOf(p)&&1!==n[p]?`${n[p]} - ${m[p]} - 1`:`${m[p]}`}(b,p));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${o}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${o}){\n            result.g = ${function u(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function c(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${o}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const o3e={kernelName:Sy,backendName:"webgl",kernelFunc:function s3e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{dims:o}=r,i=s.shape.length,a=pt(o,s.shape);if(0===i)return to({inputs:{x:s},backend:t});const l=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new r3e(s.shape,a):new n3e(s.shape,a);return t.runWebGLProgram(l,[s],s.dtype)}};class i3e{constructor(n,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=n[1],s=n[2];this.outputShape=n;let o="";o="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${o}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const a3e={kernelName:vC,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{image:r}=e,{radians:s,fillValue:o,center:i}=n,a=t,l=new i3e(r.shape,o),[u,c]=tR(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},l3e=At({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),u3e={kernelName:vf,backendName:"webgl",kernelFunc:l3e},c3e=At({opSnippet:"return inversesqrt(x);",cpuKernelImpl:a2e}),d3e={kernelName:bf,backendName:"webgl",kernelFunc:c3e};class rO{constructor(n,t,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Xt(o.length),c=Xt(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let f="";1===s?f="i":2===s&&(f="i, coords[1]");let m="";l&&(m="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${f});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${m}), sum, float(found)));\n        }\n      `}}class h3e{constructor(n,t,r,s,o,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Xt(o.length),c=Xt(i.length);let d="";1===r?d="i":2===r&&(d="i, j");let f="";1===s?f="i":2===s&&(f="i, coords[1]");let m="";l&&(m="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${o});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(getIndices(${d}));\n              flattenedIndex += index.xz * ${t>1?"strides[j]":"strides"};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${t>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${f});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${m}), sum, found));\n        }\n      `}}const p3e={kernelName:tC,backendName:"webgl",kernelFunc:function f3e(e){const{inputs:n,backend:t,attrs:r}=e,{indices:s,updates:o}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ql(0,s,i),h=[d/u,u];if(0===d)return t.makeTensorInfo(i,s.dtype);const f=ye({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),p=ye({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=V().getBool("WEBGL_PACK")?new h3e(l,a,f.shape.length,p.shape.length,c,h):new rO(l,a,f.shape.length,p.shape.length,c,h);const y=t.runWebGLProgram(g,[p,f,m],p.dtype),v=ye({inputs:{x:y},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),v}};class m3e{constructor(n,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===V().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const y3e={kernelName:rC,backendName:"webgl",kernelFunc:function g3e(e){const{inputs:n,backend:t,attrs:r}=e,{sortedSequence:s,values:o}=n,{side:i}=r,a=new m3e(s.shape[0],s.shape[1],o.shape[1],i);return t.runWebGLProgram(a,[s,o],"int32",[[s.shape[1]]])}};class v3e{constructor(n,t,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=t,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)o="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${a[c]}`),c<n&&l.push(`${a[c]}`);s=l.join(),o=u.join()}const i=Xt(r);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}const w3e={kernelName:_y,backendName:"webgl",kernelFunc:function b3e(e){const{inputs:n,backend:t}=e,{condition:r,t:s,e:o}=n,i=new v3e(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(i,[r,s,o],Ts(s.dtype,o.dtype))}},C3e=At({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${gI};\n  float scale = ${yI};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),I3e={kernelName:wf,backendName:"webgl",kernelFunc:C3e},_3e=At({opSnippet:yp+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:u2e}),E3e={kernelName:Sf,backendName:"webgl",kernelFunc:_3e},D3e=At({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),N3e={kernelName:If,backendName:"webgl",kernelFunc:D3e},A3e=At({opSnippet:yp+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${nd}\n  return result;\n`}),R3e={kernelName:xf,backendName:"webgl",kernelFunc:A3e},M3e=At({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),O3e={kernelName:Cf,backendName:"webgl",kernelFunc:M3e},F3e=At({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),$3e={kernelName:_f,backendName:"webgl",kernelFunc:F3e},P3e={kernelName:Ny,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{blockShape:o,paddings:i}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((y,v)=>y*v),l=[[0,0]];l.push(...i);for(let y=1+o.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=mK({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),d=gv(c.shape,o,a,!1),h=yv(d.length,o.length,!1),f=vv(c.shape,o,a,!1),p=ye({inputs:{x:c},backend:t,attrs:{shape:d}}),m=vs({inputs:{x:p},backend:t,attrs:{perm:h}}),g=ye({inputs:{x:m},backend:t,attrs:{shape:f}});return u.push(c),u.push(p),u.push(m),u.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}},V3e={kernelName:sC,backendName:"webgl",kernelFunc:function L3e(e){const{inputs:n,backend:t}=e,{indices:r,values:s,denseShape:o,defaultValue:i}=n;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=t.readSync(r.dataId),l=t.readSync(s.dataId),u=t.readSync(o.dataId),c=t.readSync(i.dataId)[0],[d,h,f,p,m]=d2e(a,r.shape,r.dtype,l,s.dtype,u,c);return[t.makeTensorInfo(h,r.dtype,d),t.makeTensorInfo([h[0]],s.dtype,f),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),t.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},z3e={kernelName:oC,backendName:"webgl",kernelFunc:function B3e(e){const{inputs:n,backend:t}=e,{inputIndices:r,inputShape:s,newShape:o}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(t.readSync(s.dataId)),a=t.readSync(r.dataId),l=Array.from(t.readSync(o.dataId)),[u,c,d]=h2e(a,r.shape,r.dtype,i,l);return[t.makeTensorInfo(c,r.dtype,u),t.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},W3e={kernelName:iC,backendName:"webgl",kernelFunc:function U3e(e){const{inputs:n,backend:t}=e,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(o.dataId),[u,c]=x8(i,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(c,r.dtype,u)}},j3e={kernelName:aC,backendName:"webgl",kernelFunc:function H3e(e){const{inputs:n,backend:t}=e,{data:r,indices:s,segmentIds:o}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(o.dataId),[u,c]=x8(i,r.shape,r.dtype,a,l);return t.makeTensorInfo(c,r.dtype,u)}},q3e={kernelName:lC,backendName:"webgl",kernelFunc:function G3e(e){const{inputs:n,backend:t,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ql(0,s,a),f=!1;if("string"===o.dtype){const y=t.bufferSync(s),v=t.bufferSync(o),b=Pa(t.readSync(i.dataId)[0]),w=l2e(y,v,a,h,c,u,l,d,b,f);return t.makeTensorInfo(a,w.dtype,w.values)}const p=new rO(u,l,s.shape.length,o.shape.length,d,[h,1],f),m=t.runWebGLProgram(p,[o,s,i],o.dtype),g=ye({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(m),g}},X3e={kernelName:Ty,backendName:"webgl",kernelFunc:function K3e(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{numOrSizeSplits:o,axis:i}=r,a=pt(i,s.shape)[0],l=yR(s,o,a),c=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=vp({inputs:{x:s},backend:t,attrs:{begin:c,size:f}});return c[a]+=h,p})}},yK="return sqrt(x);",Y3e=At({opSnippet:yK,packedOpSnippet:yK,cpuKernelImpl:f2e}),Z3e={kernelName:Ef,backendName:"webgl",kernelFunc:Y3e},Q3e=At({opSnippet:"return x * x;"}),J3e={kernelName:uC,backendName:"webgl",kernelFunc:Q3e},vK="return (a - b) * (a - b);",eze=jr({opSnippet:vK,packedOpSnippet:vK}),tze={kernelName:Df,backendName:"webgl",kernelFunc:eze},rze={kernelName:Ay,backendName:"webgl",kernelFunc:function nze(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const i=Xa(t.readSync(s.dataId)),a=p2e(i,"string",r);return t.makeTensorInfo(s.shape,"string",a)}},oze={kernelName:Rf,backendName:"webgl",kernelFunc:function sze({inputs:e,attrs:n,backend:t}){const{x:r}=e,o=new da(r.shape,To+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `);return t.runWebGLProgram(o,[r],r.dtype)}};class ize{constructor(n,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=Xt(r.length),i=Xt(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,1===r.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${o} begin = ${o}(${n});\n      ${o} strides = ${o}(${t});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const lze={kernelName:cC,backendName:"webgl",kernelFunc:function aze(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{begin:o,end:i,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:v,end:b,strides:w}=$k(s.shape,o,i,a,l,u,c,d,h);let x;if(m)x=ye({inputs:{x:s},backend:t,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const _=Mk(v,b,w),D=vp({inputs:{x:s},backend:t,attrs:{begin:v,size:_}});x=ye({inputs:{x:D},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(D)}else if(t.shouldExecuteOnCPU([s])){const D=t.readSync(s.dataId),N=it(s.shape,s.dtype,D),T=m2e(f,N,w,v);x=t.makeTensorInfo(p,s.dtype,T.values)}else{const D=new ize(v,w,f);x=t.runWebGLProgram(D,[s],s.dtype)}const I=ye({inputs:{x},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(x),I}},cze={kernelName:dC,backendName:"webgl",kernelFunc:function uze(e){const{inputs:n,backend:t,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=n,h=t.readSync(c.dataId),f=t.readSync(d.dataId),[p,m]=g2e(h,f,s,o,i,a,l,u);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(d.shape,"int32",m)]}},hze={kernelName:hC,backendName:"webgl",kernelFunc:function dze(e){const{inputs:n,backend:t,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:i}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=t.readSync(o.dataId),l=t.readSync(i.dataId)[0],[u,c,d]=y2e(a,l,s),h=c.length;return[t.makeTensorInfo([h,2],"int32",u),t.makeTensorInfo([h],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(d))]}},pze={kernelName:fC,backendName:"webgl",kernelFunc:function fze(e){const{inputs:n,backend:t,attrs:r}=e,{numBuckets:s}=r,{input:o}=n;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=t.readSync(o.dataId),a=v2e(i,s);return t.makeTensorInfo(o.shape,"int32",a)}},mze=At({opSnippet:"return tan(x);"}),gze={kernelName:Tf,backendName:"webgl",kernelFunc:mze},yze=At({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),vze={kernelName:kf,backendName:"webgl",kernelFunc:yze},wze={kernelName:nC,backendName:"webgl",kernelFunc:function bze(e){const{inputs:n,backend:t}=e,{tensor:s,indices:o,updates:i}=n,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ql(0,o,s.shape),h=[d/u,u];if(0===d)return t.makeTensorInfo(s.shape,o.dtype);const f=ye({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),p=ye({inputs:{x:i},backend:t,attrs:{shape:[l,u]}}),m=ye({inputs:{x:s},backend:t,attrs:{shape:h}}),g=new rO(l,a,f.shape.length,p.shape.length,c,h,!1,!0),y=t.runWebGLProgram(g,[p,f,m],m.dtype),v=ye({inputs:{x:y},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),v}};class xze{constructor(n,t){this.variableNames=["A"];const r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*t[i];this.outputShape=r,this.rank=r.length;const s=Xt(this.rank),o=function Cze(e){const n=e.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(1===n)return`imod(resRC, ${e[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${t[s]}, ${e[s]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}function bK(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const l=t.readSync(s.dataId),u="string"===s.dtype?l.map(h=>Pa(h)):l,c=it(s.shape,s.dtype,u),d=w2e(c,o);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new xze(s.shape,o);return t.runWebGLProgram(i,[s],s.dtype)}const Ize={kernelName:Af,backendName:"webgl",kernelFunc:bK};class Sze{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class _ze{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function sd(e,n){null!==n&&e.disposeIntermediateTensorInfo(n)}function wK(e){let n=1;for(;n<e;)n*=2;return n}const Dze={kernelName:pC,backendName:"webgl",kernelFunc:function Eze(e){const{inputs:n,backend:t,attrs:r}=e,{x:s}=n,{k:o,sorted:i}=r,a=V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([s])||c<a||o>l){const T=t.readSync(s.dataId),[P,B]=x2e(T,u,s.dtype,o,i);return[t.makeTensorInfo(P.shape,P.dtype,P.values),t.makeTensorInfo(B.shape,B.dtype,B.values)]}if(0===o)return u[u.length-1]=0,[t.makeTensorInfo(u,s.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(1===c)return[s,Wv({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const d=t.texData.get(s.dataId),h=null!==d&&d.isPacked,f=h?t.unpackTensor(s):s,m=j(u)/c,g=ye({inputs:{x:f},attrs:{shape:[m,c]},backend:t});h&&sd(t,f);const y=wK(o),v=wK(c);let b=null;const w=()=>null===b?[g,g]:[g,b],x=(T,P,B)=>{const W=w(),H=new Sze(B),Q=b;b=t.runWebGLProgram(H,W,"int32",[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[T],[P]]),sd(t,Q)};for(let T=1;T<y;T*=2){const P=2*T;for(let B=T;B>=1;B/=2)x(P,B,[m,v])}for(let T=v;T>y;T/=2){const P=w(),B=new _ze([m,T/2]),G=b;b=t.runWebGLProgram(B,P,"int32",[[c],[null===b?1:0],[y]]),sd(t,G);const Y=y/2,Q=2*Y;for(let q=Y;q>=1;q/=2)x(Q,q,b.shape)}let I=b;b=vp({inputs:{x:b},backend:t,attrs:{begin:0,size:[m,o]}}),sd(t,I);let _=lK({inputs:{x:g,indices:b},backend:t,attrs:{axis:1,batchDims:1}});sd(t,g);const D=u.slice(0,-1);D.push(o),I=b,b=ye({inputs:{x:b},attrs:{shape:D},backend:t}),sd(t,I);const N=_;return _=ye({inputs:{x:_},attrs:{shape:D},backend:t}),sd(t,N),[_,b]}};class Nze{constructor(n,t,r,s,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const kze={kernelName:mC,backendName:"webgl",kernelFunc:function Tze(e){const{inputs:n,backend:t,attrs:r}=e,{image:s,transforms:o}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:u}=r,[c,d,h,f]=s.shape,[p,m]=u??[d,h],y=new Nze(d,h,i,a,l,[c,p,m,f]);return t.runWebGLProgram(y,[s,o],"float32")}},Rze={kernelName:gC,backendName:"webgl",kernelFunc:function Aze(e){const{inputs:n,attrs:t,backend:r}=e,{axis:s}=t,{x:o}=n;Pv(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:l,indices:u}=C2e(i,s,o.shape,o.dtype);return[r.makeTensorInfo(l,o.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}},Oze={kernelName:Ry,backendName:"webgl",kernelFunc:function Mze(e){const{inputs:n,backend:t,attrs:r}=e,{value:s}=n;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,l=s.shape[o],u=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==o&&(u[c++]=i.shape[m]);const d=[],h=new Array(a).fill(0),f=i.shape.slice();f[o]=1;const p=new Array(l);for(let m=0;m<p.length;m++){h[o]=m;const g=vp({inputs:{x:i},backend:t,attrs:{begin:h,size:f}}),y=ye({inputs:{x:g},backend:t,attrs:{shape:u}});p[m]=y,d.push(g)}return d.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}};class Fze{constructor(n,t){this.variableNames=["x","segmentIds"];const r=n.windowSize,s=n.batchSize,o=n.inSize,i=n.numSegments,a=i*Math.ceil(o/r);this.outputShape=[s,a];const c=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";o%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return initializationValue;\n        }\n      `);let p="";o%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${o}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Lze=[gFe,vFe,xFe,SFe,EFe,TFe,AFe,MFe,PFe,VFe,UFe,jFe,KFe,QFe,t$e,r$e,o$e,u$e,d$e,f$e,g$e,C$e,S$e,N$e,k$e,F$e,P$e,z$e,J2e,H$e,X$e,J$e,oPe,lPe,cPe,hPe,pPe,vPe,wPe,CPe,SPe,EPe,NPe,APe,MPe,PPe,VPe,UPe,jPe,qPe,XPe,QPe,eLe,rLe,oLe,iLe,lLe,cLe,hLe,pLe,gLe,vLe,xLe,SLe,ELe,TLe,RLe,OLe,$Le,Q2e,LLe,q$e,BLe,ULe,HLe,tFe,GLe,KLe,YLe,JLe,nVe,sVe,iVe,lVe,dVe,fVe,mVe,bVe,xVe,IVe,DVe,TVe,AVe,MVe,FVe,VVe,UVe,GVe,QVe,sFe,nBe,oBe,lBe,dBe,A$e,fBe,mBe,yBe,wBe,SBe,rFe,EBe,NBe,kBe,RBe,MBe,R$e,KVe,FBe,LBe,zBe,iFe,jBe,KBe,QBe,t3e,o3e,a3e,u3e,d3e,p3e,y3e,w3e,I3e,E3e,N3e,R3e,O3e,x$e,YVe,$3e,P3e,V3e,z3e,W3e,j3e,q3e,X3e,Z3e,J3e,tze,rze,oze,lze,cze,hze,pze,XVe,fFe,gze,vze,wze,Ize,Dze,kze,pFe,Rze,Oze,{kernelName:My,backendName:"webgl",kernelFunc:function $ze(e){const{inputs:n,backend:t,attrs:r}=e,{x:s,segmentIds:o}=n,{numSegments:i}=r,a=s.shape.length,l=[];let u=0;const c=Dn([u],a);let d=s;null!=c&&(d=vs({inputs:{x:s},backend:t,attrs:{perm:c}}),l.push(d),u=Hn(1,a)[0]);const h=AG(d.shape,u,i),f=j([d.shape[u]]),p=ye({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}});l.push(p);const m=IC(s.dtype),g=(w,x,I,_,D)=>{const N=w.shape[0],T=w.shape[1],P=kG(T,D),W=new Fze({windowSize:P,inSize:T,batchSize:N,numSegments:D},x),H=t.compileAndRun(W,[w,I],_);if(l.push(H),H.shape[1]===D)return H;const G=gK({backend:t,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),Y=bK({inputs:{x:G},backend:t,attrs:{reps:[T/P]}});return l.push(G),l.push(Y),g(H,x,Y,_,D)},v=ye({inputs:{x:g(p,"unsortedSegmentSum",o,m,i)},backend:t,attrs:{shape:h}});let b=v;if(null!=c){l.push(v);const w=Ql(c);b=vs({inputs:{x:b},backend:t,attrs:{perm:w}})}return l.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}},pBe];for(const e of Lze)wC(e);var sO=function(e,n){return(sO=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var s in r)r.hasOwnProperty(s)&&(t[s]=r[s])})(e,n)};function xK(e,n){function t(){this.constructor=e}sO(e,n),e.prototype=null===n?Object.create(n):(t.prototype=n.prototype,new t)}var ha=function(){return ha=Object.assign||function(n){for(var t,r=1,s=arguments.length;r<s;r++)for(var o in t=arguments[r])Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o]);return n},ha.apply(this,arguments)};function fa(e,n,t,r){return new(t||(t=Promise))(function(o,i){function a(c){try{u(r.next(c))}catch(d){i(d)}}function l(c){try{u(r.throw(c))}catch(d){i(d)}}function u(c){c.done?o(c.value):function s(o){return o instanceof t?o:new t(function(i){i(o)})}(c.value).then(a,l)}u((r=r.apply(e,n||[])).next())})}function pa(e,n){var r,s,o,i,t={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(u){return function(c){return function l(u){if(r)throw new TypeError("Generator is already executing.");for(;t;)try{if(r=1,s&&(o=2&u[0]?s.return:u[0]?s.throw||((o=s.return)&&o.call(s),0):s.next)&&!(o=o.call(s,u[1])).done)return o;switch(s=0,o&&(u=[2&u[0],o.value]),u[0]){case 0:case 1:o=u;break;case 4:return t.label++,{value:u[1],done:!1};case 5:t.label++,s=u[1],u=[0];continue;case 7:u=t.ops.pop(),t.trys.pop();continue;default:if(!(o=(o=t.trys).length>0&&o[o.length-1])&&(6===u[0]||2===u[0])){t=0;continue}if(3===u[0]&&(!o||u[1]>o[0]&&u[1]<o[3])){t.label=u[1];break}if(6===u[0]&&t.label<o[1]){t.label=o[1],o=u;break}if(o&&t.label<o[2]){t.label=o[2],t.ops.push(u);break}o[2]&&t.ops.pop(),t.trys.pop();continue}u=n.call(e,t)}catch(c){u=[6,c],s=0}finally{r=o=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([u,c])}}}function CK(e){var n=e.shape[2],t=Kl(e,2),r=O(t,[-1]);return Mc(r,n)}function _S(e,n){return L(function(){return pe(fs(e,Re(n)),"int32")})}function zze(e,n){var t=n.shape,r=t[0],s=t[1],o=t[2];return L(function(){var i=CK(n),a=jn(Ga(0,o,1,"int32"),1),l=pe(at(i,a),"int32"),u=O(l,[r,s]),c=ne(u,Re(1,"int32"));return Ce(function Bze(e,n){return M(e,n)}(c,e),Re(1,"int32"))})}var IK=function(){function e(n,t){this.model=n,this.outputStride=t;var r=this.model.inputs[0].shape;S(-1===r[1]&&-1===r[2],function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"})}return e.prototype.predict=function(n){var t=this;return L(function(){var r=t.preprocessInput(pe(n,"float32")),s=jn(r,0),i=t.model.predict(s).map(function(l){return Qs(l,[0])}),a=t.nameOutputResults(i);return{heatmapScores:wo(a.heatmap),offsets:a.offsets,displacementFwd:a.displacementFwd,displacementBwd:a.displacementBwd,segmentation:a.segmentation,partHeatmaps:a.partHeatmaps,longOffsets:a.longOffsets,partOffsets:a.partOffsets}})},e.prototype.dispose=function(){this.model.dispose()},e}(),Wze=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return xK(n,e),n.prototype.preprocessInput=function(t){return L(function(){return Ce(ke(t,127.5),1)})},n.prototype.nameOutputResults=function(t){return{offsets:t[0],segmentation:t[1],partHeatmaps:t[2],longOffsets:t[3],heatmap:t[4],displacementFwd:t[5],displacementBwd:t[6],partOffsets:t[7]}},n}(IK),ES=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],Si=ES.length,DS=ES.reduce(function(e,n,t){return e[n]=t,e},{});function oO(e,n,t){return[n[1]/(t.left+t.right+e[1]),n[0]/(t.top+t.bottom+e[0])]}function SK(e,n,t,r){return{y:r.get(e,n,t),x:r.get(e,n,t+Si)}}function _K(e,n,t){var i=SK(e.heatmapY,e.heatmapX,e.id,t);return{x:e.heatmapX*n+i.x,y:e.heatmapY*n+i.y}}function EK(e,n,t){return e<n?n:e>t?t:e}function DK(e,n){return{x:e.x+n.x,y:e.y+n.y}}function qze(e,n,t){void 0===t&&(t=.3);for(var r=0,s=0,o=0;o<e.length;o++)n.keypoints[o].score>t&&(s+=1,r+=Math.pow(e[o].x-n.keypoints[o].position.x,2)+Math.pow(e[o].y-n.keypoints[o].position.y,2));return 0===s?r=1/0:r/=s,r}function Xze(e,n,t,r,s,o,i){for(var a=i[0],l=i[1],u=t(e),c=u.y*r+u.x,d=s[Si*(2*c)+n],h=s[Si*(2*c+1)+n],f=e.y+d,p=e.x+h,m=0;m<o;m++){f=Math.min(f,a-1);var g=t({x:p=Math.min(p,l-1),y:f}),y=g.y*r+g.x;f+=d=s[Si*(2*y)+n],p+=h=s[Si*(2*y+1)+n]}return{x:p,y:f}}function NK(e,n,t,r,s,o,i,a,l,u){for(var c=s[0],d=s[1],h=o[0],f=o[1],p=a[0],m=a[1],g=[],y=function(D){return function Kze(e,n,t,r){var o=n[1],i=t[0],l=Math.round(((n[0]+e.y+1)*t[1]-1)/r);return{x:Math.round(((o+e.x+1)*i-1)/r),y:l}}(D,[c,d],[h,f],l)},v=0;v<r;v++){var b=Xze(e,v,y,i,n,u,[p,m]);g.push(b)}for(var w=-1,x=1/0,I=0;I<t.length;I++){var _=qze(g,t[I]);_<x&&(w=I,x=_)}return w}function TK(e,n){var t=e[0];return[Math.round((e[1]-1)/n+1),Math.round((t-1)/n+1)]}function kK(e,n,t,r,s,o,i,a,l,u,c){for(var d=i[0],h=i[1],f=e.shape,p=f[0],m=f[1],g=n.shape.slice(0,2),b=O(n,[g[0],g[1],2,Si]),w=new Float32Array(c*Si*3).fill(0),x=0;x<t.length;x++)for(var I=x*Si*3,_=t[x],D=0;D<Si;D++){var N=_.keypoints[D],T=I+3*D;w[T]=N.score,w[T+1]=N.position.y,w[T+2]=N.position.x}var P=oO([r,s],[d,h],a),B=P[0],W=P[1],H=cs(w,[c,Si,3]),G=a.top,Y=a.left,Q={variableNames:["segmentation","longOffsets","poses"],outputShape:[p,m],userCode:"\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\n    }\n\n    float convertToPositionInOutputFloat(\n        int pos, int pad, float scale, int stride) {\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\n    }\n\n    float dist(float x1, float y1, float x2, float y2) {\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\n    }\n\n    float sampleLongOffsets(float h, float w, int d, int k) {\n      float fh = fract(h);\n      float fw = fract(w);\n      int clH = int(ceil(h));\n      int clW = int(ceil(w));\n      int flH = int(floor(h));\n      int flW = int(floor(w));\n      float o11 = getLongOffsets(flH, flW, d, k);\n      float o12 = getLongOffsets(flH, clW, d, k);\n      float o21 = getLongOffsets(clH, flW, d, k);\n      float o22 = getLongOffsets(clH, clW, d, k);\n      float o1 = mix(o11, o12, fw);\n      float o2 = mix(o21, o22, fw);\n      return mix(o1, o2, fh);\n    }\n\n    int findNearestPose(int h, int w) {\n      float prob = getSegmentation(h, w);\n      if (prob < 1.0) {\n        return -1;\n      }\n\n      // Done(Tyler): convert from output space h/w to strided space.\n      float stridedH = convertToPositionInOutputFloat(\n        h, ".concat(G,", ").concat(W,", ").concat(o,");\n      float stridedW = convertToPositionInOutputFloat(\n        w, ").concat(Y,", ").concat(B,", ").concat(o,");\n\n      float minDist = 1000000.0;\n      int iMin = -1;\n      for (int i = 0; i < ").concat(c,"; i++) {\n        float curDistSum = 0.0;\n        int numKpt = 0;\n        for (int k = 0; k < ").concat(Si,"; k++) {\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\n\n          float y = float(h) + dy;\n          float x = float(w) + dx;\n\n          for (int s = 0; s < ").concat(l,"; s++) {\n            int yRounded = round(min(y, float(").concat(r-1,")));\n            int xRounded = round(min(x, float(").concat(s-1,")));\n\n            float yStrided = convertToPositionInOutputFloat(\n              yRounded, ").concat(G,", ").concat(W,", ").concat(o,");\n            float xStrided = convertToPositionInOutputFloat(\n              xRounded, ").concat(Y,", ").concat(B,", ").concat(o,");\n\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\n\n            y = y + dy;\n            x = x + dx;\n          }\n\n          float poseScore = getPoses(i, k, 0);\n          float poseY = getPoses(i, k, 1);\n          float poseX = getPoses(i, k, 2);\n          if (poseScore > ").concat(u,") {\n            numKpt = numKpt + 1;\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\n          }\n        }\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\n          minDist = curDistSum / float(numKpt);\n          iMin = i;\n        }\n      }\n      return iMin;\n    }\n\n    void main() {\n        ivec2 coords = getOutputCoords();\n        int nearestPose = findNearestPose(coords[0], coords[1]);\n        setOutput(float(nearestPose));\n      }\n  ")};return EC().compileAndRun(Q,[e,b,H])}function AK(){return"webgl"===Gy()}function eUe(e,n,t,r,s,o,i,a,l,u,c,d){var h=i[0],f=i[1];return void 0===l&&(l=.2),void 0===u&&(u=8),void 0===c&&(c=.3),void 0===d&&(d=10),fa(this,void 0,void 0,function(){var p,m,g,y,v;return pa(this,function(b){switch(b.label){case 0:return p=t.filter(function(w){return w.score>=l}),AK()?(g=L(function(){var w=kK(e,n,p,r,s,o,[h,f],a,u,c,d),x=vo().makeTensorFromDataId(w.dataId,w.shape,w.dtype);return p.map(function(I,_){return function Qze(e,n){return L(function(){return pe(Xs(e,Re(n)),"int32")})}(x,_)})}),[4,Promise.all(g.map(function(w){return w.data()}))]):[3,2];case 1:return m=b.sent(),g.forEach(function(w){return w.dispose()}),[3,5];case 2:return[4,e.data()];case 3:return y=b.sent(),[4,n.data()];case 4:v=b.sent(),m=function Yze(e,n,t,r,s,o,i,a,l,u){var c=i[0],d=i[1];void 0===u&&(u=5);for(var h=t.map(function(D){return new Uint8Array(r*s).fill(0)}),f=a.top,p=a.left,m=oO([r,s],[c,d],a),g=m[0],y=m[1],v=TK([c,d],o)[0],b=0;b<r;b+=1)for(var w=0;w<s;w+=1){var x=b*s+w;if(1===e[x]){var _=NK({x:w,y:b},n,t,u,[f,p],[g,y],v,[r,s],o,l);_>=0&&(h[_][x]=1)}}return h}(y,v,p,r,s,o,[h,f],a,u),b.label=5;case 5:return[2,m.map(function(w,x){return{data:w,pose:p[x],width:s,height:r}})]}})})}function tUe(e,n,t,r,s,o,i,a,l,u,c,d,h){var f=a[0],p=a[1];return void 0===u&&(u=.2),void 0===c&&(c=8),void 0===d&&(d=.3),void 0===h&&(h=10),fa(this,void 0,void 0,function(){var m,g,y,v,b,w;return pa(this,function(x){switch(x.label){case 0:return m=r.filter(function(I){return I.score>=u}),AK()?(y=L(function(){var I=kK(e,n,m,s,o,i,[f,p],l,c,d,h),_=vo().makeTensorFromDataId(I.dataId,I.shape,I.dtype);return m.map(function(D,N){return function Jze(e,n,t){return L(function(){return Ce(M(pe(Xs(e,Re(t)),"int32"),ne(n,1)),1)})}(_,t,N)})}),[4,Promise.all(y.map(function(I){return I.data()}))]):[3,2];case 1:return g=x.sent(),y.forEach(function(I){return I.dispose()}),[3,6];case 2:return[4,e.data()];case 3:return v=x.sent(),[4,n.data()];case 4:return b=x.sent(),[4,t.data()];case 5:w=x.sent(),g=function Zze(e,n,t,r,s,o,i,a,l,u,c){var d=a[0],h=a[1];void 0===c&&(c=5);for(var f=r.map(function(N){return new Int32Array(s*o).fill(-1)}),p=l.top,m=l.left,g=oO([s,o],[d,h],l),y=g[0],v=g[1],b=TK([d,h],i)[0],w=0;w<s;w+=1)for(var x=0;x<o;x+=1){var I=w*o+x;if(1===e[I]){var D=NK({x,y:w},n,r,c,[p,m],[y,v],b,[s,o],i,u);D>=0&&(f[D][I]=t[I])}}return f}(v,b,w,m,s,o,i,[f,p],l,c),x.label=6;case 6:return[2,g.map(function(I,_){return{pose:m[_],data:I,height:s,width:o}})]}})})}function iO(e){return Math.floor(e/2)}[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map(function(e){return[DS[e[0]],DS[e[1]]]});var nUe=function(){function e(n,t){this.priorityQueue=new Array(n),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(n){this.priorityQueue[++this.numberOfElements]=n,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var n=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,n},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(n){for(;n>0&&this.less(iO(n),n);)this.exchange(n,iO(n)),n=iO(n)},e.prototype.sink=function(n){for(;2*n<=this.numberOfElements;){var t=2*n;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(n,t))break;this.exchange(n,t),n=t}},e.prototype.getValueAt=function(n){return this.getElementValue(this.priorityQueue[n])},e.prototype.less=function(n,t){return this.getValueAt(n)<this.getValueAt(t)},e.prototype.exchange=function(n,t){var r=this.priorityQueue[n];this.priorityQueue[n]=this.priorityQueue[t],this.priorityQueue[t]=r},e}();function rUe(e,n,t,r,s,o){for(var i=o.shape,a=i[0],l=i[1],u=!0,c=Math.max(t-s,0),d=Math.min(t+s+1,a),h=c;h<d;++h){for(var f=Math.max(r-s,0),p=Math.min(r+s+1,l),m=f;m<p;++m)if(o.get(h,m,e)>n){u=!1;break}if(!u)break}return u}var RK=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map(function(e){return[DS[e[0]],DS[e[1]]]}),aO=RK.map(function(e){return e[1]}),MK=RK.map(function(e){return e[0]});function lO(e,n,t,r){return{y:EK(Math.round(e.y/n),0,t-1),x:EK(Math.round(e.x/n),0,r-1)}}function OK(e,n,t,r,s,o,i,a){void 0===a&&(a=2);for(var l=r.shape,u=l[0],c=l[1],h=function oUe(e,n,t){var r=t.shape[2]/2;return{y:t.get(n.y,n.x,e),x:t.get(n.y,n.x,r+e)}}(e,lO(n.position,o,u,c),i),p=DK(n.position,h),m=0;m<a;m++){var g=lO(p,o,u,c),y=SK(g.y,g.x,t,s);p=DK({x:g.x*o,y:g.y*o},{x:y.x,y:y.y})}var v=lO(p,o,u,c),b=r.get(v.y,v.x,t);return{position:p,part:ES[t],score:b}}function iUe(e,n,t,r,s,o){var a=aO.length,l=new Array(n.shape[2]),u=e.part,c=e.score,d=_K(u,r,t);l[u.id]={score:c,part:ES[u.id],position:d};for(var h=a-1;h>=0;--h){var p=MK[h];l[f=aO[h]]&&!l[p]&&(l[p]=OK(h,l[f],p,n,t,r,o))}for(h=0;h<a;++h){var f;p=aO[h],l[f=MK[h]]&&!l[p]&&(l[p]=OK(h,l[f],p,n,t,r,s))}return l}function FK(e,n,t,r){var s=t.x,o=t.y;return e.some(function(i){var l=i.keypoints[r].position;return function Gze(e,n,t,r){var s=t-e,o=r-n;return s*s+o*o}(o,s,l.y,l.x)<=n})}function aUe(e,n,t){return t.reduce(function(s,o,i){var l=o.score;return FK(e,n,o.position,i)||(s+=l),s},0)/t.length}function NS(e,n,t,r,s,o,i,a){void 0===i&&(i=.5),void 0===a&&(a=20);for(var l=[],u=function sUe(e,n,t){for(var r=t.shape,s=r[0],o=r[1],i=r[2],a=new nUe(s*o*i,function(h){return h.score}),l=0;l<s;++l)for(var u=0;u<o;++u)for(var c=0;c<i;++c){var d=t.get(l,u,c);d<e||rUe(c,d,l,u,n,t)&&a.enqueue({score:d,part:{heatmapY:l,heatmapX:u,id:c}})}return a}(i,1,e),c=a*a;l.length<o&&!u.empty();){var d=u.dequeue();if(!FK(l,c,_K(d.part,s,n),d.part.id)){var f=iUe(d,e,n,s,t,r),p=aUe(l,c,f);l.push({keypoints:f,score:p})}}return l}var wp,uUe=[-123.15,-115.9,-103.06],cUe=function(e){function n(){return null!==e&&e.apply(this,arguments)||this}return xK(n,e),n.prototype.preprocessInput=function(t){return ne(t,uUe)},n.prototype.nameOutputResults=function(t){return{offsets:t[4],segmentation:t[6],partHeatmaps:t[5],longOffsets:t[3],heatmap:t[2],displacementFwd:t[1],displacementBwd:t[0],partOffsets:t[7]}},n}(IK),$K="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",PK="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function tl(e){if(typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)return function fUe(e){if("offsetHeight"in e&&0!==e.offsetHeight&&"offsetWidth"in e&&0!==e.offsetWidth)return[e.offsetHeight,e.offsetWidth];if(null!=e.height&&null!=e.width)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(e);if(typeof ImageData<"u"&&e instanceof ImageData)return[e.height,e.width];if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)return function pUe(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(e);if(e instanceof St)return[e.shape[0],e.shape[1]];throw new Error("error: Unknown input type: ".concat(e,"."))}function LK(e,n){return function mUe(e,n){return(e-1)%n==0}(e,n)?e:Math.floor(e/n)*n+1}var Hv={low:"low",medium:"medium",high:"high",full:"full"},gUe=((wp={})[Hv.low]=.25,wp[Hv.medium]=.5,wp[Hv.high]=.75,wp[Hv.full]=1,wp);function TS(e,n,t){var r=t[0],s=t[1],o=function yUe(e){if("string"==typeof e){var n=gUe[e];return S("number"==typeof n,function(){return"string value of inputResolution must be one of ".concat(Object.values(Hv).join(",")," but was ").concat(e,".")}),n}return S("number"==typeof e&&e<=2&&e>=.1,function(){return"inputResolution must be a string or number between ".concat(.1," and ").concat(2,", but ")+"was ".concat(e)}),e}(e);return[LK(r*o,n),LK(s*o,n)]}function xp(e,n,t,r,s){var o=n[0],i=n[1],a=t[0],l=t[1],u=r[0],c=u[0],d=u[1],h=r[1],f=h[0],p=h[1];return void 0===s&&(s=!1),L(function(){var m=ms.resizeBilinear(e,[a,l],!0);return s&&(m=wo(m)),function bUe(e,n,t){var r=n[0],s=n[1],o=t[0],i=o[0],a=o[1],l=t[1],u=l[0],c=l[1];return L(function(){var d=jn(e);return Qs(ms.cropAndResize(d,[[i/(r+i+a-1),u/(s+u+c-1),(i+r-1)/(r+i+a-1),(u+s-1)/(s+u+c-1)]],[0],[r,s]),[0])})}(m,[o,i],[[c,d],[f,p]])})}function kS(e,n){var t=n[0],r=n[1],s=tl(e),o=s[0],i=s[1],a=r/t,u=[0,0,0,0],c=u[0],d=u[1],h=u[2],f=u[3];i/o<a?(c=0,d=0,h=Math.round(.5*(a*o-i)),f=Math.round(.5*(a*o-i))):(c=Math.round(.5*(1/a*i-o)),d=Math.round(.5*(1/a*i-o)),h=0,f=0);var p=L(function(){var m=function vUe(e){return e instanceof St?e:Tk(e)}(e);return m=EA(m,[[c,d],[h,f],[0,0]]),ms.resizeBilinear(m,[t,r])});return{resized:p,padding:{top:c,left:h,right:f,bottom:d}}}function AS(e){return fa(this,void 0,void 0,function(){return pa(this,function(n){return[2,Promise.all(e.map(function(t){return t.buffer()}))]})})}function RS(e,n,t,r,s){var i=n[1],d=function xUe(e,n,t,r,s){return void 0===r&&(r=0),void 0===s&&(s=0),1===t&&1===n&&0===r&&0===s?e:e.map(function(o){return function wUe(e,n,t,r,s){return void 0===r&&(r=0),void 0===s&&(s=0),{score:e.score,keypoints:e.keypoints.map(function(o){var l=o.position;return{score:o.score,part:o.part,position:{x:l.x*t+s,y:l.y*n+r}}})}}(o,n,t,r,s)})}(e,(n[0]+r.top+r.bottom)/t[0],(i+r.left+r.right)/t[1],-r.top,-r.left);return s?function IUe(e,n){return n<=0?e:e.map(function(t){return function CUe(e,n){return{score:e.score,keypoints:e.keypoints.map(function(t){var o=t.position;return{score:t.score,part:t.part,position:{x:n-1-o.x,y:o.y}}})}}(t,n)})}(d,i):d}var Cp=!0,MS=!1,zK={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},UK=["MobileNetV1","ResNet50"],WK={MobileNetV1:[8,16,32],ResNet50:[32,16]},HK={MobileNetV1:[.5,.75,1],ResNet50:[1]},jK=[1,2,4],OS={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},FS={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function GK(e){var n=e.segmentationThreshold,t=e.maxDetections,r=e.scoreThreshold,s=e.nmsRadius;if(n<0||n>1)throw new Error("segmentationThreshold ".concat(n,". ")+"Should be in range [0.0, 1.0]");if(t<=0)throw new Error("Invalid maxDetections ".concat(t,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius ".concat(s,"."))}function qK(e){var n=e.segmentationThreshold,t=e.maxDetections,r=e.scoreThreshold,s=e.nmsRadius,o=e.minKeypointScore,i=e.refineSteps;if(n<0||n>1)throw new Error("segmentationThreshold ".concat(n,". ")+"Should be in range [0.0, 1.0]");if(t<=0)throw new Error("Invalid maxDetections ".concat(t,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius ".concat(s,"."));if(o<0||o>1)throw new Error("Invalid minKeypointScore ".concat(o,".")+"Should be in range [0.0, 1.0]");if(i<=0||i>20)throw new Error("Invalid refineSteps ".concat(i,".")+"Should be in range [1, 20]")}var KK=function(){function e(n){this.baseModel=n}return e.prototype.predictForPersonSegmentation=function(n){var t=this.baseModel.predict(n);return{segmentLogits:t.segmentation,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},e.prototype.predictForPersonSegmentationAndPart=function(n){var t=this.baseModel.predict(n);return{segmentLogits:t.segmentation,partHeatmapLogits:t.partHeatmaps,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},e.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(n){var t=this.baseModel.predict(n);return{segmentLogits:t.segmentation,longOffsets:t.longOffsets,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd,partHeatmaps:t.partHeatmaps}},e.prototype.segmentPersonActivation=function(n,t,r){var s=this;void 0===r&&(r=.5);var o=tl(n),i=o[0],a=o[1],l=TS(t,this.baseModel.outputStride,[i,a]),u=kS(n,l),c=u.resized,d=u.padding,h=L(function(){var v=s.predictForPersonSegmentation(c),w=v.heatmapScores,x=v.offsets,I=v.displacementFwd,_=v.displacementBwd,D=c.shape,P=xp(v.segmentLogits,[i,a],[D[0],D[1]],[[d.top,d.bottom],[d.left,d.right]],Cp);return{segmentation:_S(Qs(P),r),heatmapScores:w,offsets:x,displacementFwd:I,displacementBwd:_}}),f=h.segmentation,p=h.heatmapScores,m=h.offsets,g=h.displacementFwd,y=h.displacementBwd;return c.dispose(),{segmentation:f,heatmapScores:p,offsets:m,displacementFwd:g,displacementBwd:y,padding:d,internalResolutionHeightAndWidth:l}},e.prototype.segmentPerson=function(n,t){return void 0===t&&(t=OS),fa(this,void 0,void 0,function(){var r,s,o,i,a,l,u,c,d,h,f,p,m,w;return pa(this,function(x){switch(x.label){case 0:return GK(t=ha(ha({},OS),t)),r=this.segmentPersonActivation(n,t.internalResolution,t.segmentationThreshold),o=r.heatmapScores,i=r.offsets,a=r.displacementFwd,l=r.displacementBwd,u=r.padding,c=r.internalResolutionHeightAndWidth,h=(d=(s=r.segmentation).shape)[0],f=d[1],[4,s.data()];case 1:return p=x.sent(),s.dispose(),[4,AS([o,i,a,l])];case 2:return m=x.sent(),w=RS(w=NS(m[0],m[1],m[2],m[3],this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[h,f],c,u,MS),o.dispose(),i.dispose(),a.dispose(),l.dispose(),[2,{height:h,width:f,data:p,allPoses:w}]}})})},e.prototype.segmentMultiPerson=function(n,t){return void 0===t&&(t=FS),fa(this,void 0,void 0,function(){var r,s,o,i,a,l,u,c,d,h,f,p,m,g,y,I,_,D=this;return pa(this,function(N){switch(N.label){case 0:return qK(t=ha(ha({},FS),t)),r=tl(n),i=TS(t.internalResolution,this.baseModel.outputStride,[s=r[0],o=r[1]]),a=kS(n,i),l=a.resized,u=a.padding,c=L(function(){var q,T=D.predictForMultiPersonInstanceSegmentationAndPart(l),B=T.longOffsets,W=T.heatmapScores,H=T.offsets,G=T.displacementFwd,Y=T.displacementBwd,Q=xp(T.segmentLogits,[s,o],i,[[u.top,u.bottom],[u.left,u.right]],Cp);return q=B,{segmentation:_S(Qs(Q),t.segmentationThreshold),longOffsets:q,heatmapScoresRaw:W,offsetsRaw:H,displacementFwdRaw:G,displacementBwdRaw:Y}}),d=c.segmentation,h=c.longOffsets,[4,AS([f=c.heatmapScoresRaw,p=c.offsetsRaw,m=c.displacementFwdRaw,g=c.displacementBwdRaw])];case 1:return y=N.sent(),I=RS(I=NS(y[0],y[1],y[2],y[3],this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[s,o],i,u,MS),[4,eUe(d,h,I,s,o,this.baseModel.outputStride,i,u,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return _=N.sent(),l.dispose(),d.dispose(),h.dispose(),f.dispose(),p.dispose(),m.dispose(),g.dispose(),[2,_]}})})},e.prototype.segmentPersonPartsActivation=function(n,t,r){var s=this;void 0===r&&(r=.5);var o=tl(n),i=o[0],a=o[1],l=TS(t,this.baseModel.outputStride,[i,a]),u=kS(n,l),c=u.resized,d=u.padding,h=L(function(){var v=s.predictForPersonSegmentationAndPart(c),w=v.partHeatmapLogits,x=v.heatmapScores,I=v.offsets,_=v.displacementFwd,D=v.displacementBwd,N=c.shape,T=N[0],P=N[1],B=xp(v.segmentLogits,[i,a],[T,P],[[d.top,d.bottom],[d.left,d.right]],Cp),W=xp(w,[i,a],[T,P],[[d.top,d.bottom],[d.left,d.right]],Cp);return{partSegmentation:zze(_S(Qs(B),r),W),heatmapScores:x,offsets:I,displacementFwd:_,displacementBwd:D}}),f=h.partSegmentation,p=h.heatmapScores,m=h.offsets,g=h.displacementFwd,y=h.displacementBwd;return c.dispose(),{partSegmentation:f,heatmapScores:p,offsets:m,displacementFwd:g,displacementBwd:y,padding:d,internalResolutionHeightAndWidth:l}},e.prototype.segmentPersonParts=function(n,t){return void 0===t&&(t=OS),fa(this,void 0,void 0,function(){var r,s,o,i,a,l,u,c,d,h,f,p,m,w;return pa(this,function(x){switch(x.label){case 0:return GK(t=ha(ha({},OS),t)),r=this.segmentPersonPartsActivation(n,t.internalResolution,t.segmentationThreshold),o=r.heatmapScores,i=r.offsets,a=r.displacementFwd,l=r.displacementBwd,u=r.padding,c=r.internalResolutionHeightAndWidth,h=(d=(s=r.partSegmentation).shape)[0],f=d[1],[4,s.data()];case 1:return p=x.sent(),s.dispose(),[4,AS([o,i,a,l])];case 2:return m=x.sent(),w=RS(w=NS(m[0],m[1],m[2],m[3],this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[h,f],c,u,MS),o.dispose(),i.dispose(),a.dispose(),l.dispose(),[2,{height:h,width:f,data:p,allPoses:w}]}})})},e.prototype.segmentMultiPersonParts=function(n,t){return void 0===t&&(t=FS),fa(this,void 0,void 0,function(){var r,s,o,i,a,l,u,c,d,h,f,p,m,g,y,v,_,D,N=this;return pa(this,function(T){switch(T.label){case 0:return qK(t=ha(ha({},FS),t)),r=tl(n),i=TS(t.internalResolution,this.baseModel.outputStride,[s=r[0],o=r[1]]),a=kS(n,i),l=a.resized,u=a.padding,c=L(function(){var P=N.predictForMultiPersonInstanceSegmentationAndPart(l),W=P.longOffsets,H=P.heatmapScores,G=P.offsets,Y=P.displacementFwd,Q=P.displacementBwd,q=P.partHeatmaps,J=xp(P.segmentLogits,[s,o],i,[[u.top,u.bottom],[u.left,u.right]],Cp),ie=xp(q,[s,o],i,[[u.top,u.bottom],[u.left,u.right]],Cp),ue=W,me=_S(Qs(J),t.segmentationThreshold),de=function Uze(e){var n=e.shape,t=n[0],r=n[1],s=n[2];return L(function(){var o=CK(e),i=jn(Ga(0,s,1,"int32"),1),a=pe(at(o,i),"int32");return O(a,[t,r])})}(ie);return{segmentation:me,longOffsets:ue,heatmapScoresRaw:H,offsetsRaw:G,displacementFwdRaw:Y,displacementBwdRaw:Q,partSegmentation:de}}),d=c.segmentation,h=c.longOffsets,y=c.partSegmentation,[4,AS([f=c.heatmapScoresRaw,p=c.offsetsRaw,m=c.displacementFwdRaw,g=c.displacementBwdRaw])];case 1:return v=T.sent(),_=RS(_=NS(v[0],v[1],v[2],v[3],this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[s,o],i,u,MS),[4,tUe(d,h,y,_,s,o,this.baseModel.outputStride,i,u,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return D=T.sent(),l.dispose(),d.dispose(),h.dispose(),f.dispose(),p.dispose(),m.dispose(),g.dispose(),y.dispose(),[2,D]}})})},e.prototype.dispose=function(){this.baseModel.dispose()},e}();function _Ue(e){return fa(this,void 0,void 0,function(){var n,t,r,s,o,i;return pa(this,function(a){switch(a.label){case 0:if(n=e.outputStride,t=e.quantBytes,r=e.multiplier,null==Kn)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return s=function hUe(e,n,t){var r={1:"100",.75:"075",.5:"050"},s="model-stride".concat(e,".json");return 4===t?PK+"float/".concat(r[n],"/")+s:PK+"quant".concat(t,"/").concat(r[n],"/")+s}(n,r,t),[4,E6(e.modelUrl||s)];case 1:return o=a.sent(),i=new Wze(o,n),[2,new KK(i)]}})})}function EUe(e){return fa(this,void 0,void 0,function(){var n,t,r,s,o;return pa(this,function(i){switch(i.label){case 0:if(n=e.outputStride,t=e.quantBytes,null==Kn)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return r=function dUe(e,n){var t="model-stride".concat(e,".json");return 4===n?$K+"float/"+t:$K+"quant".concat(n,"/")+t}(n,t),[4,E6(e.modelUrl||r)];case 1:return s=i.sent(),o=new cUe(s,n),[2,new KK(o)]}})})}const PUe=["canvas"],LUe=e=>({left:e}),VUe=e=>({right:e});let BUe=(()=>{class e{route;http;authService;router;imageUrl=null;imageFilename=null;editedImage=null;maskApplied=!1;canvas;ctx;net;canvasWidth;canvasHeight;windowWidth;windowHeight;backButtonPosition={left:0};fileNamePosition={right:0};constructor(t,r,s,o){this.route=t,this.http=r,this.authService=s,this.router=o}ngOnInit(){var t=this;return F(function*(){yield t.configureBackend(),t.route.queryParams.subscribe(r=>{t.imageUrl=r.url,t.imageFilename=r.filename}),t.imageUrl&&(yield t.loadModel(),t.initializeCanvas()),t.updateWindowDimensions(),window.addEventListener("resize",t.updateWindowDimensions.bind(t))})()}configureBackend(){return F(function*(){try{yield G1("webgl"),yield gH(),console.log(`Using backend: ${Gy()}`)}catch{console.warn("WebGL not supported. Switching to CPU backend."),yield G1("cpu"),console.log(`Using backend: ${Gy()}`)}})()}loadModel(){var t=this;return F(function*(){try{t.net=yield function DUe(e){return void 0===e&&(e=zK),fa(this,void 0,void 0,function(){return pa(this,function(n){return"ResNet50"===(e=function SUe(e){if(null==(e=e||zK).architecture&&(e.architecture="MobileNetV1"),UK.indexOf(e.architecture)<0)throw new Error("Invalid architecture ".concat(e.architecture,". ")+"Should be one of ".concat(UK));if(null==e.outputStride&&(e.outputStride=16),WK[e.architecture].indexOf(e.outputStride)<0)throw new Error("Invalid outputStride ".concat(e.outputStride,". ")+"Should be one of ".concat(WK[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.multiplier&&(e.multiplier=1),HK[e.architecture].indexOf(e.multiplier)<0)throw new Error("Invalid multiplier ".concat(e.multiplier,". ")+"Should be one of ".concat(HK[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.quantBytes&&(e.quantBytes=4),jK.indexOf(e.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(e.quantBytes,". ")+"Should be one of ".concat(jK," ")+"for architecture ".concat(e.architecture,"."));return e}(e)).architecture?[2,EUe(e)]:"MobileNetV1"===e.architecture?[2,_Ue(e)]:[2,null]})})}(),console.log("BodyPix model loaded successfully")}catch(r){console.error("Error loading BodyPix model:",r)}})()}initializeCanvas(){const t=this.canvas.nativeElement,r=t.getContext("2d");if(!r||!this.imageUrl)return void console.error("Canvas context or image URL is missing");const s=new Image;s.src=this.imageUrl,s.crossOrigin="anonymous",s.onload=()=>{const{width:o,height:i}=this.calculateDisplayDimensions(s.width,s.height);t.width=o,t.height=i,r.drawImage(s,0,0,o,i),this.ctx=r,this.canvasWidth=o,this.canvasHeight=i,this.updateDynamicPositions(),this.editedImage=t.toDataURL("image/png")}}calculateDisplayDimensions(t,r){const i=Math.min(this.windowWidth/t,this.windowHeight/r);return{width:Math.round(t*i),height:Math.round(r*i)}}updateWindowDimensions(){this.windowWidth=window.innerWidth,this.windowHeight=window.innerHeight,this.updateDynamicPositions()}updateDynamicPositions(){this.canvasWidth&&this.canvasHeight&&(this.backButtonPosition.left=Math.max((this.windowWidth-this.canvasWidth)/2-.05*this.canvasWidth,10),this.fileNamePosition.right=Math.max((this.windowWidth-this.canvasWidth)/2-.05*this.canvasWidth,10))}applyBodyPix(){var t=this;return F(function*(){if(!t.ctx||!t.canvas||!t.net)return void console.error("Canvas, context, or BodyPix model is not ready.");const r=t.canvas.nativeElement,s=t.ctx,o=s.getImageData(0,0,r.width,r.height),i=yield t.net.segmentPerson(r),a=cs(i.data,[i.height,i.width,1],"int32"),u=ms.resizeBilinear(a,[r.height,r.width]).squeeze().arraySync();for(let c=0;c<r.height;c++)for(let d=0;d<r.width;d++){const h=4*(c*r.width+d);u[c][d]>.5||(o.data[h]=0,o.data[h+1]=0,o.data[h+2]=0,o.data[h+3]=0)}s.putImageData(o,0,0),t.editedImage=r.toDataURL("image/png"),t.maskApplied=!0,console.log("AI mask applied.")})()}onSave(){if(!this.editedImage||!this.imageFilename||!this.maskApplied)return void console.error("Mask not applied or no image to save.");const t=(new _r).set("Authorization",this.authService.getToken()||""),r=this.base64ToBlob(this.editedImage),s=new FormData;s.append("image",r,this.imageFilename),this.http.post("http://localhost:8000/api/save-edited-image",s,{headers:t}).subscribe(()=>{console.log("Image saved successfully")},o=>{console.error("Error saving image:",o)})}base64ToBlob(t){const r=atob(t.split(",")[1]),s=new ArrayBuffer(r.length),o=new Uint8Array(s);for(let i=0;i<r.length;i++)o[i]=r.charCodeAt(i);return new Blob([o],{type:"image/png"})}navigateToApplyBackground(){if(!this.editedImage||!this.imageFilename)return void console.error("No image or filename to pass.");const t=this.authService.getToken();this.router.navigate(["/applybackground"],{queryParams:{image:this.editedImage,filename:this.imageFilename,token:t}})}static \u0275fac=function(r){return new(r||e)(se($l),se(bh),se(D1),se(Uo))};static \u0275cmp=Cl({type:e,selectors:[["app-edit"]],viewQuery:function(r,s){if(1&r&&Pw(PUe,5),2&r){let o;Vm(o=Bm())&&(s.canvas=o.first)}},decls:15,vars:11,consts:[["canvas",""],[1,"header"],[1,"back-button",3,"routerLink","ngStyle"],[1,"file-name",3,"ngStyle"],[1,"image-container"],[1,"tools"],[1,"apply-mask-btn",3,"click","disabled"]],template:function(r,s){if(1&r){const o=sc();ze(0,"div",1)(1,"button",2),bt(2," Back to Gallery "),Ye(),ze(3,"h1",3),bt(4),Ye()(),ze(5,"div",4),rc(6,"canvas",null,0),Ye(),ze(8,"div",5)(9,"button",6),hn("click",function(){return ao(o),lo(s.applyBodyPix())}),bt(10," Apply AI Mask "),Ye(),ze(11,"button",6),hn("click",function(){return ao(o),lo(s.onSave())}),bt(12," Save Edited Image "),Ye(),ze(13,"button",6),hn("click",function(){return ao(o),lo(s.navigateToApplyBackground())}),bt(14,"Go to Apply Background"),Ye()()}2&r&&(In(),Zr("routerLink","/gallery")("ngStyle",IN(7,LUe,s.backButtonPosition.left+"px")),In(2),Zr("ngStyle",IN(9,VUe,s.fileNamePosition.right+"px")),In(),Lw(" Image: ",s.imageFilename," "),In(5),Zr("disabled",!s.imageUrl||!s.ctx||s.maskApplied),In(2),Zr("disabled",!s.maskApplied),In(2),Zr("disabled",!s.maskApplied))},dependencies:[iT,az,Ah,mc],styles:[".header[_ngcontent-%COMP%]{position:relative;width:100%;height:0px;display:flex;align-items:center;justify-content:space-between;background-color:#3576b8;padding:0;box-shadow:0 2px 4px #0000001a}.back-button[_ngcontent-%COMP%]{position:absolute;top:10px;background-color:#007bff;font-weight:700;color:#fff;border:none;border-radius:4px;padding:10px 20px;cursor:pointer}.file-name[_ngcontent-%COMP%]{position:absolute;top:10px;font-size:16px;font-weight:700;background-color:#414040;color:#fff;border:none;border-radius:4px;padding:10px 20px;cursor:pointer}.image-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:calc(100vh - 10px)}canvas[_ngcontent-%COMP%]{max-width:100%;max-height:100%;object-fit:contain}.tools[_ngcontent-%COMP%]{position:fixed;bottom:20px;width:100%;display:flex;justify-content:center;gap:20px}.apply-mask-btn[_ngcontent-%COMP%]{padding:10px 20px;font-size:16px;font-weight:700;color:#fff;background-color:#28a745;border:none;border-radius:8px;cursor:pointer;transition:background-color .3s ease}.apply-mask-btn[_ngcontent-%COMP%]:disabled{background-color:#6c757d;cursor:not-allowed}.apply-mask-btn[_ngcontent-%COMP%]:hover:not(:disabled){background-color:#218838}"]})}return e})();const zUe=["canvas"];function UUe(e,n){if(1&e){const t=sc();ze(0,"div",13)(1,"img",14),hn("click",function(){const s=ao(t).$implicit;return lo(ii().applyBackground(s))}),Ye()()}if(2&e){const t=n.$implicit;In(),Zr("src",t,am)}}let WUe=(()=>{class e{route;http;canvas;ctx;receivedImage=null;imageFilename=null;token=null;availableBackgrounds=[];selectedBackground=null;constructor(t,r){this.route=t,this.http=r}ngOnInit(){this.route.queryParams.subscribe(t=>{this.receivedImage=t.image,this.imageFilename=t.filename,this.token=t.token,this.receivedImage?(console.log("Received image:"),console.log("Filename:",this.imageFilename),console.log("Token:",this.token)):console.error("No image received (receivedImage is null or undefined).")}),this.loadBackgrounds()}loadBackgrounds(){this.http.get("http://localhost:8000/api/backgrounds").subscribe(t=>{this.availableBackgrounds=t.map(r=>`http://localhost:8000/uploads/background/${r}`)},t=>{console.error("Error loading backgrounds:",t)})}ngAfterViewInit(){this.receivedImage&&this.drawImageOnCanvas()}drawImageOnCanvas(){if(!this.receivedImage)return;const t=this.canvas.nativeElement,r=t.getContext("2d");if(!r)return void console.error("Canvas context is missing");const s=new Image;s.src=this.receivedImage,s.crossOrigin="anonymous",s.onload=()=>{t.width=s.width,t.height=s.height,r.drawImage(s,0,0),this.ctx=r,console.log("Image drawn on canvas.")},s.onerror=()=>{console.error("Error loading the image.")}}applyBackground(t){if(!this.receivedImage)return;const r=this.canvas.nativeElement,s=r.getContext("2d");if(!s)return void console.error("Canvas context is missing");const o=new Image;o.src=t,o.crossOrigin="anonymous";const i=new Image;i.src=this.receivedImage,i.crossOrigin="anonymous",o.onload=()=>{i.onload=()=>{r.width=i.width,r.height=i.height;const a=o.width/o.height;let u,c,d,h;i.width/i.height>a?(u=i.width,c=i.width/a,d=0,h=(i.height-c)/2):(c=i.height,u=i.height*a,d=(i.width-u)/2,h=0),s.drawImage(o,d,h,u,c),s.drawImage(i,0,0,i.width,i.height),console.log("Background applied to the image.")}},o.onerror=()=>{console.error("Error loading the background.")}}onSave(){if(!this.imageFilename||!this.token)return void console.error("Cannot save the image - missing required data.");const r=this.canvas.nativeElement.toDataURL("image/png"),s=this.base64ToBlob(r),o=(new _r).set("Authorization",this.token||""),i=new FormData;i.append("image",s,this.imageFilename),this.http.post("http://localhost:8000/api/save-image-with-background",i,{headers:o}).subscribe(()=>{console.log("Image saved successfully.")},a=>{console.error("Error saving the image:",a)})}base64ToBlob(t){const r=atob(t.split(",")[1]),s=new ArrayBuffer(r.length),o=new Uint8Array(s);for(let i=0;i<r.length;i++)o[i]=r.charCodeAt(i);return new Blob([o],{type:"image/png"})}static \u0275fac=function(r){return new(r||e)(se($l),se(bh))};static \u0275cmp=Cl({type:e,selectors:[["app-applybackground"]],viewQuery:function(r,s){if(1&r&&Pw(zUe,5),2&r){let o;Vm(o=Bm())&&(s.canvas=o.first)}},decls:16,vars:2,consts:[["canvas",""],[1,"container-fluid","mt-4"],[1,"row"],[1,"col-md-6","position-relative","d-flex","flex-column","justify-content-center","align-items-center",2,"height","95vh"],[1,"tools","position-absolute","d-flex","justify-content-between","w-100",2,"top","0","z-index","10","padding","15px"],[1,"btn","text-white",2,"background-color","#007bff",3,"routerLink"],[1,"btn","text-white",2,"background-color","#28a745",3,"click"],[1,"image-container","position-relative",2,"z-index","1"],[1,"w-90","h-90"],[1,"col-md-6","d-flex","flex-column","justify-content-center","align-items-center",2,"height","95vh"],[1,"text-center","mb-3"],[1,"row","w-100"],["class","col-6 mb-3 d-flex justify-content-center align-items-center",4,"ngFor","ngForOf"],[1,"col-6","mb-3","d-flex","justify-content-center","align-items-center"],["alt","Background",1,"background-image","w-100","rounded",2,"max-height","20vh","cursor","pointer",3,"click","src"]],template:function(r,s){if(1&r){const o=sc();ze(0,"div",1)(1,"div",2)(2,"div",3)(3,"div",4)(4,"button",5),bt(5,"Back to Gallery"),Ye(),ze(6,"button",6),hn("click",function(){return ao(o),lo(s.onSave())}),bt(7,"Save Image"),Ye()(),ze(8,"div",7),rc(9,"canvas",8,0),Ye()(),ze(11,"div",9)(12,"h3",10),bt(13,"Wybierz t\u0142o"),Ye(),ze(14,"div",11),Tm(15,UUe,2,1,"div",12),Ye()()()()}2&r&&(In(4),Zr("routerLink","/gallery"),In(11),Zr("ngForOf",s.availableBackgrounds))},dependencies:[iT,tT,Ah,mc],encapsulation:2})}return e})(),HUe=(()=>{class e{http;router;user={username:"",password:""};message="";constructor(t,r){this.http=t,this.router=r}onRegister(){this.http.post("http://localhost:8000/api/register",this.user).subscribe({next:t=>{this.message=t.message,alert("Registration successful! Redirecting to login..."),this.router.navigate(["/login"])},error:t=>{this.message=t.error||"Registration failed!"}})}static \u0275fac=function(r){return new(r||e)(se(bh),se(Uo))};static \u0275cmp=Cl({type:e,selectors:[["app-register"]],decls:21,vars:3,consts:[[1,"container","mt-5"],[1,"row","justify-content-center"],[1,"col-md-6"],[1,"card","shadow-sm"],[1,"card-header","text-center","bg-secondary","text-white"],[1,"h4","mb-0"],[1,"card-body"],[3,"ngSubmit"],[1,"form-group","mb-3"],["for","username"],["type","text","id","username","name","username","placeholder","Enter your username","required","",1,"form-control",3,"ngModelChange","ngModel"],["for","password"],["type","password","id","password","name","password","placeholder","Enter your password","required","",1,"form-control",3,"ngModelChange","ngModel"],["type","submit",1,"btn","btn-success","w-100"],[1,"mt-3","text-center","text-danger"]],template:function(r,s){1&r&&(ze(0,"div",0)(1,"div",1)(2,"div",2)(3,"div",3)(4,"div",4)(5,"h1",5),bt(6,"Register"),Ye()(),ze(7,"div",6)(8,"form",7),hn("ngSubmit",function(){return s.onRegister()}),ze(9,"div",8)(10,"label",9),bt(11,"Username:"),Ye(),ze(12,"input",10),dh("ngModelChange",function(i){return Um(s.user.username,i)||(s.user.username=i),i}),Ye()(),ze(13,"div",8)(14,"label",11),bt(15,"Password:"),Ye(),ze(16,"input",12),dh("ngModelChange",function(i){return Um(s.user.password,i)||(s.user.password=i),i}),Ye()(),ze(17,"button",13),bt(18,"Register"),Ye()(),ze(19,"p",14),bt(20),Ye()()()()()()),2&r&&(In(12),ch("ngModel",s.user.username),In(4),ch("ngModel",s.user.password),In(4),zm(s.message))},dependencies:[A4,x1,Sg,a1,l1,kg,r0,Tg,TT,Ah],encapsulation:2})}return e})();const jUe=document.getElementsByTagName("base")[0]?.getAttribute("href")||"/";(function eue(e,n){return joe({rootComponent:e,...Mz(n)})})(bfe,{providers:[function ofe(e,...n){return ya([{provide:kh,multi:!0,useValue:e},[],{provide:$l,useFactory:SW,deps:[Uo]},{provide:Qd,multi:!0,useFactory:_W},n.map(t=>t.\u0275providers)])}([{path:"login",component:wpe},{path:"",redirectTo:"/login",pathMatch:"full"},{path:"gallery",component:Dpe},{path:"edit",component:BUe},{path:"applybackground",component:WUe},{path:"register",component:HUe},{path:"**",redirectTo:"/login",pathMatch:"full"}]),bU(),{provide:HN,useValue:jUe}]}).catch(e=>console.error(e))},929:Dt=>{Dt.exports=U;var It=null;try{It=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function U(ee,A,we){this.low=0|ee,this.high=0|A,this.unsigned=!!we}function We(ee){return!0===(ee&&ee.__isLong__)}Object.defineProperty(U.prototype,"__isLong__",{value:!0}),U.isLong=We;var nr={},qe={};function pn(ee,A){var we,He,Tt;return A?(Tt=0<=(ee>>>=0)&&ee<256)&&(He=qe[ee])?He:(we=Pe(ee,(0|ee)<0?-1:0,!0),Tt&&(qe[ee]=we),we):(Tt=-128<=(ee|=0)&&ee<128)&&(He=nr[ee])?He:(we=Pe(ee,ee<0?-1:0,!1),Tt&&(nr[ee]=we),we)}function ct(ee,A){if(isNaN(ee))return A?Kn:Ut;if(A){if(ee<0)return Kn;if(ee>=ce)return Ft}else{if(ee<=-Ne)return $t;if(ee+1>=Ne)return Nt}return ee<0?ct(-ee,A).neg():Pe(ee%re|0,ee/re|0,A)}function Pe(ee,A,we){return new U(ee,A,we)}U.fromInt=pn,U.fromNumber=ct,U.fromBits=Pe;var lt=Math.pow;function Se(ee,A,we){if(0===ee.length)throw Error("empty string");if("NaN"===ee||"Infinity"===ee||"+Infinity"===ee||"-Infinity"===ee)return Ut;if("number"==typeof A?(we=A,A=!1):A=!!A,(we=we||10)<2||36<we)throw RangeError("radix");var He;if((He=ee.indexOf("-"))>0)throw Error("interior hyphen");if(0===He)return Se(ee.substring(1),A,we).neg();for(var Tt=ct(lt(we,8)),gt=Ut,Pt=0;Pt<ee.length;Pt+=8){var An=Math.min(8,ee.length-Pt),$n=parseInt(ee.substring(Pt,Pt+An),we);if(An<8){var rr=ct(lt(we,An));gt=gt.mul(rr).add(ct($n))}else gt=(gt=gt.mul(Tt)).add(ct($n))}return gt.unsigned=A,gt}function z(ee,A){return"number"==typeof ee?ct(ee,A):"string"==typeof ee?Se(ee,A):Pe(ee.low,ee.high,"boolean"==typeof A?A:ee.unsigned)}U.fromString=Se,U.fromValue=z;var re=4294967296,ce=re*re,Ne=ce/2,Me=pn(1<<24),Ut=pn(0);U.ZERO=Ut;var Kn=pn(0,!0);U.UZERO=Kn;var Xn=pn(1);U.ONE=Xn;var Ao=pn(1,!0);U.UONE=Ao;var no=pn(-1);U.NEG_ONE=no;var Nt=Pe(-1,2147483647,!1);U.MAX_VALUE=Nt;var Ft=Pe(-1,-1,!0);U.MAX_UNSIGNED_VALUE=Ft;var $t=Pe(0,-2147483648,!1);U.MIN_VALUE=$t;var ae=U.prototype;ae.toInt=function(){return this.unsigned?this.low>>>0:this.low},ae.toNumber=function(){return this.unsigned?(this.high>>>0)*re+(this.low>>>0):this.high*re+(this.low>>>0)},ae.toString=function(A){if((A=A||10)<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq($t)){var we=ct(A),He=this.div(we),Tt=He.mul(we).sub(this);return He.toString(A)+Tt.toInt().toString(A)}return"-"+this.neg().toString(A)}for(var gt=ct(lt(A,6),this.unsigned),Pt=this,An="";;){var $n=Pt.div(gt),wn=(Pt.sub($n.mul(gt)).toInt()>>>0).toString(A);if((Pt=$n).isZero())return wn+An;for(;wn.length<6;)wn="0"+wn;An=""+wn+An}},ae.getHighBits=function(){return this.high},ae.getHighBitsUnsigned=function(){return this.high>>>0},ae.getLowBits=function(){return this.low},ae.getLowBitsUnsigned=function(){return this.low>>>0},ae.getNumBitsAbs=function(){if(this.isNegative())return this.eq($t)?64:this.neg().getNumBitsAbs();for(var A=0!=this.high?this.high:this.low,we=31;we>0&&!(A&1<<we);we--);return 0!=this.high?we+33:we+1},ae.isZero=function(){return 0===this.high&&0===this.low},ae.eqz=ae.isZero,ae.isNegative=function(){return!this.unsigned&&this.high<0},ae.isPositive=function(){return this.unsigned||this.high>=0},ae.isOdd=function(){return!(1&~this.low)},ae.isEven=function(){return!(1&this.low)},ae.equals=function(A){return We(A)||(A=z(A)),(this.unsigned===A.unsigned||this.high>>>31!=1||A.high>>>31!=1)&&this.high===A.high&&this.low===A.low},ae.eq=ae.equals,ae.notEquals=function(A){return!this.eq(A)},ae.neq=ae.notEquals,ae.ne=ae.notEquals,ae.lessThan=function(A){return this.comp(A)<0},ae.lt=ae.lessThan,ae.lessThanOrEqual=function(A){return this.comp(A)<=0},ae.lte=ae.lessThanOrEqual,ae.le=ae.lessThanOrEqual,ae.greaterThan=function(A){return this.comp(A)>0},ae.gt=ae.greaterThan,ae.greaterThanOrEqual=function(A){return this.comp(A)>=0},ae.gte=ae.greaterThanOrEqual,ae.ge=ae.greaterThanOrEqual,ae.compare=function(A){if(We(A)||(A=z(A)),this.eq(A))return 0;var we=this.isNegative(),He=A.isNegative();return we&&!He?-1:!we&&He?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},ae.comp=ae.compare,ae.negate=function(){return!this.unsigned&&this.eq($t)?$t:this.not().add(Xn)},ae.neg=ae.negate,ae.add=function(A){We(A)||(A=z(A));var wn=0,ns=0,vt=0,qr=0;return vt+=(qr+=(65535&this.low)+(65535&A.low))>>>16,ns+=(vt+=(this.low>>>16)+(A.low>>>16))>>>16,wn+=(ns+=(65535&this.high)+(65535&A.high))>>>16,wn+=(this.high>>>16)+(A.high>>>16),Pe((vt&=65535)<<16|(qr&=65535),(wn&=65535)<<16|(ns&=65535),this.unsigned)},ae.subtract=function(A){return We(A)||(A=z(A)),this.add(A.neg())},ae.sub=ae.subtract,ae.multiply=function(A){if(this.isZero())return Ut;if(We(A)||(A=z(A)),It)return Pe(It.mul(this.low,this.high,A.low,A.high),It.get_high(),this.unsigned);if(A.isZero())return Ut;if(this.eq($t))return A.isOdd()?$t:Ut;if(A.eq($t))return this.isOdd()?$t:Ut;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(Me)&&A.lt(Me))return ct(this.toNumber()*A.toNumber(),this.unsigned);var Tt=65535&this.high,gt=this.low>>>16,Pt=65535&this.low,$n=65535&A.high,rr=A.low>>>16,wn=65535&A.low,ns=0,vt=0,qr=0,xu=0;return qr+=(xu+=Pt*wn)>>>16,vt+=(qr+=gt*wn)>>>16,qr&=65535,vt+=(qr+=Pt*rr)>>>16,ns+=(vt+=Tt*wn)>>>16,vt&=65535,ns+=(vt+=gt*rr)>>>16,vt&=65535,ns+=(vt+=Pt*$n)>>>16,ns+=(this.high>>>16)*wn+Tt*rr+gt*$n+Pt*(A.high>>>16),Pe((qr&=65535)<<16|(xu&=65535),(ns&=65535)<<16|(vt&=65535),this.unsigned)},ae.mul=ae.multiply,ae.divide=function(A){if(We(A)||(A=z(A)),A.isZero())throw Error("division by zero");var He,Tt,gt;if(It)return this.unsigned||-2147483648!==this.high||-1!==A.low||-1!==A.high?Pe((this.unsigned?It.div_u:It.div_s)(this.low,this.high,A.low,A.high),It.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Kn:Ut;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return Kn;if(A.gt(this.shru(1)))return Ao;gt=Kn}else{if(this.eq($t))return A.eq(Xn)||A.eq(no)?$t:A.eq($t)?Xn:(He=this.shr(1).div(A).shl(1)).eq(Ut)?A.isNegative()?Xn:no:(Tt=this.sub(A.mul(He)),gt=He.add(Tt.div(A)));if(A.eq($t))return this.unsigned?Kn:Ut;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();gt=Ut}for(Tt=this;Tt.gte(A);){He=Math.max(1,Math.floor(Tt.toNumber()/A.toNumber()));for(var An=Math.ceil(Math.log(He)/Math.LN2),$n=An<=48?1:lt(2,An-48),rr=ct(He),wn=rr.mul(A);wn.isNegative()||wn.gt(Tt);)wn=(rr=ct(He-=$n,this.unsigned)).mul(A);rr.isZero()&&(rr=Xn),gt=gt.add(rr),Tt=Tt.sub(wn)}return gt},ae.div=ae.divide,ae.modulo=function(A){return We(A)||(A=z(A)),It?Pe((this.unsigned?It.rem_u:It.rem_s)(this.low,this.high,A.low,A.high),It.get_high(),this.unsigned):this.sub(this.div(A).mul(A))},ae.mod=ae.modulo,ae.rem=ae.modulo,ae.not=function(){return Pe(~this.low,~this.high,this.unsigned)},ae.and=function(A){return We(A)||(A=z(A)),Pe(this.low&A.low,this.high&A.high,this.unsigned)},ae.or=function(A){return We(A)||(A=z(A)),Pe(this.low|A.low,this.high|A.high,this.unsigned)},ae.xor=function(A){return We(A)||(A=z(A)),Pe(this.low^A.low,this.high^A.high,this.unsigned)},ae.shiftLeft=function(A){return We(A)&&(A=A.toInt()),0==(A&=63)?this:A<32?Pe(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):Pe(0,this.low<<A-32,this.unsigned)},ae.shl=ae.shiftLeft,ae.shiftRight=function(A){return We(A)&&(A=A.toInt()),0==(A&=63)?this:A<32?Pe(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):Pe(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},ae.shr=ae.shiftRight,ae.shiftRightUnsigned=function(A){if(We(A)&&(A=A.toInt()),0==(A&=63))return this;var we=this.high;return A<32?Pe(this.low>>>A|we<<32-A,we>>>A,this.unsigned):Pe(32===A?we:we>>>A-32,0,this.unsigned)},ae.shru=ae.shiftRightUnsigned,ae.shr_u=ae.shiftRightUnsigned,ae.toSigned=function(){return this.unsigned?Pe(this.low,this.high,!1):this},ae.toUnsigned=function(){return this.unsigned?this:Pe(this.low,this.high,!0)},ae.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},ae.toBytesLE=function(){var A=this.high,we=this.low;return[255&we,we>>>8&255,we>>>16&255,we>>>24,255&A,A>>>8&255,A>>>16&255,A>>>24]},ae.toBytesBE=function(){var A=this.high,we=this.low;return[A>>>24,A>>>16&255,A>>>8&255,255&A,we>>>24,we>>>16&255,we>>>8&255,255&we]},U.fromBytes=function(A,we,He){return He?U.fromBytesLE(A,we):U.fromBytesBE(A,we)},U.fromBytesLE=function(A,we){return new U(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,we)},U.fromBytesBE=function(A,we){return new U(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],we)}},814:(Dt,It,U)=>{var We=U(495),nr=U(850),qe=U(704),pn=U(114),ct=U(40),Pe=U(478),lt=U(454);lt.alea=We,lt.xor128=nr,lt.xorwow=qe,lt.xorshift7=pn,lt.xor4096=ct,lt.tychei=Pe,Dt.exports=lt},495:function(Dt,It,U){var We;!function(nr,qe){function ct(z){var he=this,ve=function Se(){var z=4022871197;return function(ve){ve=String(ve);for(var re=0;re<ve.length;re++){var ce=.02519603282416938*(z+=ve.charCodeAt(re));ce-=z=ce>>>0,z=(ce*=z)>>>0,z+=4294967296*(ce-=z)}return 2.3283064365386963e-10*(z>>>0)}}();he.next=function(){var re=2091639*he.s0+2.3283064365386963e-10*he.c;return he.s0=he.s1,he.s1=he.s2,he.s2=re-(he.c=0|re)},he.c=1,he.s0=ve(" "),he.s1=ve(" "),he.s2=ve(" "),he.s0-=ve(z),he.s0<0&&(he.s0+=1),he.s1-=ve(z),he.s1<0&&(he.s1+=1),he.s2-=ve(z),he.s2<0&&(he.s2+=1),ve=null}function Pe(z,he){return he.c=z.c,he.s0=z.s0,he.s1=z.s1,he.s2=z.s2,he}function lt(z,he){var ve=new ct(z),re=he&&he.state,ce=ve.next;return ce.int32=function(){return 4294967296*ve.next()|0},ce.double=function(){return ce()+11102230246251565e-32*(2097152*ce()|0)},ce.quick=ce,re&&("object"==typeof re&&Pe(re,ve),ce.state=function(){return Pe(ve,{})}),ce}qe&&qe.exports?qe.exports=lt:U.amdD&&U.amdO?void 0!==(We=function(){return lt}.call(It,U,It,qe))&&(qe.exports=We):this.alea=lt}(0,Dt=U.nmd(Dt))},478:function(Dt,It,U){var We;!function(nr,qe){function ct(Se){var z=this,he="";z.next=function(){var re=z.b,ce=z.c,Ne=z.d,Me=z.a;return re=re<<25^re>>>7^ce,ce=ce-Ne|0,Ne=Ne<<24^Ne>>>8^Me,Me=Me-re|0,z.b=re=re<<20^re>>>12^ce,z.c=ce=ce-Ne|0,z.d=Ne<<16^ce>>>16^Me,z.a=Me-re|0},z.a=0,z.b=0,z.c=-1640531527,z.d=1367130551,Se===Math.floor(Se)?(z.a=Se/4294967296|0,z.b=0|Se):he+=Se;for(var ve=0;ve<he.length+20;ve++)z.b^=0|he.charCodeAt(ve),z.next()}function Pe(Se,z){return z.a=Se.a,z.b=Se.b,z.c=Se.c,z.d=Se.d,z}function lt(Se,z){var he=new ct(Se),ve=z&&z.state,re=function(){return(he.next()>>>0)/4294967296};return re.double=function(){do{var Me=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},re.int32=he.next,re.quick=re,ve&&("object"==typeof ve&&Pe(ve,he),re.state=function(){return Pe(he,{})}),re}qe&&qe.exports?qe.exports=lt:U.amdD&&U.amdO?void 0!==(We=function(){return lt}.call(It,U,It,qe))&&(qe.exports=We):this.tychei=lt}(0,Dt=U.nmd(Dt))},850:function(Dt,It,U){var We;!function(nr,qe){function ct(Se){var z=this,he="";z.x=0,z.y=0,z.z=0,z.w=0,z.next=function(){var re=z.x^z.x<<11;return z.x=z.y,z.y=z.z,z.z=z.w,z.w^=z.w>>>19^re^re>>>8},Se===(0|Se)?z.x=Se:he+=Se;for(var ve=0;ve<he.length+64;ve++)z.x^=0|he.charCodeAt(ve),z.next()}function Pe(Se,z){return z.x=Se.x,z.y=Se.y,z.z=Se.z,z.w=Se.w,z}function lt(Se,z){var he=new ct(Se),ve=z&&z.state,re=function(){return(he.next()>>>0)/4294967296};return re.double=function(){do{var Me=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},re.int32=he.next,re.quick=re,ve&&("object"==typeof ve&&Pe(ve,he),re.state=function(){return Pe(he,{})}),re}qe&&qe.exports?qe.exports=lt:U.amdD&&U.amdO?void 0!==(We=function(){return lt}.call(It,U,It,qe))&&(qe.exports=We):this.xor128=lt}(0,Dt=U.nmd(Dt))},40:function(Dt,It,U){var We;!function(nr,qe){function ct(Se){var z=this;z.next=function(){var Ne,Me,ve=z.w,re=z.X,ce=z.i;return z.w=ve=ve+1640531527|0,Me=re[ce+34&127],Ne=re[ce=ce+1&127],Me^=Me<<13,Ne^=Ne<<17,Me=re[ce]=(Me^=Me>>>15)^(Ne^=Ne>>>12),z.i=ce,Me+(ve^ve>>>16)|0},function he(ve,re){var ce,Ne,Me,Ut,Kn,Xn=[],Ao=128;for(re===(0|re)?(Ne=re,re=null):(re+="\0",Ne=0,Ao=Math.max(Ao,re.length)),Me=0,Ut=-32;Ut<Ao;++Ut)re&&(Ne^=re.charCodeAt((Ut+32)%re.length)),0===Ut&&(Kn=Ne),Ne^=Ne<<10,Ne^=Ne>>>15,Ne^=Ne<<4,Ne^=Ne>>>13,Ut>=0&&(Me=0==(ce=Xn[127&Ut]^=Ne+(Kn=Kn+1640531527|0))?Me+1:0);for(Me>=128&&(Xn[127&(re&&re.length||0)]=-1),Me=127,Ut=512;Ut>0;--Ut)Ne=Xn[Me+34&127],ce=Xn[Me=Me+1&127],Ne^=Ne<<13,ce^=ce<<17,Xn[Me]=(Ne^=Ne>>>15)^(ce^=ce>>>12);ve.w=Kn,ve.X=Xn,ve.i=Me}(z,Se)}function Pe(Se,z){return z.i=Se.i,z.w=Se.w,z.X=Se.X.slice(),z}function lt(Se,z){null==Se&&(Se=+new Date);var he=new ct(Se),ve=z&&z.state,re=function(){return(he.next()>>>0)/4294967296};return re.double=function(){do{var Me=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},re.int32=he.next,re.quick=re,ve&&(ve.X&&Pe(ve,he),re.state=function(){return Pe(he,{})}),re}qe&&qe.exports?qe.exports=lt:U.amdD&&U.amdO?void 0!==(We=function(){return lt}.call(It,U,It,qe))&&(qe.exports=We):this.xor4096=lt}(0,Dt=U.nmd(Dt))},114:function(Dt,It,U){var We;!function(nr,qe){function ct(Se){var z=this;z.next=function(){var ce,Ne,ve=z.x,re=z.i;return ce=ve[re],Ne=(ce^=ce>>>7)^ce<<24,Ne^=(ce=ve[re+1&7])^ce>>>10,Ne^=(ce=ve[re+3&7])^ce>>>3,Ne^=(ce=ve[re+4&7])^ce<<7,ce=ve[re+7&7],ve[re]=Ne^=(ce^=ce<<13)^ce<<9,z.i=re+1&7,Ne},function he(ve,re){var ce,Me=[];if(re===(0|re))Me[0]=re;else for(re=""+re,ce=0;ce<re.length;++ce)Me[7&ce]=Me[7&ce]<<15^re.charCodeAt(ce)+Me[ce+1&7]<<13;for(;Me.length<8;)Me.push(0);for(ce=0;ce<8&&0===Me[ce];++ce);for(8==ce&&(Me[7]=-1),ve.x=Me,ve.i=0,ce=256;ce>0;--ce)ve.next()}(z,Se)}function Pe(Se,z){return z.x=Se.x.slice(),z.i=Se.i,z}function lt(Se,z){null==Se&&(Se=+new Date);var he=new ct(Se),ve=z&&z.state,re=function(){return(he.next()>>>0)/4294967296};return re.double=function(){do{var Me=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},re.int32=he.next,re.quick=re,ve&&(ve.x&&Pe(ve,he),re.state=function(){return Pe(he,{})}),re}qe&&qe.exports?qe.exports=lt:U.amdD&&U.amdO?void 0!==(We=function(){return lt}.call(It,U,It,qe))&&(qe.exports=We):this.xorshift7=lt}(0,Dt=U.nmd(Dt))},704:function(Dt,It,U){var We;!function(nr,qe){function ct(Se){var z=this,he="";z.next=function(){var re=z.x^z.x>>>2;return z.x=z.y,z.y=z.z,z.z=z.w,z.w=z.v,(z.d=z.d+362437|0)+(z.v=z.v^z.v<<4^re^re<<1)|0},z.x=0,z.y=0,z.z=0,z.w=0,z.v=0,Se===(0|Se)?z.x=Se:he+=Se;for(var ve=0;ve<he.length+64;ve++)z.x^=0|he.charCodeAt(ve),ve==he.length&&(z.d=z.x<<10^z.x>>>4),z.next()}function Pe(Se,z){return z.x=Se.x,z.y=Se.y,z.z=Se.z,z.w=Se.w,z.v=Se.v,z.d=Se.d,z}function lt(Se,z){var he=new ct(Se),ve=z&&z.state,re=function(){return(he.next()>>>0)/4294967296};return re.double=function(){do{var Me=((he.next()>>>11)+(he.next()>>>0)/4294967296)/(1<<21)}while(0===Me);return Me},re.int32=he.next,re.quick=re,ve&&("object"==typeof ve&&Pe(ve,he),re.state=function(){return Pe(he,{})}),re}qe&&qe.exports?qe.exports=lt:U.amdD&&U.amdO?void 0!==(We=function(){return lt}.call(It,U,It,qe))&&(qe.exports=We):this.xorwow=lt}(0,Dt=U.nmd(Dt))},454:function(Dt,It,U){var We;!function(nr,qe,pn){var ce,ct=256,z=pn.pow(ct,6),he=pn.pow(2,52),ve=2*he;function Ne(Nt,Ft,$t){var ae=[],ee=Xn(Kn((Ft=1==Ft?{entropy:!0}:Ft||{}).entropy?[Nt,no(qe)]:Nt??function Ao(){try{var Nt;return ce&&(Nt=ce.randomBytes)?Nt=Nt(ct):(Nt=new Uint8Array(ct),(nr.crypto||nr.msCrypto).getRandomValues(Nt)),no(Nt)}catch{var Ft=nr.navigator,$t=Ft&&Ft.plugins;return[+new Date,nr,$t,nr.screen,no(qe)]}}(),3),ae),A=new Me(ae),we=function(){for(var He=A.g(6),Tt=z,gt=0;He<he;)He=(He+gt)*ct,Tt*=ct,gt=A.g(1);for(;He>=ve;)He/=2,Tt/=2,gt>>>=1;return(He+gt)/Tt};return we.int32=function(){return 0|A.g(4)},we.quick=function(){return A.g(4)/4294967296},we.double=we,Xn(no(A.S),qe),(Ft.pass||$t||function(He,Tt,gt,Pt){return Pt&&(Pt.S&&Ut(Pt,A),He.state=function(){return Ut(A,{})}),gt?(pn.random=He,Tt):He})(we,ee,"global"in Ft?Ft.global:this==pn,Ft.state)}function Me(Nt){var Ft,$t=Nt.length,ae=this,ee=0,A=ae.i=ae.j=0,we=ae.S=[];for($t||(Nt=[$t++]);ee<ct;)we[ee]=ee++;for(ee=0;ee<ct;ee++)we[ee]=we[A=255&A+Nt[ee%$t]+(Ft=we[ee])],we[A]=Ft;(ae.g=function(He){for(var Tt,gt=0,Pt=ae.i,An=ae.j,$n=ae.S;He--;)Tt=$n[Pt=255&Pt+1],gt=gt*ct+$n[255&($n[Pt]=$n[An=255&An+Tt])+($n[An]=Tt)];return ae.i=Pt,ae.j=An,gt})(ct)}function Ut(Nt,Ft){return Ft.i=Nt.i,Ft.j=Nt.j,Ft.S=Nt.S.slice(),Ft}function Kn(Nt,Ft){var ee,$t=[],ae=typeof Nt;if(Ft&&"object"==ae)for(ee in Nt)try{$t.push(Kn(Nt[ee],Ft-1))}catch{}return $t.length?$t:"string"==ae?Nt:Nt+"\0"}function Xn(Nt,Ft){for(var ae,$t=Nt+"",ee=0;ee<$t.length;)Ft[255&ee]=255&(ae^=19*Ft[255&ee])+$t.charCodeAt(ee++);return no(Ft)}function no(Nt){return String.fromCharCode.apply(0,Nt)}if(Xn(pn.random(),qe),Dt.exports){Dt.exports=Ne;try{ce=U(234)}catch{}}else void 0!==(We=function(){return Ne}.call(It,U,It,Dt))&&(Dt.exports=We)}(typeof self<"u"?self:this,[],Math)},817:()=>{},590:()=>{},530:()=>{},108:()=>{},551:()=>{},234:()=>{}},Dt=>{Dt(Dt.s=386)}]);